#!/bin/bash
# Copyright 2017 - 2024 Open Text.
#
# The only warranties for products and services of Open Text and its affiliates and licensors ("Open Text")
# are as may be set forth in the express warranty statements accompanying such products and services.
# Nothing herein should be construed as constituting an additional warranty. Open Text shall not be liable
# for technical or editorial errors or omissions contained herein. The information contained herein is subject
# to change without notice.
#
# Except as specifically indicated otherwise, this document contains confidential information and a valid
# license is required for possession, use or copying. If this work is provided to the U.S. Government,
# consistent with FAR 12.211 and 12.212, Commercial Computer Software, Computer Software
# Documentation, and Technical Data for Commercial Items are licensed to the U.S. Government under
# vendor's standard commercial license.


#see feature: OCTFT19S1761772
if [[ "bash" != "$(readlink /proc/$$/exe|xargs basename)" ]];then
    echo "Error: only bash support, current shell: $(readlink /proc/$$/exe)"
    exit 1
fi
set +o posix

### CDF bins
KCTL="${K8S_HOME:-'/opt/kubernetes'}/bin/kubectl"
JQ="${K8S_HOME:-'/opt/kubernetes'}/bin/jq"
### Setup of non-default paths
#In the case of BYOK the path is /usr/bin/kubectl
[[ -x "$KCTL" ]] || KCTL="/usr/bin/kubectl"
[[ -x "$JQ" ]] || JQ="/usr/bin/jq"
#Default to what is set in the path if we still dont have an executable
if [[ ! -x "$KCTL" ]]; then
    KCTL=$(type -p kubectl 2>/dev/null)
    [[ "$?" -ne 0 ]] && echo "[ERROR] 'kubectl' executable not found - Please add it to your PATH and try again." && exit 1
fi
if [[ ! -x "$JQ" ]]; then
    JQ=$(type -p jq 2>/dev/null)
    [[ "$?" -ne 0 ]] && echo "[ERROR] 'jq' executable not found - Please add it to your PATH and try again." && exit 1
fi

### Parsed yaml data is stored in these arrays
SECRETS_NAME=()
SECRETS_DESCRIPTION=()
SECRETS_COMPLEXITY=()
SECRETS_BASE64=()
SECRETS_FIXEDVALUE=()
SECRETS_FROMKEY=()

EXISTING_NAME=()
EXISTING_VALUE=()

### Logging
LOGFILE="/tmp/"`basename $0|cut -d'.' -f1`.`date "+%Y%m%d%H%M%S"`.log""

getRfcTime(){
    local fmt=$1
    date --rfc-3339=${fmt}|sed 's/ /T/'
}

log() {
    local consTimeFmt=$(getRfcTime 'seconds')
    local logTimeFmt=$(getRfcTime 'ns')
    if [[ ! -z "${2}" ]]; then
        case $2 in
            nolog)  echo -e "$consTimeFmt ${1}"   ;;
            noecho) echo -e "$logTimeFmt ${1}" >> "${LOGFILE}"   ;;
            *)      echo "[ERROR] log - Unknown argument: "${2}""
        esac
    else
        echo -e "$consTimeFmt ${1}"
        echo -e "$logTimeFmt ${1}" >> "${LOGFILE}"
    fi
}

### Intro
description() {
    echo "---------------------------------------"
    echo "-- OpenText vault-secrets utility --"
    echo "---------------------------------------"
    echo " "
}

### Usage
usage() {
    echo " "
    echo "Usage: ./$(basename $0) [-n|--namespace <namespace>] [-c|--chart </path/to/chart.tgz>] [-o <out.yaml>] [-u|--upgrade] [-d|--debug] [-v|--validate]" >&2
    echo "       -n|--namespace        mandatory - the namespace where the suite will be deployed "
    echo "       -c|--chart            mandatory - full path to the helm chart"
    echo "       -o|--output-yaml      write secrets to YAML output file (only) and do not create secrets"
    echo "       -u|--upgrade          only modifies new keys (not already present in the secret)"
    echo "       --update <K1>,<K2>,... modifies individual keys (comma-separated list) within the secret"
    echo "       -d|--debug            debugs the validation of the vault keys metadata and prints out the passwords at the end"
    echo "       -v|--validate         only validates the vault key metadata - does not create the K8s secret"
    echo " "
}

### Get params
CUST_SEC_NAME=
UPDATE=
getParams() {
    OPTPOS=()
    while [[ $# -gt 0 ]]
    do
        option="$1"
        case $option in
          -h|--help) usage && exit 0 ;;
          -n|--namespace)
                          NAMESPACE="${2}"
                          shift
                          shift
                          ;;
          -c|--chart)
                          CHART="${2}"
                          shift
                          shift
                          ;;
          -d|--debug)
                          VDEBUG=1
                          shift
                          ;;
          -s|--secret)    CUST_SEC_NAME="${2}"
                          shift 2
                          ;;
          --update)       UPDATE=$(echo "$2"| sed 's@,@\n@g') #@filename or Key1,Key2,...KeyN
                          [[ ! "$UPDATE" =~ @.* ]] || UPDATE=$(cat ${UPDATE#?})
                          [[ $? -ne 0 ]] && log "[ERROR] update flag $UPDATE must refer to readable file" && exit 1
                          shift
                          shift
                          ;;
          -u|--upgrade)   UPDATE=new
                          shift
                          ;;
          -v|--validate)
                          VONLY=1
                          shift
                          ;;
          -o|--output-yaml)
                          OUTPUTYAML="${2}"
                          shift
                          shift
                          ;;
          *)
                          OPTPOS+=("$1")
                          shift
                          ;;
        esac
        [[ $? -ne 0 ]] && log "[ERROR] Missing args for '$option'?" && _GPFLAG=1
    done

    set -- "${OPTPOS[@]}"

    INVALIDOPTS=`echo "${OPTPOS[@]}"`
    [[ ! -z "${INVALIDOPTS}" ]] && log "[ERROR] Invalid option(s) provided: "${INVALIDOPTS}"" && _GPFLAG=1
    [[ "${NAMESPACE}" =~ ^-.*$ ]] && log "[ERROR] An incorrect namespace was provided: "${NAMESPACE}"" && _GPFLAG=1
    [[ "${CHART}" =~ ^-.*$ ]] && log "[ERROR] An incorrect helm chart path was provided: "${CHART}"" && _GPFLAG=1
    [[ -z "${NAMESPACE}" ]] && log "[ERROR] Please provide the namespace where the suite will be installed (flag: -n|--namespace)" && _GPFLAG=1
    [[ -z "${CHART}" ]] && log "[ERROR] Please provide the path of the helm chart (flag: -c|--chart)" && _GPFLAG=1
    [[ "${_GPFLAG}" == "1" ]] && usage && exit 1
}

### Get YAMLs from chart
getYamls() {
    log "[INFO] Obtaining the required information from the chart..."
    CHARTPATH=`realpath "${CHART}"`
    if ! test `find "${CHARTPATH}"`; then
        if [[ -d "${CHARTPATH}" ]]; then
            log "[ERROR] The provided path is a directory. Please provide the full path of the helm chart" && exit 1
        else
            log "[ERROR] Could not locate the helm chart in the provided path: "${CHARTPATH}"" && exit 1
        fi
    fi
    # Get name of the provided tar of charts
    CHARTNAME=`basename "${CHARTPATH}"`
    CHARTDIR=`dirname "${CHARTPATH}"`

    # First two letters of chartname
    _FTL=`tar tf "${CHARTPATH}" | head -1 | awk -F/ '{print $1}'`

    [[ -n "$CUST_SEC_NAME" ]] &&
       log "[INFO] Using SECRET name: $CUST_SEC_NAME" nolog

    # Try to parse initSecrets from values.yaml
    [[ -z "$CUST_SEC_NAME" ]] &&
       VYAML_CONT=$(tar -zxOf "${CHARTPATH}" "${_FTL}/values.yaml")
       [[ $? -eq 0 ]] &&
          CUST_SEC_NAME=$(echo "$VYAML_CONT" |
             awk '/^ +initSecrets: ?/ {print $2}') &&
          [[ -n "$CUST_SEC_NAME" ]] &&
          log "[INFO] Found SECRET name: $CUST_SEC_NAME" nolog

    # Suite name from Chart.yaml
    [[ -z "$CUST_SEC_NAME" ]] &&
    CHARTYAML=`tar -zxOf "${CHARTPATH}" "${_FTL}"/Chart.yaml`
    CHARTYAMLRC=$?
    if [[ "${CHARTYAMLRC}" != "0" ]] && [[ -z "$CUST_SEC_NAME" ]]; then
        log "[ERROR] Failed to read 'Chart.yaml' in "${CHARTNAME}""
        log "${CHARTYAML}" nolog
        exit 1
    fi
    [[ -n "$CHARTYAML" ]] &&
    SUITE=`echo "${CHARTYAML}" | sed -n 's/^name://p' | sed -e 's/^[[:space:]]*//' | sed -e 's/[[:space:]]*$//'` &&
       log "[INFO] Found SUITE name: $SUITE" nolog


    # Vault Keys yaml
    VKYAML=`tar -zxOf "${CHARTPATH}" "${_FTL}"/templates/_vk.yaml`
    VKYAMLRC=`echo $?`
    if [[ "${VKYAMLRC}" != "0" ]]; then
        log "[ERROR] Failed to read the Vault Keys yaml file in "${CHARTNAME}""
        log "${VKYAML}" nolog
        exit 1
    fi

    log "[INFO] Done"
}


### YAML validation
unsetMe() {
    for unsetme in $@
    do
        unset "${unsetme}"
    done
}

parseYamlFile() {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
   sed -ne "s|,$s\]$s\$|]|" \
        -e ":1;s|^\($s\)\($w\)$s:$s\[$s\(.*\)$s,$s\(.*\)$s\]|\1\2: [\3]\n\1  - \4|;t1" \
        -e "s|^\($s\)\($w\)$s:$s\[$s\(.*\)$s\]|\1\2:\n\1  - \3|;p" $1 | \
   sed -ne "s|,$s}$s\$|}|" \
        -e ":1;s|^\($s\)-$s{$s\(.*\)$s,$s\($w\)$s:$s\(.*\)$s}|\1- {\2}\n\1  \3: \4|;t1" \
        -e    "s|^\($s\)-$s{$s\(.*\)$s}|\1-\n\1  \2|;p" | \
   sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)-$s[\"']\(.*\)[\"']$s\$|\1$fs$fs\2|p" \
        -e "s|^\($s\)-$s\(.*\)$s\$|\1$fs$fs\2|p" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" | \
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]; idx[i]=0}}
      if(length($2)== 0){  vname[indent]= ++idx[indent] };
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) { vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, vname[indent], $3);
      }
   }'
}

parseYaml() {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
   echo "${1}" | sed -ne "s|,$s\]$s\$|]|" \
        -e ":1;s|^\($s\)\($w\)$s:$s\[$s\(.*\)$s,$s\(.*\)$s\]|\1\2: [\3]\n\1  - \4|;t1" \
        -e "s|^\($s\)\($w\)$s:$s\[$s\(.*\)$s\]|\1\2:\n\1  - \3|;p" | \
   sed -ne "s|,$s}$s\$|}|" \
        -e ":1;s|^\($s\)-$s{$s\(.*\)$s,$s\($w\)$s:$s\(.*\)$s}|\1- {\2}\n\1  \3: \4|;t1" \
        -e    "s|^\($s\)-$s{$s\(.*\)$s}|\1-\n\1  \2|;p" | \
   sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)-$s[\"']\(.*\)[\"']$s\$|\1$fs$fs\2|p" \
        -e "s|^\($s\)-$s\(.*\)$s\$|\1$fs$fs\2|p" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" | \
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]; idx[i]=0}}
      if(length($2)== 0){  vname[indent]= ++idx[indent] };
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) { vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, vname[indent], $3);
      }
   }'
}

getExistingK8sSecret() {
    if [[ -z "${UPDATE}" ]] ;then
      return
    fi
    S_NAME=${CUST_SEC_NAME:-$SUITE-secret}

    # Save backup of the secret in k8s
    eval ${KCTL} get -n "$NAMESPACE" "secrets/${S_NAME}" > /dev/null
    if [[ $? -eq 0 ]] ;then
        log "[INFO] Saving backup of existing secret as '${S_NAME}-backup'"

        `${KCTL} get -n "$NAMESPACE" "secrets/${S_NAME}" -o yaml |\
          sed -e "s/${S_NAME}/${S_NAME}-backup/g" |\
          ${KCTL} apply -n "$NAMESPACE" --force -f - > /dev/null 2> /dev/null`

        if [[ $? -ne 0 ]] ;then
            log "[ERROR] can't create backup of secret as \"${S_NAME}-backup\" already exists"
        fi
    else
        log "[INFO] No existing secrets, continuing with standard install steps."
        unsetMe UPDATE
        return
    fi

    # Get secret as json for easier parsing with 'jq'
    EXISTING_JSON=$(${KCTL} get -n "$NAMESPACE" "secrets/${S_NAME}" -o json)
    EXISTING_DATA=$(echo "$EXISTING_JSON" | $JQ -r '.data')

    # Use two arrays for existing secret keys and their values [preserving order]
    keys=( $(echo "$EXISTING_DATA" | $JQ '. | to_entries[] | .key' | sed 's/"//g') )
    values=( $(echo "$EXISTING_DATA" | $JQ '. | to_entries[] | .value' | sed 's/"//g') )
    for i in ${!keys[@]}
    do
        # Filter out --update keys/values. In jq >1.4 filtering EXISTING_DATA with inside() would be preferable.
        [[ $UPDATE =~ ${keys[$i]} ]] && continue
        EXISTING_NAME+=("${keys[$i]}")
        EXISTING_VALUE+=("${values[$i]}")
    done

    # Collect all keys in single string for quick regex lookup of what's configured already
    # NB we leave --update keys/values and need to be conscious of usage
    EXISTING=$(echo "$EXISTING_DATA" | $JQ '. | to_entries[] | join(": ")' | xargs -l1 | tr -d '\n')
}

constructArrays() {
    getExistingK8sSecret
    eval $(parseYaml "${VKYAML}")
    for (( key=1; key<=1000; key++ ))
    do
        for property in "name" "description" "complexity" "base64" "fixedValue" "fromKey" "specialChars"
        do
            SEARCH_PATTERN="vaultKeys_"${key}"_"${property}""
            PROP_VALUE=`echo "${!SEARCH_PATTERN}" | sed -e 's/^[[:space:]]*//' | sed -e 's/[[:space:]]*$//'`
            if [[ "${property}" == "name" ]] && [[ -z "${PROP_VALUE}" ]]; then
                break
            # grep if property name already exists for updating, if so, don't to ask for value
            # leave --update keys NB we short-circuit the AND before the EXISTING test would fail
            elif [[ "${property}" == "name" && ! $UPDATE =~ $PROP_VALUE ]] && echo "$EXISTING" | grep -q "${PROP_VALUE}"; then
                log "[INFO] secret '${PROP_VALUE}' has already been configured."
                break
            else
                if [[ -z "${PROP_VALUE}" ]]; then
                    eval "SECRETS_${property^^}+=(\"0\")"
                else
                    eval "SECRETS_${property^^}+=(\"\$PROP_VALUE\")"
                fi
            fi
        done
    done

    if [[ "${VDEBUG}" == "1" ]]; then
        echo "${_u_logIndent}- secret keys to update: "${SECRETS_NAME[@]}""
    fi

    if [[ ${#SECRETS_NAME[@]} == "0" ]] && [[ ${#EXISTING_NAME[@]} == 0 ]]; then
        log "[ERROR] Could not retrieve any Vault key from the _vk.yaml file inside the provided chart. Please contact  OpenText support"
        exit 1
    fi
}

getName() {
    S_NAME=`echo "${SECRETS_NAME[${1}]}"`
}

getDesc() {
    S_DESC=`echo "${SECRETS_DESCRIPTION[${1}]}"`
    if [[ "${S_DESC}" == "0" ]]; then
        local _S_FV=`echo "${SECRETS_FIXEDVALUE[${1}]}"`
        local _S_AV=`echo "${SECRETS_FROMKEY[${1}]}"`
        if [[ "${_S_FV}" == "0" && "${_S_AV}" == "0" ]]; then
            checkNameInErrArr
            eval "ERR_DESC_${ENINDX}+=(\"Description not provided\")"
        fi
    fi
}

getEncoding() {
    S_ENC=`echo "${SECRETS_BASE64[${1}]}"`
    if [[ "${S_ENC}" == "0" ]] || [[ "${S_ENC}" == "false" ]]; then
        SECRETS_BASE64[${1}]="false"
    elif [[ "${S_ENC}" == "true" ]]; then
        return
    else
        checkNameInErrArr
        eval "ERR_ENC_${ENINDX}+=(\"Invalid value provided: ${S_ENC}\")"
    fi
}

getComplexity() {
    S_COM=`echo "${SECRETS_COMPLEXITY[${1}]}"`
    local OCC_ARR=()
    local C_CODES=`echo "${S_COM}" | tr ";" "\n" | sed -e 's/^[[:space:]]*//' | sed -e 's/[[:space:]]*$//'`
    local OLD_IFS=$IFS
    IFS=$'\n'

    # do not perform the complexity check if key has either 'fromKey' or 'fixedValue' property
    local _K_FV=`echo "${SECRETS_FIXEDVALUE[$indx]}"`
    local _K_AV=`echo "${SECRETS_FROMKEY[$indx]}"`
    if [[ "${_K_FV}" == "0" && "${_K_AV}" == "0" ]]; then
        # step 1 - check that codes in complexity string are OK
        for code in $C_CODES
        do
            if codeOccurence $code; then
                checkNameInErrArr
                eval "ERR_COM_${ENINDX}+=(\"Complexity code: ${code} is declared multiple times\")"
            fi
            case $code in
                # 0 - complexity not provided or empty -> use default
                0|default)
                          SECRETS_COMPLEXITY[${1}]="default"
                          IFS=$OLD_IFS
                          return
                          ;;
                none)     C_NONE=1 ;;
                random)   C_RAND=1 ;;
                optional) C_OPT=1  ;;
                L*)       c_getLength $code ;;
                A)        C_ALPH=1 ;;
                N)        C_NUM=1 ;;
                *)
                          checkNameInErrArr
                          eval "ERR_COM_${ENINDX}+=(\"Invalid complexity code: ${code}\")" && COM_FLAG_ERR=1
            esac
        done
        IFS=$OLD_IFS
        # continue to check the code combos only if individual code validation passed
        getIndexInErrNameArr "${S_NAME}"
        local COM_ERRORS=$(eval echo \${\#ERR_COM_${ENINDX}[@]})
        if [ "${COM_ERRORS}" == "0" ]; then
            validateComplexityCombo
        fi
        unset ENINDX
    else
        IFS=$OLD_IFS
    fi
}

validateComplexityCombo() {
    # This function deals only with complexity codes that pased the first validation
    # It checks that provided code combos are OK
    for code in $C_CODES
    do
      case $code in
        none)
            for xcode in $C_CODES
            do
              case $xcode in
                optional) ;;
                none)     ;;
                *)
                  if [ "${FLAG_NONE_ERR}" != "1" ]; then
                    checkNameInErrArr
                    eval "ERR_COM_${ENINDX}+=(\"Invalid usage of complexity code: 'none' - 'none' can be used in combination with 'optional', or alone\")"
                    local FLAG_NONE_ERR=1
                  fi
              esac
            done
            ;;
        optional)
            for xcode in $C_CODES
            do
              case $xcode in
                random)
                  checkNameInErrArr
                  eval "ERR_COM_${ENINDX}+=(\"Invalid usage of complexity code: 'optional' - 'optional' cannot be used in combination with 'random'\")"
                  local FLAG_OPT_ERR=1
                  ;;
                *) ;;
              esac
            done
            ;;
        random)
            for xcode in $C_CODES
            do
              case $xcode in
                optional|none)
                  if [ "${FLAG_RAND_ERR}" != "1" ]; then
                    checkNameInErrArr
                    eval "ERR_COM_${ENINDX}+=(\"Invalid usage of complexity codes: 'random' - 'random' cannot be used in combination with 'optional' or 'none'\")"
                    local FLAG_RAND_ERR=1
                  fi
                  ;;
                *) ;;
              esac
            done
            ;;
        *) ;;
      esac
    done

    # Mandatory unsets
    unsetMe C_NONE C_RAND C_OPT C_ALPH C_NUM FLAG_NONE_ERR FLAG_OPT_ERR FLAG_RAND_ERR
}

codeOccurence() {
    if [ "${1}" == "0" ]; then
        return 1
    else
        if [ `echo "${C_CODES}" | grep -w -x $1 | wc -l` -gt 1 ]; then
            if checkCodeInArray $1; then
                return 0
            else
                return 1
            fi
        else
            return 1
        fi
    fi
}

checkCodeInArray() {
    CHK_OCC=`echo "${OCC_ARR[@]}" | tr " " "\n" | grep -x $1`
    if [ -z "${CHK_OCC}" ]; then
        OCC_ARR+=("${1}")
        return 0
    else
        return 1
    fi
}

checkNameInErrArr() {
    CHK_KNAME=`echo "${ERR_NAME[@]}" | tr " " "\n" | grep -x "${S_NAME}"`
    if [ -z "${CHK_KNAME}" ]; then
        ERR_NAME+=("${S_NAME}")
    fi
    getIndexInErrNameArr "${S_NAME}"
}

getIndexInErrNameArr() {
    for eindx in "${!ERR_NAME[@]}"
    do
        _EINDX=`echo "${ERR_NAME[$eindx]}"`
        if [[ "${ERR_NAME[$eindx]}" == "${1}" ]]; then
            ENINDX="${eindx}"
        fi
    done

}

c_getLength() {
    CL="${code:1:2}"
    if [[ "${CL}" -ge 4 && "${CL}" -le 64 ]]; then
        C_LENGTH="${CL}"
    else
        checkNameInErrArr
        eval "ERR_COM_"${ENINDX}"+=(\"Invalid length code: ${code} (must be an integer in interval [4-64]\")"
    fi
}

getAssignedValue() {
    S_AVAL=`echo "${SECRETS_FROMKEY[${1}]}"`
    if [[ "${S_AVAL}" == "0" ]]; then
        return
    else
        for _keyname in "${SECRETS_NAME[@]}"
        do
            if [[ "${S_AVAL}" == "${_keyname}" ]]; then
                local _FOUND=1
                # get index of key whose value is inherited
                local I_KEY_INDX=`echo ${SECRETS_NAME[@]/"${S_AVAL}"//} | cut -d/ -f1 | wc -w | tr -d ' '`
                # check if parent key inherits a value from another key
                local I_KEY_AVAL=`echo "${SECRETS_FROMKEY[${I_KEY_INDX}]}"`
                if [[ "${I_KEY_AVAL}" == "0" ]]; then
                    # parent key does not inherit any value
                    break
                else
                    # parent key inherits value from another key
                    checkNameInErrArr
                    eval "ERR_FVAL_${ENINDX}+=(\"Cannot inherit value from: "${S_AVAL}" because this key has it's value inherited. Please assign to the 'fromKey' property only a key name whose value is either user-provided, fixed, or randomly generated\")"
                    break
                fi
            else
                local _FOUND=0
            fi
        done
        if [[ "${_FOUND}" != '1' ]]; then
            for _exist_keyname in "${EXISTING_NAME[@]}"
            do
                if [[ "${S_AVAL}" == "${_exist_keyname}" ]]; then
                    local _FOUND=1
                    break
                else
                    local _FOUND=0
                fi
            done
        fi
        if [[ "${_FOUND}" == "1" ]]; then
            local S_AVAL_CHECK_FVAL=`echo "${SECRETS_FIXEDVALUE[${1}]}"`
            if [[ "${S_AVAL_CHECK_FVAL}" != "0" ]]; then
                checkNameInErrArr
                eval "ERR_FVAL_${ENINDX}+=(\"Cannot have both 'fixedValue' and 'fromKey' properties defined\")"
            else
                return
            fi
        else
            checkNameInErrArr
            eval "ERR_FVAL_${ENINDX}+=(\"Value cannot be assigned from key: "${S_AVAL}" because this key name is not present in the key yaml file\")"
        fi
    fi
}

getSpecialChars() {
    S_SCHARS=`echo "${SECRETS_SPECIALCHARS[${1}]}"`
    if [[ "${S_SCHARS}" == "0" ]]; then
        return
    else
        if `echo "$S_SCHARS" | grep -q "[[:space:]]"`; then
            checkNameInErrArr
            eval "ERR_SCHAR_${ENINDX}+=(\"The provided special characters list contains spaces\")"
        fi
        _S_COM=`echo "${SECRETS_COMPLEXITY[${1}]}"`
        if [[ "${_S_COM}" =~ "none" ]]; then
            checkNameInErrArr
            eval "ERR_SCHAR_${ENINDX}+=(\"Cannot use a defined special chars list and complexity: '"${_S_COM}"'\")"
        fi
    fi
}

validateYamlData() {
    log "[INFO] Validating the Vault Keys yaml file..."
    constructArrays
    local V_KEYS=`echo "${#SECRETS_NAME[@]}"`
    for (( indx=0; indx<"${V_KEYS}"; indx++ ))
    do
        getName $indx
        getDesc $indx
        getEncoding $indx
        getComplexity $indx
        getAssignedValue $indx
        getSpecialChars $indx
    done

    if [[ `echo "${#ERR_NAME[@]}"` != "0" ]]; then
        local FAILED_KEYS=`echo "${#ERR_NAME[@]}"`
        log "[ERROR] The file does not have the correct internal structure"
        if [ "${VDEBUG}" != "1" ]; then
            log "[ERROR] Please contact OpenText support"
            exit 1
        fi
        log "[ERROR] Check below to see for which Vault keys, the provided properties could not be validated:" nolog
        log " " nolog
        for (( kn=0; kn<"${FAILED_KEYS}"; kn++ ))
        do
            local FKEY_NAME=`echo "${ERR_NAME[$kn]}"`
            log "$((kn+1)). Key name: "${FKEY_NAME}"" nolog
            for cprop in "ENC" "COM" "DESC" "FVAL" "SCHAR"
            do
                [ "${cprop}" == "ENC" ] && PROP_NAME="   [Encoding]"
                [ "${cprop}" == "COM" ] && PROP_NAME="   [Complexity]"
                [ "${cprop}" == "DESC" ] && PROP_NAME="   [Description]"
                [ "${cprop}" == "FVAL" ] && PROP_NAME="   [fromKey]"
                [ "${cprop}" == "SCHAR" ] && PROP_NAME="   [SpecialChars]"
                local ERRS=$(eval echo \${\#ERR_${cprop}_${kn}[@]})
                if [[ "${ERRS}" != "0" ]]; then
                    log "$PROP_NAME" nolog
                    for (( err=0; err<"${ERRS}"; err++ ))
                    do
                        log "   -- $(eval echo \${ERR_${cprop}_${kn}[${err}]})" nolog
                    done
                    log " " nolog
                fi
            done
        done
        exit 1
    else
        log "[INFO] All good"
        [[ "${VONLY}" != "1" ]] && [[ `echo "${#EXISTING_NAME[@]}"` == 0 ]] && log "[INFO] Please follow the list below, and provide a value for each Vault Key that requires your input" nolog && log "[INFO] Getting user input..." noecho
        echo " "
    fi
}
### /YAML validation

# Sets var _R_output to the value of variable GENERATE_SECRETS__$UKN
# and returns true in case GENERATE_SECRETS__$UKN is not empty. False otherwise.
envPreSetInput() {
    local env_var_name="GENERATE_SECRETS__${UKN}"
    _R_output=${!env_var_name}
    [[ -n "$_R_output" ]]
}

### User input and pass generation
readUserInputSub() {
    local _skip="${1}"
    local _input=''

    # Return early in case a corresponding env. var holding the secret has been set.
    envPreSetInput && return

    echo -n "${_g_logIndent}Provide value: "
    while IFS= read -r -s -n1 _char; do
        if [[ -z $_char ]]; then
            if [[ -z "${_input}" ]]; then
                if [[ -z "${_skip}" ]]; then
                    echo " "
                    echo -e "${_g_logIndent}[ERROR] Value cannot be empty"
                    echo -n "${_g_logIndent}Provide value: "
                else
                    _skipConfirm=1
                    echo " "
                    echo -e "${_g_logIndent}--OK"
                    printf '\n'
                    break
                fi
            else
                printf '\n'
                break
            fi
        elif [[ $_char == $'\x7f' ]]; then
            [[ -n $_input ]] && _input=${_input%?}
            printf '\b \b'
        else
            _input+="${_char}"
            printf '*'
        fi
    done
    _R_output="${_input}"
}

# Sets var _R_confirm to the value of variable GENERATE_SECRETS__$UKN
# and returns true in case GENERATE_SECRETS__$UKN is not empty. False otherwise.
# In addition, the GENERATE_SECRETS__$UKN variable is unset
envPreSetConfirm() {
    local env_var_name="GENERATE_SECRETS__${UKN}"
    _R_confirm=${!env_var_name}
    printf -v "$env_var_name" '%s' ''
    [[ -n $_R_confirm ]]
}

confirmUserInput() {
    local _confirm=''

    # Return early in case a corresponding env. var holding the secret has been set.
    envPreSetConfirm && return

    echo -n "${_g_logIndent}Confirm value: "
    while IFS= read -r -s -n1 _char; do
        if [[ -z $_char ]]; then
            if [[ -z "${_confirm}" ]]; then
                echo " "
                echo "${_g_logIndent}[ERROR] Value cannot be empty"
                echo -n "${_g_logIndent}Confirm value: "
            else
                printf '\n'
                break
            fi
        elif [[ $_char == $'\x7f' ]]; then
            [[ -n $_confirm ]] && _confirm=${_confirm%?}
            printf '\b \b'
        else
            _confirm+=$_char
            printf '*'
        fi
    done
    _R_confirm="${_confirm}"
}

readUserInput() {
    local _skip="${1}"
    readUserInputSub "${_skip}"
    if [[ "${_skipConfirm}" != "1" ]]; then
        confirmUserInput
    fi
    if [[ ! -z "${_R_output}" ]]; then
        while [[ "${_R_output}" != "${_R_confirm}" ]]
        do
            echo "${_g_logIndent}[WARN] Values don't match, try again"
            unsetMe _R_output _R_confirm
            readUserInputSub "${_skip}"
            if [[ "${_skipConfirm}" != "1" ]]; then
                confirmUserInput
            fi
        done
    fi
    unsetMe _skipConfirm
}

validatePwdSub() {
    local _patternsAmount=$(echo "${#_PATT[@]}")
    local n=0
    if [[ "${UKS}" != "0" ]]; then
        local c=0
        for (( currChar=0; currChar<"${#_vp_string}"; currChar++ ))
        do
            for _patt in "[a-z]" "[A-Z]" "[0-9]"
            do
                if [[ $(echo "${_vp_string:$currChar:1}" | grep -P "${_patt}" >/dev/null 2>&1; echo $?) -ne 0 ]]; then
                    # current char is not alpha-numeric
                    c=1
                else
                    # current char is alpha-numeric; set flag for the matched pattern
                    case $_patt in
                        '[a-z]') _matchAlphaLower=1 ;;
                        '[A-Z]') _matchAlphaUpper=1 ;;
                        '[0-9]') _matchNumeric=1    ;;
                        *)       _empty=1           ;;
                    esac
                    c=0
                    break
                fi
            done
            if [[ "${c}" -eq "1" ]]; then
                if grep -qF "${_vp_string:$currChar:1}" <<< "$UKS"; then
                    # current char is one from the specialChars list in _vk.yaml
                    _matchSpecialChar=1
                    c=0
                fi
            fi
            # c=1 means that current char does not match any pattern: [a-z] [A-Z] [0-9] [$UKS]
            [[ "${c}" == "1" ]] && break
        done
        # analyze results
        if [[ "${c}" == "1" ]]; then
            # one char from the string is not compliant
            return 1
        else
            # verify that all 4 pattern checks have passed
            if [[ "${_matchAlphaLower}" == "1" ]] && [[ "${_matchAlphaUpper}" == "1" ]] && [[ "${_matchNumeric}" == "1" ]] && [[ "${_matchSpecialChar}" == "1" ]]; then
                n=$((n+4))
            else
                return 1
            fi
        fi
    else
        for _pattern in "${_PATT[@]}"
        do
            if [[ $(echo "${_vp_string}" | grep -P "$_pattern" >/dev/null 2>&1; echo $?) -eq 0 ]]; then
                n=$((n+1))
            fi
        done
    fi
    local _vp_string_len=`echo ${#_vp_string}`
    if [[ "${_VAL_FIXED_LEN}" == "0" ]]; then
        if [ $(echo ${_vp_string} | grep -P "\s" >/dev/null 2>&1; echo $?) -ne 0 -a ${_vp_string_len} -ge 8 -a ${_vp_string_len} -le 64 -a $n -ge $_patternsAmount ]; then
            return 0
        else
            return 1
        fi
    else
        if [ $(echo ${_vp_string} | grep -P "\s" >/dev/null 2>&1; echo $?) -ne 0 -a ${_vp_string_len} -eq ${_vp_length} -a $n -ge $_patternsAmount ]; then
            return 0
        else
            return 1
        fi
    fi
}

validatePwdMain() {
    # 1 - pattern
    # 2 - length
    # 3 - string to validate
    local _vp_patt="${1}"
    local _vp_length="${2}"
    local _vp_string="${3}"
    _PATT=()
    case $_vp_patt in
        alpha)
                eval "_PATT+=(\"[a-z]\")"
                eval "_PATT+=(\"[A-Z]\")"
                ;;
        digit)
                eval "_PATT+=(\"[0-9]\")"
                ;;
        alnum)
                eval "_PATT+=(\"[a-z]\")"
                eval "_PATT+=(\"[A-Z]\")"
                eval "_PATT+=(\"[0-9]\")"
                ;;
        graph)
                eval "_PATT+=(\"[a-z]\")"
                eval "_PATT+=(\"[0-9]\")"
                eval "_PATT+=(\"[A-Z]\")"
                if [[ "${UKS}" == "0" ]]; then
                    eval "_PATT+=(\"[^0-9a-zA-Z]\")"
                else
                    eval "_PATT+=(\"[${UKS}]\")"
                fi
                ;;
        *)     log "[ERROR] validatePwdMain - Invalid argument provided:" "${_vp_patt}"; exit 1    ;;
    esac
    validatePwdSub
    if [ $? -eq 0 ]; then
        unsetMe _PATT _matchAlphaLower _matchAlphaUpper _matchNumeric _matchSpecialChar
        return 0
    else
        unsetMe _PATT _matchAlphaLower _matchAlphaUpper _matchNumeric _matchSpecialChar
        return 1
    fi
}

validatePwdNoneOpt() {
    # 1 - string
    _noLength="${#1}"
    if [[ $(echo "${1}" | grep -P '[a-z]' >/dev/null 2>&1; echo $?) -eq 0 || $(echo "${1}" | grep -P '[A-Z]' >/dev/null 2>&1; echo $?) -eq 0 || $(echo "${1}" | grep -P '[0-9]' >/dev/null 2>&1; echo $?) -eq 0 || $(echo "${1}" | grep -P '[^0-9a-zA-Z]' >/dev/null 2>&1; echo $?) -eq 0 ]]; then
        if [ $(echo "${1}" | grep -P "\s" >/dev/null 2>&1; echo $?) -ne 0 -a "${_noLength}" -ge 1 -a "${_noLength}" -le 64 ]; then
            return 0
        else
            return 1
        fi
    else
        return 1
    fi
}
generateRandomSub() {
    local _g_type="${1}"
    local _g_length="${2}"
    case "${_g_type}" in
      alpha)    GENERATED=`< /dev/urandom tr -cd '[:alpha:]' | head -c $_g_length; echo`           ;;
      digit)    GENERATED=`< /dev/urandom tr -cd '[:digit:]' | head -c $_g_length; echo`           ;;
      alnum)    GENERATED=`< /dev/urandom tr -cd '[:alnum:]' | head -c $_g_length; echo`           ;;
      graph)
                GEN_ALNUM=`< /dev/urandom tr -cd '[:alnum:]' | head -c $((_g_length-1)); echo`
                if [[ "${UKS}" == "0" ]]; then
                    GEN_GRAPH=`< /dev/urandom tr -cd '!@#^()_+=[]{}?' | head -c 1; echo`
                else
                    GEN_GRAPH=`< /dev/urandom tr -cd -- "${UKS}" 2>/dev/null| head -c 1; echo`
                fi
                GENERATED=""${GEN_ALNUM}""${GEN_GRAPH}""
                ;;
      *)        log "[ERROR] generateRandomSub - Invalid argument provided:" "${_g_type}"; exit 1    ;;
    esac

}

generateRandom() {
    local g_type="${1}"
    local g_length="${2}"
    local _GFLAG=0
    while [[ "${_GFLAG}" == "0" ]]
    do
        generateRandomSub "${g_type}" "${g_length}"
        validatePwdMain "${g_type}" "${g_length}" "${GENERATED}"
        if [[ $? -eq 0 ]]; then
            _GFLAG=1
        else
            unsetMe GENERATED
            generateRandomSub "${g_type}" "${g_length}"
            validatePwdMain "${g_type}" "${g_length}" "${GENERATED}"
        fi
    done
}

checkBase64() {
    if [[ "${UKE}" == "true" ]]; then
        _TNAME=`echo ${SECRETS_NAME[$uindx]}`
        _TNAME=""$_TNAME"_B64"
        SECRETS_NAME[$uindx]="${_TNAME}"
    fi
}

listNormArr() {
    NORM_LST=`echo "${NORM[@]}"`
    for norm in $NORM_LST
    do
        case $norm in
            A)  NALPH=1 ;;
            N)  NNUM=1 ;;
            L*) NLEN="${norm:1:2}" ;;
            *)  NNUL=1 ;;
        esac
    done
}

u_addValInArr() {
    local _val="${1}"
    SECRETS_VALS[$uindx]="${_val}"
    unsetMe GENERATED
}

u_resolveDefault() {
    echo " "
    echo "${_g_logIndent}[INFO] This Vault Key requires the following complexity:"
    local _u_logIndent="$_g_logIndent       "
    echo "${_u_logIndent}- length: 8-64 characters"
    echo "${_u_logIndent}- at least 1 lower case"
    echo "${_u_logIndent}- at least 1 upper case"
    echo "${_u_logIndent}- at least 1 digit"
    if [[ "${UKS}" == "0" ]]; then
        echo "${_u_logIndent}- at least 1 printable special character"
    else
        echo "${_u_logIndent}- at least one of the following allowed special characters: "${UKS}""
    fi
    echo " "
    local _VAL_FIXED_LEN=0
    local _RDEF=0
    while  [[ "${_RDEF}" == "0" ]]
    do
         readUserInput
         validatePwdMain graph 8 "${_R_output}"
         if [[ $? -eq 0 ]]; then
             _RDEF=1
         else
             echo "${_g_logIndent}[ERROR] Your input does not match the required complexity, try again"
         fi
    done
    echo "${_g_logIndent}-- OK"
    checkBase64
    u_addValInArr "${_R_output}"
    unsetMe _R_output _R_confirm
}

u_resolveNormSub(){
    # 1 - pattern
    # 2 - length
    local _NORMVAL=0
    while  [[ "${_NORMVAL}" == "0" ]];
    do
        readUserInput
        validatePwdMain "${1}" "${2}" "${_R_output}"
        if [[ $? -eq 0 ]]; then
            _NORMVAL=1
        else
            echo "${_g_logIndent}[ERROR] Your input does not match the required complexity, try again"
        fi
    done

    if [[ "${_NORMVAL}" == "1" ]]; then
        echo "${_g_logIndent}-- OK"
        checkBase64
        u_addValInArr "${_R_output}"
        unsetMe _R_output _R_confirm _OPTRAND _OPTVAL
    fi
}

u_resolveNorm() {
    listNormArr
    echo " "
    echo "${_g_logIndent}[INFO] This Vault Key requires the following complexity:"
    local _u_logIndent="$_g_logIndent       "
    if [ -z "${NLEN}" ]; then
        NLEN=8
        local _VAL_FIXED_LEN=0
        echo "${_u_logIndent}- length: "${NLEN}"-64 characters"
    else
        local _VAL_FIXED_LEN=1
        echo "${_u_logIndent}- fixed length:" "${NLEN}" "characters"
    fi
    if [[ -z "${NALPH}" ]]; then
        if [[ -z "${NNUM}" ]]; then
            echo "${_u_logIndent}- at least 1 lower case"
            echo "${_u_logIndent}- at least 1 upper case"
            echo "${_u_logIndent}- at least 1 digit"
            if [[ "${UKS}" == "0" ]]; then
                echo "${_u_logIndent}- at least 1 printable special character"
            else
                echo "${_u_logIndent}- at least one of the following allowed special characters: "${UKS}""
            fi
            u_resolveNormSub graph "${NLEN}"
        else
            echo "${_u_logIndent}- only digits"
            u_resolveNormSub digit "${NLEN}"
        fi
    else
        if [[ -z "${NNUM}" ]]; then
            echo "${_u_logIndent}- alphabetical chars only"
            echo "${_u_logIndent}- at least 1 lower case"
            echo "${_u_logIndent}- at least 1 upper case"
            u_resolveNormSub alpha "${NLEN}"
        else
            echo "${_u_logIndent}- alpha numeric characters"
            echo "${_u_logIndent}- at least 1 lower case"
            echo "${_u_logIndent}- at least 1 upper case"
            echo "${_u_logIndent}- at least 1 digit"
            u_resolveNormSub alnum "${NLEN}"
        fi
    fi
    unsetMe _VAL_FIXED_LEN NLEN NALPH NNUM
}

u_generateRandomSub() {
    # 1 - pattern
    # 2 - length
    generateRandom "${1}" "${2}"
    checkBase64
    u_addValInArr "${GENERATED}"
    unsetMe GENERATED _vp_string
}

u_generateRandom() {
    listNormArr
    if [[ "${VDEBUG}" == "1" ]]; then
        echo "${_g_logIndent}[INFO] The value for Vault key: "${UKN}", will be automatically generated"
        local _u_logIndent="$_g_logIndent       "
        echo "${_u_logIndent}The complexity of the generated string will be:"
    fi
    if [ -z "${NLEN}" ]; then
        NLEN=8
        local _VAL_FIXED_LEN=0
        if [[ "${VDEBUG}" == "1" ]]; then
            echo "${_u_logIndent}- length: "${NLEN}"-64 characters"
        fi
    else
        local _VAL_FIXED_LEN=1
        if [[ "${VDEBUG}" == "1" ]]; then
            echo "${_u_logIndent}- fixed length:" "${NLEN}" "characters"
        fi
    fi
    if [[ -z "${NALPH}" ]]; then
        if [[ -z "${NNUM}" ]]; then
            if [[ "${VDEBUG}" == "1" ]]; then
                echo "${_u_logIndent}- at least 1 lower case"
                echo "${_u_logIndent}- at least 1 upper case"
                echo "${_u_logIndent}- at least 1 digit"
                if [[ "${UKS}" == "0" ]]; then
                    echo "${_u_logIndent}- at least 1 printable special character"
                else
                    echo "${_u_logIndent}- at least one of the following allowed special characters: "${UKS}""
                fi
                echo " "
            fi
            u_generateRandomSub graph "${NLEN}"
        else
            if [[ "${VDEBUG}" == "1" ]]; then
                echo "${_u_logIndent}- only digits"
                echo " "
            fi
            u_generateRandomSub digit "${NLEN}"
        fi
    else
        if [[ -z "${NNUM}" ]]; then
            if [[ "${VDEBUG}" == "1" ]]; then
                echo "${_u_logIndent}- alphabetical chars only"
                echo "${_u_logIndent}- at least 1 lower case"
                echo "${_u_logIndent}- at least 1 upper case"
                echo " "
            fi
            u_generateRandomSub alpha "${NLEN}"
        else
            if [[ "${VDEBUG}" == "1" ]]; then
                echo "${_u_logIndent}- alpha numeric characters"
                echo "${_u_logIndent}- at least 1 lower case"
                echo "${_u_logIndent}- at least 1 upper case"
                echo "${_u_logIndent}- at least 1 digit"
                echo " "
            fi
            u_generateRandomSub alnum "${NLEN}"
        fi
    fi
    unsetMe _VAL_FIXED_LEN NLEN NALPH NNUM
}

u_resolveNoneOpt() {
    echo " "
    echo "${_g_logIndent}(Optional) You can either provide a value for this Key OR press <ENTER> and a random value will be generated instead"
    local _u_logIndent="$_g_logIndent           "
    echo "${_u_logIndent}If a value is provided, then:"
    echo "${_u_logIndent} - it must contain printable characters (no spaces, carriage returns, tabs, line breaks, page breaks, null chars)"
    echo "${_u_logIndent} - it must be a [1-64] characters long"
    echo " "
    echo "${_u_logIndent}If you opt for a randomly generated value, then the complexity of the generated string will be:"
    echo "${_u_logIndent}- fixed length: 8"
    echo "${_u_logIndent}- alpha numeric characters"
    echo "${_u_logIndent}- at least 1 lower case"
    echo "${_u_logIndent}- at least 1 upper case"
    echo "${_u_logIndent}- at least 1 digit"
    echo "${_u_logIndent}- at least 1 printable special character"
    echo " "
    local _NOPTVAL=0
    local _NOPTRAND=0
    while  [[ "${_NOPTVAL}" == "0" && "${_NOPTRAND}" == "0" ]]
    do
         readUserInput skip
         if [[ ! -z "${_R_output}" ]]; then
             validatePwdNoneOpt "${_R_output}"
             if [[ $? -eq 0 ]]; then
                 _NOPTVAL=1
             else
                 echo "${_g_logIndent}[ERROR] Your input must be a printable character (no spaces, carriage returns, tabs, line breaks, page breaks, null chars), and it must be a [1-64] char long"
             fi
         else
             _NOPTRAND=1
         fi
    done
    if [ "${_NOPTRAND}" == "1" ]; then
        generateRandom graph 8
        checkBase64
        u_addValInArr "${GENERATED}"
        unsetMe GENERATED _vp_string _R_output _R_confirm
    fi
    if [[ "${_NOPTVAL}" == "1" ]]; then
        echo "${_g_logIndent}-- OK"
        checkBase64
        u_addValInArr "${_R_output}"
        unsetMe _R_output _R_confirm
    fi
}

u_resolveOptSub() {
    # 1 - pattern
    # 2 - length
    local _OPTVAL=0
    local _OPTRAND=0
    while  [[ "${_OPTVAL}" == "0" && "${_OPTRAND}" == "0" ]]
    do
        readUserInput skip
        if [[ ! -z "${_R_output}" ]]; then
            validatePwdMain "${1}" "${2}" "${_R_output}"
            if [[ $? -eq 0 ]]; then
                _OPTVAL=1
            else
                echo "${_g_logIndent}[ERROR] Your input does not match the required complexity, try again"
            fi
        else
            _OPTRAND=1
        fi
    done

    if [[ "${_OPTRAND}" == "1" ]]; then
        generateRandom "${1}" "${2}"
        checkBase64
        u_addValInArr "${GENERATED}"
        unsetMe GENERATED _vp_string _R_output _R_confirm _OPTRAND _OPTVAL
    fi
    if [[ "${_OPTVAL}" == "1" ]]; then
        echo "${_g_logIndent}-- OK"
        checkBase64
        u_addValInArr "${_R_output}"
        unsetMe _R_output _R_confirm _OPTRAND _OPTVAL
    fi
}

u_resolveOpt() {
    listNormArr
    echo " "
    echo "${_g_logIndent}(Optional) You can either provide a value for this Key OR press <ENTER> and a random value will be generated instead"
    echo " "
    local _u_logIndent="$_g_logIndent           "
    echo "${_u_logIndent}The REQUIRED complexity for this value, whether you provide it or it's automatically generated, is:"
    if [ -z "${NLEN}" ]; then
        NLEN=8
        local _VAL_FIXED_LEN=0
        echo "${_u_logIndent}- length: "${NLEN}"-64 characters"
    else
        local _VAL_FIXED_LEN=1
        echo "${_u_logIndent}- fixed length:" "${NLEN}" "characters"
    fi
    if [[ -z "${NALPH}" ]]; then
        if [[ -z "${NNUM}" ]]; then
            echo "${_u_logIndent}- at least 1 lower case"
            echo "${_u_logIndent}- at least 1 upper case"
            echo "${_u_logIndent}- at least 1 digit"
            if [[ "${UKS}" == "0" ]]; then
                echo "${_u_logIndent}- at least 1 printable special character"
            else
                echo "${_u_logIndent}- at least one of the following allowed special characters: "${UKS}""
            fi
            u_resolveOptSub graph "${NLEN}"
        else
            echo "${_u_logIndent}- only digits"
            u_resolveOptSub digit "${NLEN}"
        fi
    else
        if [[ -z "${NNUM}" ]]; then
            echo "${_u_logIndent}- alphabetical chars only"
            echo "${_u_logIndent}- at least 1 lower case"
            echo "${_u_logIndent}- at least 1 upper case"
            u_resolveOptSub alpha "${NLEN}"
        else
            echo "${_u_logIndent}- alpha numeric characters"
            echo "${_u_logIndent}- at least 1 lower case"
            echo "${_u_logIndent}- at least 1 upper case"
            echo "${_u_logIndent}- at least 1 digit"
            u_resolveOptSub alnum "${NLEN}"
        fi
    fi
    unsetMe _VAL_FIXED_LEN NLEN NALPH NNUM
}

u_resolveNone() {
    echo " "
    echo "${_g_logIndent}The only requirement for this Vault Key is:"
    local _u_logIndent="$_g_logIndent           "
    echo "${_u_logIndent} - it must be a [1-64] characters long"
    echo "${_u_logIndent} - it must contain printable characters (no spaces, carriage returns, tabs, line breaks, page breaks, null chars)"
    echo " "
    local _RNVAL=0
    while  [[ "${_RNVAL}" == "0" ]];
    do
         readUserInput
         validatePwdNoneOpt "${_R_output}"
         if [[ $? -eq 0 ]]; then
             _RNVAL=1
         else
             echo "${_g_logIndent}[ERROR] Your input must be a printable character (no spaces, carriage returns, tabs, line breaks, page breaks, null chars), and it must be a [1-64] char long"
         fi
    done
    checkBase64
    u_addValInArr "${_R_output}"
    unsetMe _vp_string _R_output _R_confirm
    echo "${_g_logIndent}-- OK"

}

# main get input
getUserInput() {
    SECRETS_VALS=()
    _VKS=`echo "${#SECRETS_NAME[@]}"`
    for (( uindx=0; uindx<"${_VKS}"; uindx++ ))
    do
        UKN=`echo "${SECRETS_NAME[$uindx]}"`
        UKD=`echo "${SECRETS_DESCRIPTION[$uindx]}"`
        UKE=`echo "${SECRETS_BASE64[$uindx]}"`
        UKC=`echo "${SECRETS_COMPLEXITY[$uindx]}"`
        UKF=`echo "${SECRETS_FIXEDVALUE[$uindx]}"`
        UKV=`echo "${SECRETS_FROMKEY[$uindx]}"`
        UKS=`echo "${SECRETS_SPECIALCHARS[$uindx]}"`
        UCOMS=`echo "${UKC}" | tr ";" "\n" | sed -e 's/^[[:space:]]*//' | sed -e 's/[[:space:]]*$//'`
        for coms in $UCOMS
        do
            case $coms in
                none)     NONE='none'       ;;
                default)  DEF='default'     ;;
                random)   RAND='random'     ;;
                optional) OPT='optional'    ;;
                A)        NORM+=("A")       ;;
                N)        NORM+=("N")       ;;
                L*)       NORM+=("${coms}") ;;
                *)
                          [[ "${UKF}" == "0" && "${UKV}" == "0" ]] && log "[ERROR] getUserInput - Incorrect argument: "${coms}"" && exit 1 ;;
            esac
        done

        if [[ `echo "${#uindx}"` -eq 1 ]]; then
            _g_logIndent='   '
        fi

        # (UKF=0)=key does not have a fixed value
        # (UKV=0)=key does not get its value from another key
        if [[ "${UKF}" == "0" ]]; then
            if [[ "${UKV}" == "0" ]]; then
                if [[ -z "${RAND}" ]]; then
                    echo " "
                    echo -e "-> Vault key:    "${UKN}""
                    echo "${_g_logIndent}Description:  "${UKD}""
                fi

                if [[ ! -z "${DEF}" ]]; then
                    u_resolveDefault # default case
                else
                    if [[ ! -z "${NONE}" || ! -z "${RAND}" || ! -z "${OPT}" ]]; then
                        if [[ ! -z "${NONE}" && ! -z "${OPT}" ]]; then
                             u_resolveNoneOpt # none optional special case
                        else
                            [[ ! -z "${NONE}" ]] && u_resolveNone # none alone case
                            [[ ! -z "${OPT}" ]] && u_resolveOpt # optional case
                        fi
                        [[ ! -z "${RAND}" ]] && u_generateRandom # random case
                    else
                        # length, A and N alone cases
                        u_resolveNorm
                    fi
                fi
                unsetMe NONE DEF RAND OPT NORM
            fi
        else
            # add the fixed value in array
            checkBase64
            SECRETS_VALS[$uindx]="${UKF}"
            unsetMe NONE DEF RAND OPT NORM
        fi
    done

    # loop the names array again
    # at this point, all the generated/user provided values are resolved
    # proceed with 'fromKey' cases
    unsetMe uindx UKN UKE UKV UKS
    for (( uindx=0; uindx<"${_VKS}"; uindx++ ))
    do
        UKN=`echo "${SECRETS_NAME[$uindx]}"`
        UKE=`echo "${SECRETS_BASE64[$uindx]}"`
        UKV=`echo "${SECRETS_FROMKEY[$uindx]}"`
        if [[ "${UKV}" != "0" ]]; then
            # get from SECRETS_NAME array the index of the key (UKV) from which current key (UKN) gets the value
            UKV_INDX=`echo ${SECRETS_NAME[@]/"${UKV}"//} | cut -d/ -f1 | wc -w | tr -d ' '`
            # get value of UKV from SECRETS_VALS array
            UKV_VAL=`echo -n "${SECRETS_VALS[$UKV_INDX]}"`
            if [[ -z $UKV_VAL ]]; then
                UKV_INDX=`echo ${EXISTING_NAME[@]/"${UKV}"//} | cut -d/ -f1 | wc -w | tr -d ' '`
                UKV_VAL=`echo -n "${EXISTING_VALUE[$UKV_INDX]}" | base64 --decode`
            fi
            # assign the obtained value to current key (UKN) in SECRETS_VALS
            checkBase64
            SECRETS_VALS[$uindx]="${UKV_VAL}"
        fi
    done
}

createK8sSecret() {
    _SNAME="${CUST_SEC_NAME}"
    [[ -z "$_SNAME" ]] && _SNAME=""${SUITE}"-secret"

    if [[ -n "$OUTPUTYAML" ]]; then
	log "[INFO] Writing the secrets YAML... $_SNAME"
        _STMPYAML="secrets:"
    else
        log "[INFO] $([[ -n "$UPDATE" ]] && echo "Updating" || echo "Creating" ) the K8s secret... $_SNAME"
        _STMPYAML="apiVersion: v1
kind: Secret
metadata:
  name: $_SNAME
type: Opaque
data:"
    fi

    # Add previously existing secrets
    for (( evks=0; evks<"${#EXISTING_NAME[@]}"; evks++ ))
    do
        local _EKNAME=`echo -n "${EXISTING_NAME[$evks]}"`
        local _EKVAL=`echo -n "${EXISTING_VALUE[$evks]}"`
        _STMPYAML="$_STMPYAML
  ${_EKNAME}: ${_EKVAL}"
    done

    # Add new secrets that are configured by user
    for (( vks=0; vks<"${_VKS}"; vks++ ))
    do
        local _KNAME=`echo -n "${SECRETS_NAME[$vks]}"`
        local _KVAL=`echo -n "${SECRETS_VALS[$vks]}" | base64`
        _STMPYAML="$_STMPYAML
  ${_KNAME}: ${_KVAL}"
    done

    [ -n "${OUTPUTYAML}" ] && echo "$_STMPYAML" > $OUTPUTYAML && exit 0

    _KCTL_TYPE=$([[ -n "$UPDATE" ]] && echo "apply" || echo "create" )
    _EXECKCOM=$(echo "${_STMPYAML}" | ${KCTL} ${_KCTL_TYPE} -f - --namespace ${NAMESPACE} 2>&1 1>/dev/null)
    _VERB=$([[ -n "$UPDATE" ]] && echo "update" || echo "create" )
    if [[ ! -z "${_EXECKCOM}" ]]; then
        if [[ "${_EXECKCOM}" =~ "(AlreadyExists)" ]]; then
            log "[ERROR] Failed to ${_VERB} the K8s secret: "${_SNAME}".  Secret name already exists" nolog
            log "[ERROR] Failed to ${_VERB} K8s secret - secret name already exists" noecho
            exit 1
        elif [[ "${_EXECKCOM}" =~ "Warning" ]]; then
            [[ "${VDEBUG}" == "1" ]] && log `echo $_EXECKCOM`
            log "[INFO] Done"
            log "[INFO] Secret name: "${_SNAME}"" nolog
        else
            log "[ERROR] Failed to ${_VERB} the K8s secret. Reason: `echo $_EXECKCOM`"
            exit 1
        fi
    else
        log "[INFO] Done"
        log "[INFO] Secret name: "${_SNAME}"" nolog
    fi
}

#### Debug purposes
debug() {
    echo " "
    echo "####### DEBUG #######"
    echo " "
    echo "Parsed values:"
    _VKEYS=`echo "${#SECRETS_NAME[@]}"`
    for (( dkey=0; dkey<"${_VKEYS}"; dkey++ ))
    do
        local _DKEY_NAME=$(eval echo \${SECRETS_NAME[$dkey]})
        local _DKEY_DESC=$(eval echo \${SECRETS_DESCRIPTION[$dkey]})
        [[ "${_DKEY_DESC}" == "0" ]] && _DKEY_DESC="not provided"
        local _DKEY_ENCD=$(eval echo \${SECRETS_BASE64[$dkey]})
        local _DKEY_COMP=$(eval echo \${SECRETS_COMPLEXITY[$dkey]})
        local _DKEY_FVAL=$(eval echo \${SECRETS_FROMKEY[$dkey]})
        [[ "${_DKEY_FVAL}" == "0" ]] && _DKEY_FVAL="not assigned"
        local _DKEY_VAL=$(eval echo \${SECRETS_VALS[$dkey]})
        local _DKEY_SCHR=$(eval echo \${SECRETS_SPECIALCHARS[$dkey]})
        [[ "${_DKEY_SCHR}" == "0" ]] && _DKEY_SCHR="no custom special chars defined"
        echo ""$((dkey+1)). Key name:" "${_DKEY_NAME}""
        echo "-- Description:          " "${_DKEY_DESC}"
        echo "-- Base64 Enc:           " "${_DKEY_ENCD}"
        echo "-- Complexity:           " "${_DKEY_COMP}"
        echo "-- Value:                " "${_DKEY_VAL}"
        echo "-- Assigned value from:  " "${_DKEY_FVAL}"
        echo "-- Special Chars:        " "${_DKEY_SCHR}"
        echo " "
    done
}
#### /Debug

### Main
description
getParams $@
getYamls
validateYamlData
[ "${VONLY}" == "1" ] && exit 0
getUserInput
[ "${VDEBUG}" == "1" ] && debug
createK8sSecret
