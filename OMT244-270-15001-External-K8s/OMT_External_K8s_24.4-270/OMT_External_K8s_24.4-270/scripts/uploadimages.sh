#!/bin/bash
# Copyright 2017 - 2024 Open Text.
#
# The only warranties for products and services of Open Text and its affiliates and licensors ("Open Text")
# are as may be set forth in the express warranty statements accompanying such products and services.
# Nothing herein should be construed as constituting an additional warranty. Open Text shall not be liable
# for technical or editorial errors or omissions contained herein. The information contained herein is subject
# to change without notice.
#
# Except as specifically indicated otherwise, this document contains confidential information and a valid
# license is required for possession, use or copying. If this work is provided to the U.S. Government,
# consistent with FAR 12.211 and 12.212, Commercial Computer Software, Computer Software
# Documentation, and Technical Data for Commercial Items are licensed to the U.S. Government under
# vendor's standard commercial license.

#see feature: OCTFT19S1761772
if [[ "bash" != "$(readlink /proc/$$/exe|xargs basename)" ]];then
    echo "Error: only bash support, current shell: $(readlink /proc/$$/exe)"
    exit 1
fi
set +o posix

export PRODUCT_SHORT_NAME="OMT"
CURRENTDIR=$(cd "$(dirname "$0")";pwd)

if [ -f "/etc/profile.d/itom-cdf.sh" ]; then
    source /etc/profile.d/itom-cdf.sh 2>/dev/null
elif [ -f "$HOME/itom-cdf.sh" ];then
    source $HOME/itom-cdf.sh 2>/dev/null
fi
#in case CDF_HOME not exist, try to use K8S_HOME instead
CDF_HOME=${CDF_HOME:-"$K8S_HOME"}
if [ -f "${CDF_HOME}/bin/env.sh" ]; then
    source ${CDF_HOME}/bin/env.sh
    LOG_DIR="${CDF_HOME}/log/uploadimages"
    mkdir -p $LOG_DIR 2>/dev/null
    if [ $? -ne 0 ];then
        echo "Warning: No permission to write log to folder: $LOG_DIR. Switch the log folder to: $CURRENTDIR"
        LOG_DIR=/tmp/log/uploadimages
    fi
else
    LOG_DIR=/tmp/log/uploadimages
fi
mkdir -p $LOG_DIR 2>/dev/null
if [ $? -ne 0 ];then
    echo "Fatal: No permission to write log to folder: $LOG_DIR"
    exit 1
fi

if [[ -x "/usr/bin/rm" ]] ; then
    RM="/usr/bin/rm"
elif [[ -x "/bin/rm" ]] ; then
    RM="/bin/rm"
else
    cmd=$(which rm 2>/dev/null | xargs -n1 | grep '^/')
    if [[ -n "$cmd" ]] && [[ -x "$cmd" ]] ; then
        RM="$cmd"
    else
        RM="rm"
    fi
fi

IS_ERROR_OCCUR="false"
DEFAULT_IMAGE_BASE_DIR="/var/opt/cdf/offline/"
DEFAULT_REGISTRY="localhost:5000"
MAX_RETRY=${MAX_RETRY:-"5"}
export PATH=$PATH:$CURRENTDIR:$CURRENTDIR/../bin  #in some case,jq is under the pwd but can not be found in $PATH
usage() {
    echo "Usage: $0 [-y|--yes] [-u|--user <username>] [-p|--pass <password>] [-r|--registry <registry-url>] [-d|--dir <folder>] [-F|--image-file <image file>] [-t|--retry <retry times>] [-c|--concurrency <concurrency>]"
    echo "       -d|--dir            Folders of images,use it multiple times to specify multiple Folders. (Default value is ${DEFAULT_IMAGE_BASE_DIR})"
    echo "       -t|--retry          Number of retries if the image upload fails. (Default value is ${MAX_RETRY})"
    echo "       -y|--yes            Answer yes for any confirmations. (Default value is \"no\")"
    echo "       -r|--registry       The registry URL of the image repository. (Default value is \"${DEFAULT_REGISTRY}\")"
    echo "       -u|--user           Username of registry host account. (Default value is \"registry-admin\" when registry url is \"localhost:5000\")"
    echo "       -p|--pass           Password of registry host account. Wrap the password with single quotes. For example, 'Password@#$!123'."
    echo "       -b|--bearer-token   Authentication token for the registry whose authentication type is bearer."
    echo "       -P|--Pass-cmd       Command to get and refresh short term password.Wrap the password with single quotes."
    echo "       -f|--key-file       Key file registry host account."
    echo "       -F|--image-file     Image file generated by \"docker save\"(only .tar/.tgz/.tar.gz files are supported),use it multiple times to specify multiple files."
    echo "       -c|--concurrency    Set the working processes that run over the same time period(default is 1,maximum is half of the CPU cores)."
    echo "       -w|--overwrite      Set \"true/false\" to indicate if overwrite the existing images on the registry (default is \"false\")."
    echo "       -o|--organization   Organization name of the registry the images will be uploaded to(must be in lowercase). "
    echo "       --aws-access-key    AWS Secret Access Key. Option --aws-access-key, --aws-access-key-id and --aws-session-token compose a credential for connecting to aws. These 3 options are mutual exclusive with option --aws-profile. "
    echo "       --aws-access-key-id AWS Access key ID. "
    echo "       --aws-session-token AWS session token. "
    echo "       --aws-region        Specify AWS region id where repositories locate. "
    echo "       --aws-profile       Specify the AWS profile name for connecting to AWS. Default value is default. This option is exclusive with option --aws-access-key/--aws-access-key-id/--aws-session-token. "
    echo "       --auth              Use AUTH_STRING for accessing the registry. AUTH_STRING is a base64 encoded 'USERNAME[:PASSWORD]'. "
    echo "       --insecure          Skip SSL certificate validation. "
    echo "       --skip-verify       Skip SSL certificate validation(deprecated). "
    echo "       --cacert            Path to registry CA."
    echo "       --cleanup           Delete the image source folder to save disk space(Only work after all images are uploaded successfully). "
    echo "       --tmp-folder        Temporary folder for placing temporary files. (if this is not specified, use \$TMPDIR if set, else /tmp)"
    echo "       -h|--help           Show help."
    exit 1
}

fatalOnInvalidParm(){
    echo "$1 parameter requires a value. "; exit 1;
}

setOptionVal(){
    local cli=$1
    local val=$2
    local var=$3
    local str=""

    case "$val" in
        -*) fatalOnInvalidParm "$cli" ;;
        * ) if [ -z "$val" ];then fatalOnInvalidParm "$cli" ; fi; str="${var}=\"${val}\"";  eval $str; export $var; ;;
    esac
}
checkParm(){
    local key=$1
    local val=$2
    case "$key" in
        -w|--overwrite)
            local valInLower=$(echo "$val" | tr [:upper:] [:lower:])
            if [ "$valInLower" != "true" ] && [ "$valInLower" != "false" ];then
                echo "Error: Invalid value for $key: $val, allowed value: \"true\",\"false\""; exit 1
            fi
            ;;
        -r|--registry)
            local registryHost="$(echo "$val"|sed -r 's#^https?://##')"
            if [[ ! "$registryHost" =~ ^[a-zA-Z0-9._-]+(:[0-9]+)?$ ]];then
                echo "Error: Invalid value for $key: $val, please enter a valid registry URL, for example: yourregistry.net or yourregistry.net:5000 or $DEFAULT_REGISTRY"; exit 1
            fi
            ;;
        -f|--key-file|--cacert|-F|--image-file|-d|--dir|--tmp-folder)
            if [ ! -r "$val" ];then
                echo "Error: Can't find: $val, please make sure file or directory exists and gets the right permission"; exit 1
            fi
    esac
}

while [[ ! -z $1 ]] ; do
    step=2 ##shift step,default 2
    case "$1" in
        -y|--yes)                   CONFIRM=true;step=1;;
        --insecure|--skip-verify)   SKIP_VERIFY=true;step=1;;      #for debugging: skip cert verification
        --debug-on)                 DEBUG_ON="true";step=1;;       #for debugging: disable both rolling and logging. useful when run with bash -x
        --probe-only)               PROBE_ONLY="true";step=1;;     #only contact registry
        --silent)                   SILENT_MODE="true";step=1;;    #for upgrade use: disable rolling data recorded into the log
        --cleanup)                 CLEAN_UP="true"; step=1;;
        -r|--registry)              setOptionVal "$1" "$2" "REGISTRY_BASE"; USER_PROVIDE_REGISTRY="true";;
        -o|--organization)          setOptionVal "$1" "$2" "ORG_NAME";;
        -u|--user)                  setOptionVal "$1" "$2" "USER_NAME";;
        -P|--pass-cmd)              setOptionVal "$1" "$2" "PASSWORD_CMD";;
        -b|--bearer-token)          setOptionVal "$1" "$2" "BEARER_TOKEN";;
        -t|--retry)                 setOptionVal "$1" "$2" "MAX_RETRY";;
        -c|--concurrency)           setOptionVal "$1" "$2" "CONCURRENCY";;
        -w|--overwrite)             setOptionVal "$1" "$2" "OVERWRITE";;
        -k|--chunk-size)            setOptionVal "$1" "$2" "CHUNK_SIZE";;
        -f|--key-file)              setOptionVal "$1" "$2" "KEY_FILE";;
        --auth)                     setOptionVal "$1" "$2" "AUTH_STRING";;
        --aws-access-key)           setOptionVal "$1" "$2" "AWS_ACCESS_KEY";;
        --aws-access-key-id)        setOptionVal "$1" "$2" "AWS_ACCESS_KEY_ID";;
        --aws-session-token)        setOptionVal "$1" "$2" "AWS_SESSION_TOKEN";;
        --aws-region)               setOptionVal "$1" "$2" "AWS_REGION";;
        --aws-profile)              setOptionVal "$1" "$2" "AWS_PROFILE_NAME";;
        --cacert)                   setOptionVal "$1" "$2" "REGISTRY_CA";;
        --tmp-folder)               setOptionVal "$1" "$2" "TEMP_FOLDER";;
        -p|--pass) #not using setOptionVal to support password contains special chars
        case "$2" in
            -*) echo "-p|--pass parameter requires a value. " ; exit 1 ;;
            *)  if [[ -z $2 ]] ; then echo "-p|--pass parameter requires a value. " ; exit 1 ; fi ; PASSWORD=$2 ; ;;
        esac ;;
        -d|--dir)
        case "$2" in
            -*) echo "-d|--dir parameter requires a value. " ; exit 1 ;;
            *)  if [[ -z $2 ]] ; then echo "-d|--dir parameter requires a value. " ; exit 1 ; fi ; IMAGE_DIR="${IMAGE_DIR} $2" ; ;;
        esac ;;
        -F|--image-file)
        case "$2" in
            -*) echo "-F|--image-file parameter requires a value. " ; exit 1 ;;
            *)  if [[ -z $2 ]] ; then echo "-F|--image-file parameter requires a value. " ; exit 1 ; fi ; IMAGE_FILE="$IMAGE_FILE F--$2" IMAGE_FILE_SHOW="$IMAGE_FILE_SHOW $2"; ;;  #F--is file tag for convenience
        esac ;;
        *|-*|-h|--help|/?|help)
            if [[ "$1" != "-h" ]] && [[ "$1" != "--help" ]] && [[ "$1" != "help" ]] ; then
                echo "invalid parameter $1"
            fi
            usage;;
    esac
    if [[ $step -eq 2 ]];then
        checkParm "$1" "$2"
    fi
    shift $step
done

# US#2028075: uploadimages.sh - make the --aws-access-key-xx options and --aws-profile as mutual exclusive
if [ -n "$AWS_PROFILE_NAME" ] && ( [ -n "$AWS_ACCESS_KEY" ] || [ -n "$AWS_ACCESS_KEY_ID" ] || [ -n "$AWS_SESSION_TOKEN" ] ) ; then
    echo "Error: option --aws-access-key, --aws-access-key-id and --aws-session-token compose a credential for connecting to aws. These 3 options are mutual exclusive with option --aws-profile."; exit 1
fi
CONFIRM=${CONFIRM:-"false"}
REGISTRY_BASE=${REGISTRY_BASE:-"$DEFAULT_REGISTRY"}
CONCURRENCY=${CONCURRENCY:-"1"}
OVERWRITE=${OVERWRITE:-"false"}
USER_PROVIDE_REGISTRY=${USER_PROVIDE_REGISTRY:-"false"}
LOG_FILE="${LOG_DIR}/uploadimages-`date "+%Y%m%d%H%M%S"`.log"
CHUNK_SIZE=${CHUNK_SIZE:-"50000000"} #50M
DEFAULT_AWS_REGION="us-east-1"
AWS_PROFILE_NAME=${AWS_PROFILE_NAME:-${AWS_PROFILE:-"default"}}
TEMP_FOLDER=${TEMP_FOLDER:-${TMPDIR:-"/tmp"}}
if [ ! -r "$TEMP_FOLDER" ];then
    echo "Error: Can't find: $TEMP_FOLDER, please make sure directory exists and gets the right permission"; exit 1
fi

PID_ARRAY=""
AUTH_TYPE=""
AUTH_BASE=""
AUTH_SERVICE=""
SECURITY_OPT=""
NOPROXY_OPT=""
FAIL_FILE=""
LAYER_REC_FILE=""
LAYER_FAIL_FILE=""
ROLLID=   #make it empty, so that silent mode will not kill it
SKIP_VERIFY=${SKIP_VERIFY:-"false"}
SILENT_MODE=${SILENT_MODE:-"false"}
DEBUG_ON=${DEBUG_ON:-"false"}
PROBE_ONLY=${PROBE_ONLY:-"false"}
CLEAN_UP=${CLEAN_UP:-"false"}
TOTAL=0
INDEX=0

log() {
    if [ "$DEBUG_ON" == "false" ];then
        local level=$1
        local msg=$2
        local exitCode=1
        local timestamp=$(date --rfc-3339='ns')
        timestamp=${timestamp:0:10}"T"${timestamp:11}
        if [[ ! -z $3 ]] ; then
            exitCode=$3
        fi
        case $level in
            debug) #debug level is dedicated for write to logfile,not to stdout
                echo -e "${timestamp} DEBUG $msg  " >> $LOG_FILE ;;
            info|warn|error)
                echo -e "$msg" && echo -e "${timestamp} `echo $level|tr [:lower:] [:upper:]` $msg  " >> $LOG_FILE ;;
            begin)
                echo -e "$msg\c"
                echo -e "${timestamp} INFO $msg \c" >> $LOG_FILE ;;
            end)
                echo "$msg"
                echo "$msg" >> $LOG_FILE ;;
            fatal)
                echo -e "$msg \n Please refer to $LOG_FILE for more detail. " >&2
                echo -e "${timestamp} FATAL $msg  " >> $LOG_FILE
                exit ${exitCode}
                ;;
            *)
                echo -e "$msg"
                echo -e "${timestamp} INFO $msg  " >> $LOG_FILE ;;
        esac
    fi
}

rolling(){
    while true;do
        echo -ne '\b|'
        sleep 0.125
        echo -ne '\b/'
        sleep 0.125
        echo -ne '\b-'
        sleep 0.125
        echo -ne '\b\\'
        sleep 0.125
    done
}

startRolling(){
    if [ "$DEBUG_ON" == "false" ] && [ "$SILENT_MODE" == "false" ];then
        rolling &
        ROLLID=$!
    fi
}

stopRolling(){
    if [ "$DEBUG_ON" == "false" ] && [ "$SILENT_MODE" == "false" ];then
        if [[ -n $ROLLID ]];then
            echo -ne '\b'
            kill -s SIGTERM $ROLLID
            wait $ROLLID >/dev/null 2>&1
            ROLLID=""
        else
            ROLLID=
        fi
    fi
}

shellSemInit(){
    local value=$1
    mkfifo mulfifo
    exec 1000<>mulfifo
    $RM -rf mulfifo
    for ((n=1;n<=${value};n++))
    do
            echo >&1000
    done
}
shellSemWait(){
    read -u1000
}
shellSemPost(){
    echo >&1000
}
shellSemDestroy(){
    exec 1000>&-
    exec 1000<&-
}
killTasks(){
    for pid in ${PID_ARRAY[*]} ${ROLLID} ; do
        kill -s SIGTERM $pid 2>/dev/null
    done
}
getMaxConcurrency(){
    local cpuNum=$(cat /proc/cpuinfo 2>/dev/null |grep "processor"|sort -u|wc -l)
    if [[ $cpuNum -le 1 ]] || [[ -z "$cpuNum" ]];then
        echo "1"
    else
        echo $((cpuNum/2))
    fi
}
taskClean(){
    killTasks
    shellSemDestroy
    $RM -f ${FAIL_FILE} 2>/dev/null
    $RM -f ${LAYER_REC_FILE} 2>/dev/null
    $RM -f ${LAYER_FAIL_FILE} 2>/dev/null
    for dir in ${IMAGE_DIR};do
        $RM -f ${dir}/*.tmp* 2>/dev/null
    done
    $RM -rf $DECOMPRESS_DIR 2>/dev/null
}

readLoginInfo() {
    local retry_time=$1
    local user_tmp=""
    local need_input_password="false"
    if [ -n "$AUTH_STRING" ];then
        read -s -r -p "Please input the AUTH_STRING for accessing the registry: " AUTH_STRING
    else
        if [ -z "$USER_NAME" ];then
            read -p "Username:" USER_NAME
            need_input_password="true"
        else
            if [[ $retry_time -gt 0 ]];then #user have provide username and password
                read -p "Username(${USER_NAME})" user_tmp
                if [ -n "$user_tmp" ];then  #use the name in ()
                    USER_NAME=$user_tmp
                fi
                need_input_password="true"
            fi
        fi

        if [ -z "$PASSWORD" ] || [ "$need_input_password" == "true" ];then
            read -s -r -p "Password:" PASSWORD
            echo ""
        fi
    fi
}

getRegistryIp(){
    local host=$1
    local ip

    ip=$(ping "$host" -c 1 | awk 'NR==1 {print $3}' | tr -d '() ')
    if [[ $? -eq 0 ]];then
        echo "$ip"
    else
        echo "host can't resolved"
    fi
}

contactRegistry(){
    local result=125 scheme="" token="" status_code="" http_resp="" host port ip outputHost

    if [[ "$REGISTRY_BASE" =~ "://" ]];then  #if user provide registry with http/https scheme, remove it
        REGISTRY_BASE=${REGISTRY_BASE#*://}
    fi
    HOST_PORT="$REGISTRY_BASE"
    host=${HOST_PORT%:*}
    port=${HOST_PORT##*:}
    ip=$(getRegistryIp $host)
    if [ "$host" == "$ip" ];then
        outputHost=$HOST_PORT
    else
        if [ -n "$port" ] && [[ "$port" =~ ^[0-9]+$ ]];then
            outputHost="$host[$ip]:$port"
        else
            outputHost="$host[$ip]"
        fi
    fi

    #step 1. intentify the protocal scheme
    for scheme in "https://" "http://" ; do
        http_resp=$(curl --connect-timeout 20 -s -w %{http_code} ${NOPROXY_OPT} ${SECURITY_OPT} ${scheme}${HOST_PORT}/v2/ 2>>$LOG_FILE)
        if [[ $? -eq 60 ]];then
            if [ -n "$REGISTRY_CA" ] || [ "$CONFIRM" == "true" ];then #if ca provided, and not certified, quit
                log "fatal" "CA certificate verify failed on registry server: $HOST_PORT"
            else
                log "warn" "CA certificate verify failed on registry server: $HOST_PORT"
                read -p "Continue to upload images without TLS verify?(Y/N)" answer
                answer=$(echo "$answer" | tr [:upper:] [:lower:])
                case "$answer" in
                    y|yes ) SECURITY_OPT="$SECURITY_OPT -k ";;
                    n|no )  log "fatal" "User select to quit." ;;
                    * )     log "fatal" "Unknown input, quit";;
                esac
            fi
            http_resp=$(curl --connect-timeout 20 -s -w %{http_code} ${NOPROXY_OPT} ${SECURITY_OPT} ${scheme}${HOST_PORT}/v2/ 2>>$LOG_FILE)
        fi
        status_code=${http_resp:0-3}
        case "$status_code" in
            200)
                if [ $(echo -e "$http_resp" | grep "blocked" | wc -l) -ne 0 ];then #special handling for docker hub
                    continue
                else
                    log "info" "Contacting Registry: $outputHost ... [OK]"
                    AUTH_TYPE=""; AUTH_BASE=""; AUTH_SERVICE=""; result=0; break
                fi
                ;;
            401)
                log "debug" "intentify the protocal scheme failed, resp:\n$http_resp"
                http_resp=$(curl -s -i ${NOPROXY_OPT} ${SECURITY_OPT} ${scheme}${HOST_PORT}/v2/ 2>>$LOG_FILE)
                if [ $? -ne 0 ];then
                    log "debug" "retry intentify the protocal scheme failed, resp:\n$http_resp"
                fi
                auth_info=$(echo "$http_resp" | grep "realm")
                AUTH_BASE=$(echo "$auth_info" | cut -d = -f2 | cut -d , -f1 | tr -d ["\" \r"])
                AUTH_TYPE=$(echo "$auth_info" | cut -d = -f1 | cut -d ' ' -f2)
                AUTH_SERVICE=$(echo "$auth_info" | awk -F, '{print $2}' | awk -F= '{print $2}' | tr -d ["\" \r"])
                AUTH_SERVICE=${AUTH_SERVICE// /%20} #escape space
                result=1
                break
                ;;
            *) ;;
        esac
    done
    REGISTRY_BASE=${scheme}${HOST_PORT}

    #step 2. check if the credential is correct
    if [[ $result -eq 1 ]];then
        for((i=0;i<$MAX_RETRY;i++));do
            log "begin" "Contacting Registry: $outputHost ..."
            startRolling
            token=$(getAuthToken "")
            http_resp=$(curl -s -w %{http_code} ${NOPROXY_OPT} ${SECURITY_OPT} -H "Authorization: $AUTH_TYPE $token" "$REGISTRY_BASE/v2/" 2>>$LOG_FILE)
            status_code=${http_resp:0-3}
            stopRolling
            if [ "$status_code" == "200" ];then
                log "end" "[OK]"
                result=0
                break
            else
                log "debug" "check the credential failed, resp:\n$http_resp"
                log "end" "[Failed]"
                sleep 2
                log "info" "Retry..."
                readLoginInfo $i
            fi
        done
    fi

    if [[ $result -ne 0 ]];then
        if [[ "$REGISTRY_BASE" =~ "localhost" ]];then
            log "fatal" "Failed to login to $outputHost, please make sure your user name, password are correct."
        else
            log "fatal" "Failed to login to $outputHost, please make sure your user name, password and network/proxy configuration are correct."
        fi
    fi
}

findLatestDir(){
    local base_dir=$1
    local dirs=$(ls -t $base_dir 2>>$LOG_FILE | xargs)  #sorted by timestamp
    local latest_dir=""
    for item in ${dirs}; do
        #folder name convention: images_yyyymmddhhmmss, 14 char and a null-terminate char
        local prefix=${item%%_*}
        local sufix=${item#*_}
        if [[ -d $item ]] && [ "$prefix" != "images" ] || [ $(echo $sufix | wc -c 2>/dev/null) -ne 15 ];then
            continue
        fi
        if [[ "$item" > "$latest_dir" ]];then
            latest_dir=$item
        fi
    done
    echo $latest_dir
}
confirm(){
    local answer
    log "info" "Upload image script will run with below settings:"
    log "info" "User(specified by -u): ${USER_NAME}"
    log "info" "Docker Registry URL(specified by -r): ${REGISTRY_BASE}"
    if [[ ! -z "${ORG_NAME}" ]] ; then
        log "info" "Organization Name(specified by -o): ${ORG_NAME}"
    fi
    if [ "$PROBE_ONLY" == "false" ];then
        log "info" "Image folders(specified by -d): ${IMAGE_DIR}"
        log "info" "Image files(specified by -F): ${IMAGE_FILE_SHOW}"
    fi
    if [[ "$USER_PROVIDE_REGISTRY" == "false" ]] && [[ "$SUITE_REGISTRY" != "localhost:5000" ]];then
        log "warn" "\nWarning: $PRODUCT_SHORT_NAME is configured with registry: $SUITE_REGISTRY, now you are uploading images to: $REGISTRY_BASE"
    fi
    if [ "$CLEAN_UP" == "true" ];then
        log "warn" "\nWarning: Image folders will be removed after all images are uploaded successfully."
    fi
    if [ "$CONFIRM" == "false" ]; then
        for((i=0;i<$MAX_RETRY;i++)); do
            read -p "Are you sure to continue? (Y/N): " answer
            answer=$(echo "$answer" | tr [:upper:] [:lower:])
            case "$answer" in
                y|yes ) break;;
                n|no )  log "fatal" "Uploading process QUIT." ;;
                * )     log "warn" "Unknown input, Please input Y or N";;
            esac
            if [[ $i -eq $MAX_RETRY ]];then
                log "fatal" "error input for $MAX_RETRY times Uploading process QUIT."
            fi
        done
    fi
    ORG_NAME=${ORG_NAME:-$REGISTRY_ORGNAME}
    if [ -z "$ORG_NAME" ];then
        read -p "Organization name is empty,please provide it:" ORG_NAME
    fi
    if [[ $ORG_NAME =~ [A-Z] ]];then
        log "fatal" "error registry organization name: $ORG_NAME, it must be in lowercase"
    fi
}
checkTools(){
    local tools="$1"
    for tool in $tools ; do
        local res1=$( which $tool > /dev/null 2>& 1; echo $? )
        local res2=$( whereis $tool > /dev/null 2>& 1; echo $? )
        if [ $res1 -ne 0 ] && [ $res2 -ne 0 ]; then
            log "fatal" "$tool not found in PATH($PATH)"
        fi
    done
}
init(){
    local curlVersion tools="jq curl"
    mkdir -p $LOG_DIR
    checkTools "$tools"
    #both or none of these 2 options should be provided at the same time
    if ([ -n "$AWS_ACCESS_KEY" ] && [ -z "$AWS_ACCESS_KEY_ID" ]) || ([ -n "$AWS_ACCESS_KEY_ID" ] && [ -z "$AWS_ACCESS_KEY" ]);then
        log "fatal" "Options --aws-access-key and aws-access-key-id come in pairs!"
    fi

    if [ -z "$IMAGE_DIR" ] && [ -z "$IMAGE_FILE" ];then
        IMAGE_DIR=${DEFAULT_IMAGE_BASE_DIR}
    fi

    if [[ -z "$USER_NAME" ]] && [[ "${REGISTRY_BASE}" == "localhost:5000" ]] ; then
        USER_NAME="registry-admin"
    fi

    confirm

    if [ "$SKIP_VERIFY" == "true" ] && [ -n "$REGITRY_CA" ];then
        log "fatal" "--insecure,--skip-verify can not use with --cacert"
    fi
    if [ "$SKIP_VERIFY" == "true" ];then
        SECURITY_OPT=" -k "
    fi
    if [ -n "$REGISTRY_CA" ];then
        SECURITY_OPT=" --cacert $REGISTRY_CA "
    fi
    if [ -z "$SECURITY_OPT" ] && [[ "$REGISTRY_BASE" =~ "localhost" ]];then
        local ca_file="${CDF_HOME}/ssl/ca.crt"
        if [ -z "${CDF_HOME}" ] || [ ! -f "$ca_file" ];then
            log "fatal" "Can't find ca.crt under <CDF_HOME>/ssl/"
        fi
        SECURITY_OPT=" --cacert ${ca_file} "
    fi

    local max_cucurrency=$(getMaxConcurrency)
    if [[ $CONCURRENCY -le 0 ]];then
        CONCURRENCY=1
    elif [[ $CONCURRENCY -gt $max_cucurrency ]];then
        CONCURRENCY=$max_cucurrency
    fi
    log "info" "The concurrency number is constrained to 1-$max_cucurrency, and current concurrency number is: $CONCURRENCY"

    #chunck upload failed for unknown reason, so disable chunck upload for gcr and ecr
    if [[ "$REGISTRY_BASE" =~ "gcr.io" ]] || [[ "$REGISTRY_BASE" =~ "dkr.ecr" ]];then
        CHUNK_SIZE=100000000000
    fi

    if [[ "$REGISTRY_BASE" =~ "dkr.ecr" ]];then
        local aws_version aws_major_version tmp_region
        if [ -z "$USER_NAME" ];then
            USER_NAME='AWS'
        fi
        if [ -z "$PASSWORD" ]; then
            aws_version=$(aws --version)
            if [ $? -eq 0 ];then
                aws_major_version=$(echo $aws_version | awk '{print $1}' | awk -F/ '{print $2}' | awk -F. '{print $1}')
                if [ -z "$AWS_REGION" ];then
                    read -p "Please input aws region (default: $DEFAULT_AWS_REGION):" tmp_region
                    AWS_REGION=${tmp_region:-"$DEFAULT_AWS_REGION"}
                fi
                local awsCmdResult=
                if [ "$aws_major_version" == "1" ];then
                    awsCmdResult=$(aws --profile $AWS_PROFILE_NAME ecr get-login --region $AWS_REGION 2>&1)
                    if [ $? -ne 0 ]; then
                        log "fatal" "$awsCmdResult. Failed to get AWS login password with config profile ($AWS_PROFILE_NAME) and region ($AWS_REGION). Please provide a correct profile name, region name or provide the registry username and password."
                    fi
                    PASSWORD=$(echo $awsCmdResult | awk '{print $6}')
                elif [ "$aws_major_version" == "2" ];then
                    awsCmdResult=$(aws --profile $AWS_PROFILE_NAME ecr get-login-password --region $AWS_REGION 2>&1)
                    if [ $? -ne 0 ]; then
                        log "fatal" "$awsCmdResult. Failed to get AWS login password with config profile ($AWS_PROFILE_NAME) and region ($AWS_REGION). Please provide a correct profile name, region name or provide the registry username and password."
                    fi
                    PASSWORD="$awsCmdResult"
                else
                    log "warn" "AWS CLI version:$aws_version not supported yet!"
                fi
            fi
        fi
    fi

    if [[ "$REGISTRY_BASE" =~ "localhost:5000" ]];then
        NOPROXY_OPT="--noproxy localhost"
    fi
}
getAuthToken(){
    local repo=$1
    local rc=
    local token token_resp query_string
    if [ -z "$AUTH_TYPE" ];then
        token=""
    elif [ -n "$BEARER_TOKEN" ];then
        token=$BEARER_TOKEN
    else
        if [ -z "$AUTH_STRING" ];then
            if [ -z "$USER_NAME" ];then
                AUTH_STRING=""
            else
                if [ -n "$PASSWORD" ];then
                    AUTH_STRING=$(echo -n "$USER_NAME:$PASSWORD" | base64 -w0)
                elif [ -n "$PASSWORD_CMD" ];then
                    AUTH_STRING=$(echo -n "$USER_NAME:$(eval ${PASSWORD_CMD})" | base64 -w0)
                elif [ -n "$KEY_FILE" ];then
                    AUTH_STRING=$(echo -n "$USER_NAME:$(cat $KEY_FILE)" | base64 -w0)
                else
                    AUTH_STRING=""
                fi
            fi
        fi

        if [ "$AUTH_TYPE" == "Basic" ]; then
            token=$AUTH_STRING
        else
            if [ -z "$AUTH_SERVICE" ];then
                if [ -z "$repo" ];then
                    query_string=""
                else
                    query_string="?scope=repository:${repo}:push,pull"
                fi
            else
                if [ -z "$repo" ];then
                    query_string="?service=${AUTH_SERVICE}"
                else
                    query_string="?service=${AUTH_SERVICE}&scope=repository:${repo}:push,pull"
                fi
            fi

            log "debug" "curl -s ${NOPROXY_OPT} ${SECURITY_OPT} ${AUTH_BASE}${query_string}"
            if [ -z "$AUTH_STRING" ];then
                token_resp=$(curl -s ${NOPROXY_OPT} ${SECURITY_OPT} ${AUTH_BASE}${query_string} 2>>$LOG_FILE)
            else
                token_resp=$(curl -s ${NOPROXY_OPT} ${SECURITY_OPT} -H "Authorization: Basic $AUTH_STRING" ${AUTH_BASE}${query_string} 2>>$LOG_FILE)
            fi
            rc=$?
            if [[ "$rc" -eq 60 ]];then
                log "fatal" "CA certificate verify failed on authentication server: $AUTH_BASE"
            fi
            if [[ "$rc" -ne 0 ]];then
                log "debug" "getAuthToken failed, resp:\n$token_resp"
            fi
            token=$(echo "$token_resp" | jq -r '.token?')
            if [ "$token" == "null" ];then
                token=$(echo $token_resp | jq -r '.access_token?')
            fi
        fi
    fi
    if [[ -z "$token" ]];then
        log "debug" "Failed to get token, current token is empty !!!"
    fi
    echo  $token
}

getImageTagsFromRegistry(){
    local repo=$1
    local tag=$2
    local token=$3

    local resp http_code header_size body_size link_header body index url_path url result
    url_path="/v2/${repo}/tags/list"
    while : ; do
        if [[ "$url_path" =~ "${REGISTRY_BASE}" ]];then  #some registry retrurn the <Link> with full url(e.g. aws), but some return only the path
            url=$url_path
        else
            url=${REGISTRY_BASE}${url_path}
        fi
        log "debug" "get image tag[repo=$repo,tag=$tag],cmd=curl -s -i ${NOPROXY_OPT} ${SECURITY_OPT} ${url}"
        if [ -z "$token" ]; then
            resp=$(curl -w '\n%{size_header},%{size_download},%{http_code}' -s -i ${NOPROXY_OPT} ${SECURITY_OPT} ${url})
        else
            resp=$(curl -w '\n%{size_header},%{size_download},%{http_code}' -s -i ${NOPROXY_OPT} ${SECURITY_OPT} -H "Authorization: $AUTH_TYPE $token" ${url})
        fi
        header_size=$(echo -e "$resp" | awk -F, 'END{print $1}')
        body_size=$(echo -e "$resp" | awk -F, 'END{print $2}')
        http_code=$(echo -e "$resp" | awk -F, 'END{print $3}')
        if [ "$http_code" != "200" ];then
            log "debug" "getImageTagsFromRegistry failed, repo: $repo, tag: $tag, resp:\n$resp"
            result="$http_code:false"; break
        else
            body=${resp:$header_size:$body_size}
            log "debug" "getImageTagsFromRegistry, repo: $repo, tag: $tag, check if the content type format is JSON ..."
            index=$(echo "$body" | jq -r ".tags|index(\"$tag\")" 2>>$LOG_FILE)
            if [ $? -ne 0 ];then
                log "debug" "getImageTagsFromRegistry: the response is not as expected: \n$resp"
                result="200:false"; break
            fi
            if [ "$index" != "null" ];then #tag found
                result="200:true"; break
            fi
            link_header=$(echo -e "$resp" | grep "Link:")   #handle pagination
            if [ -z "$link_header" ];then
                result="200:false"; break
            else
                url_path=$(echo "$link_header" | awk '{print $2}' | tr -d "<>;")
            fi
        fi
    done
    log "debug" "get image tag[repo=$repo,tag=$tag],result:$result"
    echo "$result"
}

hasBlob(){
    local repo=$1
    local digest=$2
    local token=$3

    local url res httpCode
    url="${REGISTRY_BASE}/v2/$repo/blobs/$digest"
    log "debug" "check blob existence[repo=$repo,digest=$digest] cmd: curl -s -I -X HEAD ${SECURITY_OPT} $url"
    #it is not easy to handle double quote in bash, we have to resort to condition statement
    #no remove -I, otherwise, the curl command may get blocked
    if [ -z "$token" ] || [ "$token" == "null" ]; then
        res=$(curl -w '%{http_code}' -s -I -X HEAD ${NOPROXY_OPT} ${SECURITY_OPT} $url 2>>"$LOG_FILE")
    else
        res=$(curl -w '%{http_code}' -s -I -X HEAD ${NOPROXY_OPT} ${SECURITY_OPT} -H "Authorization: $AUTH_TYPE $token" $url 2>>"$LOG_FILE")
    fi
    echo "$res" >> $LOG_FILE
    httpCode=${res:0-3}
    if [ "$httpCode" != "200" ]; then
        log "debug" "blob not exist[repo=$repo,digest=$digest]"
        echo "false"
    elif echo "$res"|grep -i "Content-Type"|grep -i "text/html" -q;then
        log "debug" "hasBlob: the content-type is not as expected[repo=$repo,digest=$digest]"
        echo "false"
    else
        log "debug" "blob exist[repo=$repo,digest=$digest]"
        echo "true"
    fi
}
getBlobUploadLocation(){
    local repo=$1
    local token=$2
    local url res location

    url="${REGISTRY_BASE}/v2/$repo/blobs/uploads/"
    log "debug" "Get upload location[repo=$repo] cmd: curl -s -I -X POST ${SECURITY_OPT}  -H \"Content-Length: 0\" $url"
    if [ -z "$token" ]; then
        res=$(curl -s -i -X POST ${NOPROXY_OPT} ${SECURITY_OPT} -H "Content-Length: 0" $url 2>>$LOG_FILE)
    else
        res=$(curl -s -i -X POST ${NOPROXY_OPT} ${SECURITY_OPT} -H "Content-Length: 0" -H "Authorization: $AUTH_TYPE $token" $url 2>>$LOG_FILE)
    fi
    echo -e "$res" >>$LOG_FILE
    location=$(echo -e "$res" | grep -i "location" | cut -d ' ' -f 2)
    if [ -n "$location" ] ; then
        log "debug" "Get upload location[repo=$repo]:OK"
        if [[ ! "$location" =~ "http" ]];then  #for Azure registry, it return url start with /v2/
            location="$REGISTRY_BASE$location"
        fi
        echo "${location}"
    else
        log "debug" "Get upload location[repo=$repo]:failed"
        echo ""
    fi
}

uploadBlob(){
    local repo=$1
    local digest=$2
    local size=$3
    local blob=$4
    local token=$5

    log "debug" "upload layer[layer=$blob,size=$size,digest=$digest]..."
    local res httpCode location full_location chunk_size exist chunk_array
    local result="failed" support_chunk="true"

    for((i=0;i<$MAX_RETRY;i++)); do
        if [ "$OVERWRITE" == "false" ];then
            exist=$(hasBlob "$repo" "$digest" "$token")
            if [ "$exist" == "true" ];then
                log "debug" "blob:$digest already exist"
                result="success"
                break
            fi
        fi
        location=$(getBlobUploadLocation "$repo" "$token" | tr -d "\r" | tr -d "\n")
        if [ -z "$location" ]; then #not get location, failed
            continue
        fi

        local path=${blob%/*}
        if [[ $size -lt $CHUNK_SIZE ]] || [ "$support_chunk" == "false" ];then
            chunk_array=(${blob##*/})
            log "debug" "no split: digest=$digest,chunk_array=${chunk_array[@]}"
        else
            local digest_x=${digest#*:}
            local is_splited=$(ls $path 2>>$LOG_FILE | grep "${digest_x}.tmp" | wc -l)
            log "debug" "digest=$digest,is_splited=$is_splited"
            if [[ $is_splited -eq 0 ]] && [[ $i -eq 0 ]]; then  #only when not split before will we split the file,as split big file is time consumed task
                split -b $CHUNK_SIZE $blob "${path}/${digest_x}.tmp" 2>>$LOG_FILE
                if [ $? -ne 0 ];then
                    support_chunk="false"
                    log "debug" "No permission to support chunk upload."
                    chunk_array=(${blob##*/})
                else
                    chunk_array=$(ls $path 2>>$LOG_FILE | grep "${digest_x}.tmp" | xargs)
                    chunk_array=(${chunk_array[@]})
                fi
            else
                chunk_array=$(ls $path 2>>$LOG_FILE | grep "${digest_x}.tmp" | xargs)
                chunk_array=(${chunk_array[@]})
            fi
            log "debug" "split: digest=$digest,chunk_array=${chunk_array[@]}"
        fi
        local chunk_array_size=${#chunk_array[@]}
        local chunk chunk_size=0 range_start=0 range_end=
        log "debug" "digest=$digest,chunk_array_size=$chunk_array_size"
        for((j=0;j<$chunk_array_size;j++));do
            chunk="${path}/${chunk_array[$j]}"
            chunk_size=$(stat -c "%s" $chunk 2>>$LOG_FILE)
            range_end=$(((range_start+chunk_size-1)))
            #replace -I option with -i, as -I is conflict with -T,see CR: OCTCR19S1908232
            log "debug" "Upload chunk[digest=$digest] cmd:curl -s -i -X PATCH ${SECURITY_OPT} -T $chunk -H \"chunck:Content-Length: $chunk_size\" -H \"Content-Type: application/octet-stream\" <auth> $location "
            if [ -z "$token" ]; then
                res=$(curl -s -i -X PATCH ${NOPROXY_OPT} ${SECURITY_OPT}  -T $chunk -H "chunck:Content-Length: $chunk_size" -H "Content-Type: application/octet-stream" $location 2>>$LOG_FILE)
            else
                res=$(curl -s -i -X PATCH ${NOPROXY_OPT} ${SECURITY_OPT}  -T $chunk -H "chunck:Content-Length: $chunk_size" -H "Content-Type: application/octet-stream" -H "Authorization: $AUTH_TYPE $token" $location 2>>$LOG_FILE)
            fi
            echo -e "$res" >>$LOG_FILE
            location=$(echo "$res" | grep -i "location" | cut -d ' ' -f 2 | tr -d "\r" | tr -d "\n")
            if [ -z "$location" ]; then #not get location, failed
                break
            fi
            if [[ ! "$location" =~ "http" ]];then  #for Azure registry, it return url start with /v2/
                location="$REGISTRY_BASE$location"
            fi
            range_start=$(((range_start+chunk_size)))
        done
        if [[ "$location" =~ "?" ]];then
            full_location="${location}&digest=${digest}"
        else
            full_location="${location}?digest=${digest}"
        fi

        log "debug" "Complete chunk[digest=$digest] upload cmd:curl -s ${NOPROXY_OPT} ${SECURITY_OPT}  -i -X PUT -H \"Content-Length: 0\"  -H \"Content-Type: application/octet-stream\" ${full_location} 2>>$LOG_FILE"
        if [ -z "$token" ]; then
            res=$(curl -w '%{http_code}' -s -i -X PUT ${NOPROXY_OPT} ${SECURITY_OPT} -H "Content-Length: 0"  -H "Content-Type: application/octet-stream" ${full_location})
        else
            res=$(curl -w '%{http_code}' -s -i -X PUT ${NOPROXY_OPT} ${SECURITY_OPT} -H "Content-Length: 0"  -H "Content-Type: application/octet-stream" -H "Authorization: $AUTH_TYPE $token" ${full_location})
        fi
        echo -e "$res" >> $LOG_FILE
        httpCode=${res:0-3}
        if [ "$httpCode" == "201" ] ; then
            result="success"
            break
        fi
        log "debug" "Upload layer[layer=$blob,digest=$digest]:failed, retry in 2 seconds"
	    sleep 2
    done

    if [ "$result" == "success" ] ; then
        log "debug" "Upload layer[layer=$blob,digest=$digest]:OK"
    else
        log "debug" "Upload layer[layer=$blob,digest=$digest]:failed"
        echo $digest >> $LAYER_FAIL_FILE
    fi
    shellSemPost
}

crossRepositoryBlobMount(){
    local repo=$1
    local digest=$2
    local refRepo=$3
    local token=$4
    local url res httpCode result="failed"

    url="${REGISTRY_BASE}/v2/$repo/blobs/uploads/?mount=${digest}&from=${refRepo}"
    for((i=0;i<$MAX_RETRY;i++)); do
        log "debug" "cross-mount[repo=$repo,digest=$digest,from=$refRepo] cmd: curl -s -i -X POST ${SECURITY_OPT} -H \"Content-Length: 0\" ${url}"
        if [ -z "$token" ]; then
            res=$(curl -w '%{http_code}' -s -i -X POST ${NOPROXY_OPT} ${SECURITY_OPT}  -H "Content-Length: 0" ${url})
        else
            res=$(curl -w '%{http_code}' -s -i -X POST ${NOPROXY_OPT} ${SECURITY_OPT}  -H "Content-Length: 0" -H "Authorization: $AUTH_TYPE $token" ${url})
        fi
        echo -e "$res" >> $LOG_FILE
        httpCode=${res:0-3}
        if [ "$httpCode" == "201" ] ; then
            log "debug" "cross-mount[repo=$repo,digest=$digest,from=$refRepo]: OK"
            result="success"
            break
        fi
        log "debug" "cross-mount[repo=$repo,digest=$digest,from=$refRepo]: failed,retry in 2 seconds"
	    sleep 2
    done

    if [ "$result" == "failed" ];then
        echo $digest >> $LAYER_FAIL_FILE
    fi
    echo "$result"
}

putManifest(){
    local repo=$1
    local reference=$2
    local content=$3
    local token=$4
    local url res result httpCode

    url="${REGISTRY_BASE}/v2/$repo/manifests/$reference"
    for((i=0;i<$MAX_RETRY;i++)); do
        log "debug" "Upload manifest[repo=$repo,reference=$reference] cmd: curl -s -X PUT ${SECURITY_OPT} --data $content -H \"Content-Type:application/vnd.docker.distribution.manifest.v2+json\" \"${url}\""
        if [ -z "$token" ]; then
            res=$(curl -w %{http_code} -s -X PUT ${NOPROXY_OPT} ${SECURITY_OPT} --data "$content" -H "Content-Type: application/vnd.docker.distribution.manifest.v2+json" ${url})
        else
            res=$(curl -w %{http_code} -s -X PUT ${NOPROXY_OPT} ${SECURITY_OPT} --data "$content" -H "Content-Type: application/vnd.docker.distribution.manifest.v2+json" -H "Authorization: $AUTH_TYPE $token" ${url})
        fi
        echo -e "$res" >> $LOG_FILE
        httpCode=${res:0-3}
        if [[ "$httpCode" == 20* ]]; then
            log "debug" "Upload manifest[repo=$repo,reference=$reference]: OK"
            result="success"
            break
        fi

        log "debug" "Upload manifest[repo=$repo,reference=$reference]:failed,retry in 2 seconds"
	    sleep 2
    done

    if [ -n "$result" ] ; then
        echo "success"
    else
        echo "failed"
    fi
}

logBegin(){
    local index=$1
    local repo=$2
    local tag=$3

    $RM -rf $LAYER_FAIL_FILE
    PID_ARRAY=""  #clear PID_ARRAY

    log "begin" "Upload image [${index}/${TOTAL}] ${HOST_PORT}/${repo}:$tag ... "
    startRolling
}
logEnd(){
    local result=$1
    stopRolling
    log "end" "[$result]"
    if [ "$result" = "FAILED" ]; then
        echo "failed" >> $FAIL_FILE
    fi
}
checkAwsReop(){
    log "info" "Checking repository ..."
    local items images token res http_code index=1 tag="test" #tag is no use here, just a placeholder
    items=$(cat $GLOBAL_MANIFEST | jq -r '.[]|.RepoTags[]' | xargs)
    for item in ${items}; do
        image=${item##*/}  #remove host and org_name
        image=${image%:*}  #remove tag
        if [ -z "$ORG_NAME" ];then
            repo="$image"
        else
            repo="$ORG_NAME/$image"
        fi
        log "begin" "[${index}/${TOTAL}] check if repository: $repo exists ... "
        for((i=0;i<$MAX_RETRY;i++));do
            token=$(getAuthToken "$repo")
            res=$(getImageTagsFromRegistry "$repo" "$tag" "$token")
            http_code=${res:0:3}
            case "$http_code" in
                403) logEnd "FORBIDDEN"; return 2;;
                401)
                    logEnd "UNAUTHORIZED";
                    #refer OCTCR19S1781638
                    if [ -n "$USER_NAME" ];then
                        readLoginInfo "$i";
                    fi
                    log "begin" "[${index}/${TOTAL}] check if repository: $repo exists ... "
                    ;;
                404)
                    logEnd "NO"
                    images="${images},${image}"
                    break
                    ;;
                200) logEnd "YES"; break;;
                *) logEnd "UNKNOWN ERROR"; return 125;;
            esac
        done
        if [ $i -ge $MAX_RETRY ];then
            logEnd "FAILED"
            return 125
        fi
        index=$((index+1))
    done
    images=${images#*,} #remove first ','
    if [ -n "$images" ];then
        log "info" ""
        log "info" "Creating repository ... "
        if [ -z "$ORG_NAME" ];then
            log "fatal" "Failed to create repository on AWS ECR: org_name must not be empty!"
        fi
        local credentialFile profileExist="false" userProvideCredential="false"
        credentialFile="$HOME/.aws/credentials"
        if [ -f "$credentialFile" ];then
            if [ $(grep -F "[$AWS_PROFILE_NAME]" $credentialFile | wc -l) -eq 1 ];then
                profileExist="true"
            fi
        fi
        if [ -n "$AWS_ACCESS_KEY" ] || [ -n "$AWS_ACCESS_KEY_ID" ];then
            userProvideCredential="true"
        fi
        if [ "$userProvideCredential" == "true" ] || ([ "$userProvideCredential" == "false" ] && [ "$profileExist" == "false" ]);then
            while [ -z "$AWS_ACCESS_KEY_ID" ]; do read -p "Please input aws access key id: " AWS_ACCESS_KEY_ID ; done
            while [ -z "$AWS_ACCESS_KEY" ]; do read -p "Please input aws access key id: " AWS_ACCESS_KEY ; done
            if [ -z "$AWS_REGION" ];then
                read -p "Please input aws region (default: $DEFAULT_AWS_REGION):" tmp_region
                AWS_REGION=${tmp_region:-"$DEFAULT_AWS_REGION"}
            fi
            if [ -z "$AWS_SESSION_TOKEN" ];then
                aws-ecr-create-repository -i $AWS_ACCESS_KEY_ID -k $AWS_ACCESS_KEY -r $AWS_REGION -o $ORG_NAME -m $images
            else
                aws-ecr-create-repository -i $AWS_ACCESS_KEY_ID -k $AWS_ACCESS_KEY -I $AWS_SESSION_TOKEN -r $AWS_REGION -o $ORG_NAME -m $images
            fi
        else
            if [ -z "$AWS_REGION" ];then
                aws-ecr-create-repository --profile $AWS_PROFILE_NAME -o $ORG_NAME -m $images
            else
                aws-ecr-create-repository --profile $AWS_PROFILE_NAME -r $AWS_REGION -o $ORG_NAME -m $images
            fi

        fi
    fi
    return $?
}

generateManifest(){
    local config=$1
    local layers=$2
    local json="$(
        echo '{}' | jq -r '. + {
            schemaVersion: 2,
            mediaType: "application/vnd.docker.distribution.manifest.v2+json",
            config: {
                mediaType: "application/vnd.docker.container.image.v1+json",
                size: '${config%-*}',
                digest: "'"${config#*-}"'"
            },
            layers: '"$(echo '[]' | jq -r ".$(for layer in ${layers}; do size=${layer%-*};digest=${layer#*-};echo " + [{mediaType: \"application/vnd.docker.image.rootfs.diff.tar.gzip\", size: $size, digest: \"$digest\"}] "; done)")"'
        }'
    )"
    echo "$json"
}

pushOneV2Image(){
    local repoTags=$1
    local config_file=$2
    local layers=$3

    local res retCode=0 pid repo token image name tag configRec layerRecs manifest tagFound http_code

    for repoTag in ${repoTags}; do
        image=${repoTag##*/}
        name=${image%:*}
        tag=${image##*:}

        if [ -z "$ORG_NAME" ];then
            repo="$name"
        else
            repo="$ORG_NAME/$name"
        fi
        INDEX=$((INDEX+1))

        logBegin "$INDEX" "$repo" "$tag"
        token=$(getAuthToken "$repo")
        for((i=0;i<$MAX_RETRY;i++));do
            res=$(getImageTagsFromRegistry "$repo" "$tag" "$token")
            http_code=${res:0:3}
            case "$http_code" in
                403) logEnd "FORBIDDEN"; return 2;;
                401)
                    logEnd "UNAUTHORIZED";
                    #refer OCTCR19S1781638
                    if [ -n "$USER_NAME" ];then
                        readLoginInfo "$i";
                    fi
                    logBegin "$INDEX" "$repo" "$tag"
                    ;;
                404)
                    tagFound="false"; break;;
                200) tagFound=${res#*:}; break;;
                *) logEnd "UNKNOWN ERROR"; return 125;;
            esac
        done

        if [ $i -ge $MAX_RETRY ];then
            logEnd "FAILED"
            return 125
        fi

        if [ "$OVERWRITE" != "true" ] && [ "$tagFound" == "true" ];then
            logEnd "ALREADY UPLOADED"
            continue
        fi

        blobs="$config_file $layers"   #treat config file as blob
        local layer_index=0 fail_cnt=0 tmpLayerRec=""
        shellSemInit ${CONCURRENCY}
        for blob in $blobs; do
            local blob_file_name=${blob%%.*}
            local blob_path=$(readlink -f "${IMAGE_BASE_DIR}/${blob}")
            local check_sum=$(sha256sum $blob_path | cut -d ' ' -f 1)
            local size=$(stat -c "%s" $blob_path 2>>$LOG_FILE)
            if [ "$CHECK_LAYER" == "true" ] && [ "$blob_file_name" != "$check_sum" ];then
                log "debug" "Error: check sum invalid: sha256sum for $blob is:$check_sum"
                retCode=1
                break
            fi
            check_sum="sha256:${check_sum}"
            tmpLayerRec="$tmpLayerRec $check_sum,$repo\n"

            if [ $layer_index -eq 0 ];then
                configRec="$size-$check_sum"
            else
                layerRecs="$layerRecs $size-$check_sum"
            fi

            layer_index=$(( layer_index + 1 ))

            local uploaded_blobs cross_mount_repo
            if [[ "$REGISTRY_BASE" =~ "localhost:5000" ]];then  #we found portus and docker hub not support crossmount,here we only optimize local registry
                cross_mount_repo=$(cat $LAYER_REC_FILE 2>/dev/null | grep -m1 "$check_sum" | awk -F, '{print $2}')
            else
                cross_mount_repo=""
            fi
            if [ -n "$cross_mount_repo" ];then  #blob exist in registry
                res=$(crossRepositoryBlobMount "$repo" "$check_sum" "$cross_mount_repo" "$token")
                if [ "$res" != "success" ] ; then
                    break
                fi
            else
                fail_cnt=$(cat ${LAYER_FAIL_FILE}   2>/dev/null | wc -l)
                if [[ $fail_cnt -ne 0 ]]; then
                    break
                fi
                shellSemWait
                if [ "$DEBUG_ON" == "true" ];then
                    uploadBlob "$repo" "$check_sum" "$size" "$blob_path" "$token"
                else
                    uploadBlob "$repo" "$check_sum" "$size" "$blob_path" "$token" &
                fi
                pid=$!
                PID_ARRAY="${PID_ARRAY} $pid"
            fi
        done

        if [ "$DEBUG_ON" == "false" ];then
            if [[ -n "$PID_ARRAY" ]];then
                for pid in $PID_ARRAY;do
                    wait $pid >/dev/null 2>&1
                done
            fi
        fi
        #wait
        fail_cnt=$(cat ${LAYER_FAIL_FILE}   2>/dev/null | wc -l)
        if [[ $fail_cnt -ne 0 ]] || [[ $retCode -ne 0 ]]; then
            logEnd  "FAILED"
            retCode=1
            continue   #as images may have multi-tags, we should not return,but continue here
        fi

        #if all layers are uploaded successfully, add  them to LAYER_REC_FILE
        echo -e "$tmpLayerRec" >> $LAYER_REC_FILE

        #if multiple repotags share the same layers, we only need to upload the layers for the first repotag.
        #for the rest, cross mount them(for local registry), and put manifest
        if [ -z "$maniest" ];then
            manifest=$(generateManifest "$configRec" "$layerRecs")
        fi
        res=$(putManifest "$repo" "$tag" "$manifest" "$token")
        if [ "$res" == "success" ] ; then
            logEnd  "OK"
        else
            logEnd  "FAILED"
            retCode=1
        fi

    done
    return $retCode
}

handleImageFolders(){
    local folders_files ls_result
    for dir in ${IMAGE_DIR};do
        if [[ ! -r ${dir} ]] ; then #error folder, either not exist, or not have permission
            folders_files="$folders_files E--$dir"
            continue
        fi
        if [[ "$dir" =~ "$DEFAULT_IMAGE_BASE_DIR" ]];then
            local latest_dir=$(findLatestDir "$dir")
            dir=${dir}/${latest_dir}
        fi
        if [ ! -r "$dir/manifest.json" ]; then
            local tar_files=($(ls $dir | grep -E ".tar|.tgz|.tar.gz"|xargs))
            if [ -z "$tar_files" ];then
                continue
            fi
            for f in ${tar_files[@]};do
                folders_files="$folders_files F--$dir/$f"
            done
        else
            folders_files="$folders_files D--$dir"
        fi
    done
    echo "$folders_files"
}

cleanupImageDir(){
    local imageDir=$1
    # remove the dir directly if it is default image base dir because it's dedicated for download images
    if [[ "$imageDir" =~ $DEFAULT_IMAGE_BASE_DIR ]]; then
        rm -rf $imageDir
        return
    fi
    # customized image dir
    local manifestFile=$imageDir/manifest.json
    ## remove all referenced files in manifest
    local manifestJson=$(cat $manifestFile)
    ### remove config files
    echo "$manifestJson" | jq --arg path "${imageDir}/" -r '.[].Config | $path + . ' | xargs rm -f
    ### remove layer files
    for layer in $(echo "$manifestJson" | jq --arg path "${imageDir}/" -r '.[].Layers[] | $path + . ' | sort | uniq )
    do
        # layer: /opt/cdf/d54871933dd3efcb9a7183be0e44cb690068922fe38801f1927309b583340f0c/layer.tar
        if [[ "$layer" =~  [0-9a-z]{64}/layer\.tar ]]; then
            rm -rf $(dirname $layer)
        else
        # layer: /opt/cdf/d54871933dd3efcb9a7183be0e44cb690068922fe38801f1927309b583340f0c.tar.gz
            rm -f $layer
        fi
    done
    ### remove manifest file
    rm -f $manifestFile

    ## try to find and remove the left files & dirs
    # file:
    #   ef8e3adb68245b003d6547425337ce9ffc9a05d9a02634620fedc40baf9ffe64.json
    #   fcb6f6d2c9986d9cd6a2ea3cc2936e5fc613e09f1af9042329011e43057f3265.tar.gz
    #   downloadimages-20240311222159.log
    #   repositories
    # dir: should have 'layer.tar' file in it.
    #   75a8b9dd8d9f487f065f89f51d2132a6845cfa7fda1dacc1c0ea7589ac7a91a9
    for name in `ls $imageDir`
    do
        if [[ -f "$imageDir/$name" && "$name" =~ [0-9a-z]{64}(\.tar\.gz|\.json) ]] || \
           [[ -d "$imageDir/$name" && -f "$imageDir/$name/layer.tar" && "$name" =~ [0-9a-z]{64} ]] || \
           [[ -f "$imageDir/$name" && "$name" = "repositories" ]] || \
           [[ "$name" =~ downloadimages-[0-9]+\.log ]]; then
            rm -rf $imageDir/$name
        fi
    done
}

pushImages(){
    local folders_files=""
    folders_files=$(handleImageFolders)
    folders_files="$folders_files $IMAGE_FILE"

    for item in $folders_files; do
        INDEX=0  #for each new file or folder, reset the global index
        local show_name
        local tag=${item%%--*}
        if [ "$tag" == "E" ];then
            IS_ERROR_OCCUR=true
            IMAGE_BASE_DIR=${item#*--}
            log "error" "Can't find folder: $IMAGE_BASE_DIR, please make sure folder exists and gets the right permission!"
            continue
        elif [ "$tag" == "D" ];then
            IMAGE_BASE_DIR=${item#*--}
            show_name=$IMAGE_BASE_DIR
            CHECK_LAYER="true"
        else
            local ext
            local file=${item#*--}
            if [[ "$file" =~ ".tar.gz" ]];then
                ext="tar.gz"
            else
                ext=${file##*.}
            fi
            if [ "$ext" != "tar" ] && [ "$ext" != "tar.gz" ] && [ "$ext" != "tgz" ]; then
                log "error" "Unsupported image file extention, allowable values are: .tar, .tar.gz, .tgz"
                IS_ERROR_OCCUR=true
                continue
            fi

            if [ ! -r "$file" ];then
                log "error" "Can't find $file, Please make sure $file exists, and gets the right permission!"
                IS_ERROR_OCCUR=true
                continue
            fi
            show_name=$file
            #DECOMPRESS_DIR=${file%.*}
            DECOMPRESS_DIR=$(mktemp -d -p $TEMP_FOLDER)
            IMAGE_BASE_DIR=$DECOMPRESS_DIR
            mkdir -p $IMAGE_BASE_DIR 2>/dev/null
            if [ $? -ne 0 ];then
                log "fatal" "failed to create temporary directory for image file: $file"
            fi
            log "info" "\ndecompressing $file ..."
            if [ "$ext" == "tar" ];then
                tar -xf $file -C ${IMAGE_BASE_DIR} 2>>$LOG_FILE
            else
                tar -zxf $file -C ${IMAGE_BASE_DIR} 2>>$LOG_FILE
            fi
            if [ $? -ne 0 ];then
                log "error" "tar -xf $file -C ${IMAGE_BASE_DIR} failed!"
                IS_ERROR_OCCUR=true
                continue
            fi
            CHECK_LAYER="false"
        fi
        FAIL_FILE="${LOG_DIR}/fail-`date "+%Y%m%d%H%M%S"`"
        LAYER_REC_FILE="${LOG_DIR}/layer-`date "+%Y%m%d%H%M%S"`"
        LAYER_FAIL_FILE="${LOG_DIR}/layer-fail-`date "+%Y%m%d%H%M%S"`"
        GLOBAL_MANIFEST="$IMAGE_BASE_DIR/manifest.json"

        if [ ! -f "$GLOBAL_MANIFEST" ]; then
            log "error" "Warning: manifest.json not found under/in: $show_name, skip uploading suite images"
            IS_ERROR_OCCUR=true
        fi

        local manifest_content=$(cat $GLOBAL_MANIFEST 2>/dev/null)

        TOTAL=$(echo $manifest_content | jq -r '.[]|.RepoTags|length' | awk '{sum+=$0} END{print sum}')
        if [[ "$TOTAL" -eq 0 ]] || [ "$TOTAL" == "null" ];then
            log "error" "no image found in manifest.json under/in: $show_name, please check image downloading is successful or not"
            IS_ERROR_OCCUR=true
        fi
        if [[ "$REGISTRY_BASE" =~ "dkr.ecr" ]];then #for ecr, try to create repo
            checkAwsReop
            if [ "$?" -ne 0 ];then
                IS_ERROR_OCCUR=true
                log "error" "check/create ECR repository failed."
                continue
            fi
        fi

        if [ "$IS_ERROR_OCCUR" == "true" ];then
            if [ -n "$DECOMPRESS_DIR" ];then
                $RM -rf $DECOMPRESS_DIR
            fi
            continue
        fi

        local image_array_size=$(echo $manifest_content | jq -r '.|length')
        local begin_time=$(date +%s)
        log "info" "\n** Uploading suite images under/in: $show_name "
        for ((index=0;index<$image_array_size;index++));do
            local configFile=$(echo $manifest_content | jq -r '.['$index'].Config')
            local repoTags=$(echo $manifest_content | jq -r '.['$index'].RepoTags[]' | xargs)
            local layers=$(echo $manifest_content | jq -r '.['$index'].Layers[]' | xargs)

            if [ -z "$configFile" ] || [ -z "$repoTags" ] || [ -z "$layers" ] ; then
                log "error" "Image manifest info corrupted!"
                IS_ERROR_OCCUR=true
                break
            fi

            pushOneV2Image "$repoTags" "$configFile" "$layers"
            if [ $? -ne 0 ];then
                IS_ERROR_OCCUR=true
            fi
        done
        local end_time=$(date +%s)
        local cost_time=$(($end_time - $begin_time))
        if [ "$IS_ERROR_OCCUR" == "false" ];then
            log "info" "Upload completed.Time cost: ${cost_time} seconds."
        else
            log "info" "Upload ends. Time cost: ${cost_time} seconds."
        fi

        if [ "$tag" == "D" ];then
            if [[ "$IS_ERROR_OCCUR" != "true" ]];then
                if [ "$CLEAN_UP" == "true" ];then
                    cleanupImageDir "$IMAGE_BASE_DIR"
                else
                    if [ "$CONFIRM" == "true" ];then
                        log "info" "Images have been uploaded successfully for folder: $IMAGE_BASE_DIR. You can remove this folder to save disk space."
                    else
                        log "info" "Images have been upload successfully for folder: $IMAGE_BASE_DIR."
                        read -p "Do you want to delete the contents under image source folder to save disk space? (Y/N): " answer
                        answer=$(echo "$answer" | tr [:upper:] [:lower:])
                        case "$answer" in
                            y|yes ) cleanupImageDir "$IMAGE_BASE_DIR"; log "info" "The contents under folder: $IMAGE_BASE_DIR are removed.";;
                            n|no )  log "info" "The contents under folder: $IMAGE_BASE_DIR will not be removed";;
                            * )     log "warn" "Unknown input, the contents under folder: $IMAGE_BASE_DIR will not be removed";;
                        esac
                    fi
                fi
            fi
        fi

        if [ "$tag" == "F" ];then
            rm -rf $IMAGE_BASE_DIR
        fi
    done
    echo ""
    if [ "$IS_ERROR_OCCUR" == "false" ];then
        log "info" "Upload-process successfully completed."; exit 0
    else
        log "fatal" "Upload-process completed with errors.\nCheck Username/Password,your account access ability, http/https proxy setting, repo create requirement and backend storage usage of your registry before uploading."
        exit 1
    fi
}

########for Containerd only#####
confirm4Containerd(){
    local answer

    log "info" "Upload image script will run with below settings:"

    if [[ ! -z "${ORG_NAME}" ]] ; then
        log "info" "Organization Name(specified by -o): ${ORG_NAME}"
    fi
    log "info" "Image folders(specified by -d): ${IMAGE_DIR}"
    log "info" "Image files(specified by -F): ${IMAGE_FILE_SHOW}"

    if [ "$CONFIRM" == "false" ]; then
        for((i=0;i<$MAX_RETRY;i++)); do
            read -p "Are you sure to continue? (Y/N): " answer
            answer=$(echo "$answer" | tr [:upper:] [:lower:])
            case "$answer" in
                y|yes ) break;;
                n|no )  log "fatal" "Uploading process QUIT." ;;
                * )     log "warn" "Unknown input, Please input Y or N";;
            esac
            if [[ $i -eq $MAX_RETRY ]];then
                log "fatal" "error input for $MAX_RETRY times Uploading process QUIT."
            fi
        done
    fi
    ORG_NAME=${ORG_NAME:-$REGISTRY_ORGNAME}
    if [ -z "$ORG_NAME" ];then
        read -p "Organization name is empty,please provide it:" ORG_NAME
    fi
}
init4Containerd(){
    mkdir -p $LOG_DIR
    tools="jq curl ctr"
    checkTools "$tools"
    if [ -z "$IMAGE_DIR" ] && [ -z "$IMAGE_FILE" ];then
        IMAGE_DIR=${DEFAULT_IMAGE_BASE_DIR}
    fi
    confirm4Containerd
}
contactContainerd(){
    local result
    result=$(systemctl is-active containerd 2>/dev/null)
    if [ $? -ne 0 ];then
        log "fatal" "'systemctl is-active containerd' failed, can't determine if containerd is active or not!"
    else
        if [ "$result" == "active" ];then
            log "info" "Contact containerd ... [OK]"
        else
            log "fatal" "Contact containerd ... [Failed]"
        fi
    fi
}
#loadImage(): load image under a folder
#The folder is either generated by downloadimages.sh, or by decompressing a image tar(tar.gz, tgz).
#Inside the folder, there should be a manifest.json, we need recreate a new manifest.json from the old one, so that
#we can do the "retag" before loading the image
loadImage(){
    local folder=$1
    local existCode

    if [ ! -f "$folder/manifest.json" ]; then
        log "error" "Invalid image file/folder: manifest.json not found!"
        return 1
    fi
    mv "$folder/manifest.json" "$folder/manifest.json.bak"
    jq -r '.' "$folder/manifest.json.bak" > $folder/manifest.json  #as jq can't make inplace updating, we use sed instead
    if [ $? -ne 0 ];then
        log "error" "Parse manifest.json failed!"
        mv "$folder/manifest.json.bak" "$folder/manifest.json"
        return 2
    fi
    local repoTags=$(cat $folder/manifest.json | jq -r '.[]|.RepoTags[]' | xargs)
    for repoTag in ${repoTags};do
        local nameTag=${repoTag##*/}
        local newRepoTag
        if [ -z "$ORG_NAME" ];then
            newRepoTag="localhost:5000/$nameTag"
        else
            newRepoTag="localhost:5000/$ORG_NAME/$nameTag"
        fi
        sed -i -e "s@$repoTag@$newRepoTag@g"  $folder/manifest.json
        if [ -f "$folder/index.json" ];then
            sed -i -e "s@$repoTag@$newRepoTag@g"  $folder/index.json
        fi
    done
    log "begin" "Loading images ... "; startRolling
    output=$(tar -C $IMAGE_BASE_DIR -c . | ctr -n k8s.io images import -)
    existCode=$?
    stopRolling
    if [ $existCode -eq 0 ];then
        log "end" "[OK]"
    else
        log "end" "[Failed]"
    fi

    echo "$output"
    $RM -f $folder/manifest.json && mv "$folder/manifest.json.bak" "$folder/manifest.json"
    return $existCode
}
loadImage2Containerd(){
    local folders_files IS_ERROR_OCCUR="false" pid option existCode
    folders_files=$(handleImageFolders)
    folders_files="$folders_files $IMAGE_FILE"
   for item in $folders_files; do
        local show_name
        local tag=${item%%--*}
        if [ "$tag" == "D" ];then
            IMAGE_BASE_DIR=${item#*--}
            log "info" "\n** Loading images under: $IMAGE_BASE_DIR "
        else
            local file=${item#*--}
            local type=$(file --mime-type -b $file | awk -F/ '{print $2}')
            DECOMPRESS_DIR=$(mktemp -d -p $TEMP_FOLDER)
            IMAGE_BASE_DIR=$DECOMPRESS_DIR
            log "info" "\n** Loading images in: $file "
            if [[ "$type" == "x-gzip" ]];then
                option="-zxf"
            elif [[ "$type" == "x-tar" ]]; then
                option="-xf"
            else
                log "error" "Unsupported image file extention, allowable values are: .tar, .tar.gz, .tgz"
                IS_ERROR_OCCUR=true
                continue
            fi
            log "begin" "decompressing: $file ... "; startRolling
            tar -C $IMAGE_BASE_DIR $option $file
            existCode=$?
            stopRolling
            if [ "$existCode" -eq 0 ];then
                log "end" "[OK]"
            else
                $RM -rf $IMAGE_BASE_DIR
                log "end" "[Failed]"
                IS_ERROR_OCCUR=true
                continue
            fi
        fi

        loadImage "$IMAGE_BASE_DIR"
        existCode=$?
        [ $existCode -ne 0 ] && IS_ERROR_OCCUR=true

        if [ "$tag" == "D" ];then
            if [[ "$IS_ERROR_OCCUR" != "true" ]];then
                if [ "$CLEAN_UP" == "true" ];then
                    cleanupImageDir "$IMAGE_BASE_DIR"
                else
                    if [ "$CONFIRM" == "true" ];then
                        log "info" "Images have been uploaded successfully for folder: $IMAGE_BASE_DIR. You can removed this folder to save disk space."
                    else
                        log "info" "Images have been upload successfully for folder: $IMAGE_BASE_DIR."
                        read -p "Do you want to delete the contensts under image source folder to save disk space? (Y/N): " answer
                        answer=$(echo "$answer" | tr [:upper:] [:lower:])
                        case "$answer" in
                            y|yes ) cleanupImageDir "$IMAGE_BASE_DIR"; log "info" "The contents under folder: $IMAGE_BASE_DIR are removed.";;
                            n|no )  log "info" "The contents under folder: $IMAGE_BASE_DIR will not be removed";;
                            * )     log "warn" "Unknown input, the contents under folder: $IMAGE_BASE_DIR will not be removed";;
                        esac
                    fi
                fi
            fi
        fi

        if [ "$tag" == "F" ];then
            rm -rf $IMAGE_BASE_DIR
        fi
        if [ "$existCode" -ne 0 ];then
            IS_ERROR_OCCUR=true
            continue
        fi
    done
    echo ""
    if [ "$IS_ERROR_OCCUR" == "false" ];then
        log "info" "Upload-process successfully completed."; exit 0
    else
        log "fatal" "Upload-process completed with errors."
        exit 1
    fi
}

##############MAIN##############
trap 'taskClean; exit' 1 2 3 8 9 14 15 EXIT
if [ "$(echo $REGISTRY_BASE | tr [A-Z] [a-z])" == "containerd" ];then
    init4Containerd
    #contactContainerd
    loadImage2Containerd
else
    init
    contactRegistry
    if [ "$PROBE_ONLY" == "false" ];then
        pushImages
    fi
fi
