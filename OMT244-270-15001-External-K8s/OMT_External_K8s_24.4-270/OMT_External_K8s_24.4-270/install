#!/bin/bash

# Copyright 2017 - 2024 Open Text.
#
# The only warranties for products and services of Open Text and its affiliates and licensors ("Open Text")
# are as may be set forth in the express warranty statements accompanying such products and services.
# Nothing herein should be construed as constituting an additional warranty. Open Text shall not be liable
# for technical or editorial errors or omissions contained herein. The information contained herein is subject
# to change without notice.
#
# Except as specifically indicated otherwise, this document contains confidential information and a valid
# license is required for possession, use or copying. If this work is provided to the U.S. Government,
# consistent with FAR 12.211 and 12.212, Commercial Computer Software, Computer Software
# Documentation, and Technical Data for Commercial Items are licensed to the U.S. Government under
# vendor's standard commercial license.
#

#set -o errexit
#set -x

export LC_ALL=C

if [[ "bash" != "$(readlink /proc/$$/exe|xargs basename)" ]];then
    echo "Error: only bash support, current shell: $(readlink /proc/$$/exe)"
    exit 1
fi
set +o posix

# clean env
unsetEnvs(){
    local all_envs="
    METADATA
    CLI_CONFIGFILE
    CLI_BACKUP_STORAGE_API_CA
    CLI_BACKUP_STORAGE_API_URL
    CLI_BACKUP_STORAGE_BUCKET
    CLI_BACKUP_STORAGE_CREDENTIAL_FILE
    CLI_BACKUP_STORAGE_SECRET
    CLI_BACKUP_RESOURCE_GROUP
    CLI_BACKUP_STORAGE_ACCOUNT
    CLI_CAPABILITIES
    CLI_CDF_ADMIN_TASKS
    CLI_CDF_HOME
    CLI_CDF_NAMESPACE
    CLI_CLUSTER_WIDE_INGRESS
    CLI_LOGGING_VOL_SIZE
    CLI_APPHUB_HELM_VALUES
    CLI_APP_HTTP_PROXY
    CLI_APP_HTTPS_PROXY
    CLI_APP_NO_PROXY
    CLI_AUTO_CONFIGURE_FIREWALL
    CLI_AWS_CERTIFICATE_ARN
    CLI_AWS_EIP
    CLI_AWS_REGION
    CLI_CLOUD_PROVIDER
    CLI_K8S_PROVIDER
    CLI_CRT_HTTP_PROXY
    CLI_CRT_HTTPS_PROXY
    CLI_CRT_NO_PROXY
    CLI_FAIL_SWAP_ON
    CLI_FEATURE_GATES
    CLI_ENABLE_FIPS
    CLI_ENABLE_K8S_AUDIT_LOG
    CLI_FIPS_ENTROPY_THRESHOLD
    CLI_FLANNEL_BACKEND_TYPE
    CLI_FLANNEL_PORT
    CLI_FLANNEL_DIRECTROUTING
    CLI_FLANNEL_IFACE
    CLI_HA_VIRTUAL_IP
    CLI_LOAD_BALANCER_HOST
    CLI_K8S_HOME
    CLI_RUNTIME_CDFDATA_HOME
    CLI_KUBELET_HOME
    CLI_KEEPALIVED_NOPREEMPT
    CLI_KEEPALIVED_VIRTUAL_ROUTER_ID
    CLI_KEEPALIVED_ADVERT_INT
    CLI_MASTER_API_SSL_PORT
    CLI_REGISTRY_ORGNAME
    CLI_REGISTRY_CA
    CLI_CLUSTER_NAME
    CLI_DOCKER_REPOSITORY
    CLI_SYSTEM_USER_ID
    CLI_SYSTEM_GROUP_ID
    CLI_K8S_USER_ID
    CLI_K8S_GROUP_ID
    CLI_ETCD_USER_ID
    CLI_ETCD_GROUP_ID
    CLI_DEVICE_TYPE
    CLI_ETCD_ENDPOINT
    K8S_MASTER_IP
    NODE_HOST
    NODE_TYPE
    NODE_SELECTOR
    CLI_POD_CIDR
    CLI_POD_CIDR_SUBNETLEN
    CLI_SERVICE_CIDR
    CLI_IPV6
    CLI_IPV6_POD_CIDR
    CLI_IPV6_POD_CIDR_SUBNETLEN
    CLI_IPV6_SERVICE_CIDR
    CLI_DNS_SVC_IP
    CLI_SKIP_CHECK_ON_NODE_LOST
    CLI_SKIP_FAILED_WORKER_NODE
    CLI_TMP_FOLDER
    CLI_DEPLOYMENT_LOG_LOCATION
    CLI_SESSION_NAME
    CLI_KUBE_DNS_HOSTS
    CLI_CERTIFICATE_PERIOD
    JUST_FOR_CDF_SILENT_RERUN
    CLI_ALL_CERTS_DIR
    SILENT_CONFIG_FILE
    END_STATE
    SILENT_IMAGE_FOLDER
    SILENT_TIMEOUT_MINUTES
    SILENT_SUPERUSER
    DEPLOYMENT_NAME
    NFS_SERVER
    NFS_FOLDER
    NFS_PROV_SERVER
    NFS_PROV_FOLDER
    REGISTRY_USERNAME
    REGISTRY_PASSWORD
    REGISTRY_PASSWORD_FILE
    EXTERNAL_ACCESS_HOST
    CLI_EXTERNAL_ACCESS_PORT
    LOADBALANCER_INFO
    SUITEDB_USER
    SUITEDB_URL
    SUITEDB_CERT
    SUITEDB_TLS_SKIP_HOSTNAME_VERIFICATION
    CLI_DEFAULT_STORAGE_CLASS
    CLI_STORAGE_CLASS_MAPPINGS
    CLI_TLS_CIPHERS
    CLI_TLS_MIN_VERSION
    CLI_PERSISTENCE_THREHOLD
    SUPER_USERPWD
    SUITEDB_PASSWORD
    CLI_SET_FQDN_IN_INGRESS
    CLI_SET_APPHUB_CLUSTER_ADMIN
    CLI_KUBELET_PROTECT_KERNEL_DEFAULTS
    CLI_SKIP_PRECHECK_WARNING
    SILENT_RECONFIG
    SILENT_UPDATE
    CLI_NOINFRA
    CLI_PRINT_HELP
    "
    for env_var in $all_envs;do
        if [[ -n "${env_var}" ]];then
            # unset METADATA; unset CLI_CDF_HOME
            unset ${env_var}
            if [[ "${env_var}" =~ ^CLI_ ]];then
                # unset CDF_HOME
                unset ${env_var#CLI_}
            fi
        fi
    done

    # clean all ETCDCTL env
    for etcdctl_var in $(env|grep 'ETCDCTL_'|awk -F= '{print $1}');do unset ${etcdctl_var};done;
}

unsetEnvs

CDF_DEV_INSECURITY_DEBUG_LOG=false

##constant
export PRODUCT_SHORT_NAME="OMT"
export PRODUCT_INFRA_NAME="Infrastructure"
export PRODUCT_APP_NAME="Apphub"
export readonly DNS_DOMAIN="cluster.local"
export readonly MASTER_NODELABEL_KEY="node-role.kubernetes.io/control-plane"
export readonly MASTER_NODELABEL_VAL=""
export readonly NODESELECT="$MASTER_NODELABEL_KEY: \"$MASTER_NODELABEL_VAL\""
export readonly NODESELECT_ARG="$MASTER_NODELABEL_KEY=\"$MASTER_NODELABEL_VAL\""
export readonly TAINT_MASTER_KEY="node-role.kubernetes.io/control-plane"
export readonly ETCD_PREFIX="/coreos.com/network"
export readonly RESTART_POLICY="unless-stopped"
export readonly FLANNEL_SUBNET_DIR="/run/flannel"
export readonly DEFAULT_CDF_NAMESPACE="core"
export readonly BASEINFRA_VAULT_NAMESPACE="core"
export readonly BASEINFRA_VAULT_APPROLE="baseinfra"
export readonly BASEINFRA_VAULT_CERTIFICATE_ROLE="coretech"
export readonly MULTI_SUITE="0"
export readonly RETRY_TIMES=60
export readonly SLEEP_TIME=5
export readonly AZURE_CONFIG_FILE="/etc/cdf/keepalived/keepalived-azure.conf"
export readonly MF_SUPPORT_MSG="Please contact OpenText support."
export readonly K8S_ADMIN_USERNAME="kubernetes-admin"
export readonly INTERNAL_KUBE_REGISTRY_USERNAME="registry-admin"
export readonly INTERNAL_KUBE_REGISTRY_READER_USERNAME="registry-read"
                INTERNAL_KUBE_REGISTRY_READER_PWD="$(date +%s | md5sum | cut -c 1-10)"
                CLOUDSERVER_SECRET_KEY=$(date +%s | sha1sum | cut -c 1-32)
                CLOUDSERVER_CUSTOMER_KEY=$(echo $CLOUDSERVER_SECRET_KEY | sha1sum | cut -c 1-32)
export readonly INTERNAL_KUBE_REGISTRY_HTPASSWD_SECRET="cdf-internal-registry"
export readonly EXTERNAL_SUITEDB_SECRET="external-suitedb-secret"
export readonly INTERNAL_KUBE_REGISTRY_ENDPOINT="localhost:5000"
export readonly CDF_HELM_RELEASE_NAME="apphub"
export readonly NFS_PROVISIONER_RELEASE_NAME="nfs-provisioner"
export readonly NFS_PROVISIONER_STORAGECLASS="cdf-nfs"
export readonly DEFAULT_EXTERNAL_ACCESS_PORT=5443
export readonly SVC_DEFAULT_PORT_RANGE_LOW=30000
export readonly SVC_DEFAULT_PORT_RANGE_HIGH=32767
export DEPLOYMENT_TYPE="PRIMARY"
export CDF_NAMESPACE="$DEFAULT_CDF_NAMESPACE"
export VELERO_NAMESPACE="$CDF_NAMESPACE"

export COMPONENTNAME=$(basename $0|cut -d'.' -f1)
export LOG_FILE_TIMESTAMP="$(date "+%Y%m%d%H%M%S")"
export LOGFILENAME="$COMPONENTNAME.${LOG_FILE_TIMESTAMP}.log"
export CURRENTDIR=$(cd "$(dirname "$0")";pwd)
export PATH=$PATH:${CURRENTDIR}/bin
export CERTIFICATE_MINIMUM_PERIOD=1
export CERTIFICATE_MAXIMUM_PERIOD=3660
export CERTIFICATE_RECOMMEND_PERIOD=365
export INGRESS_2WAY_SSL_PORT=5444
export JQ="${CURRENTDIR}/bin/jq"

readonly MSG_NFS_ISSUE_TIPS="Possible error causes are as follows: 1.The NFS server network unreachable; 2.The NFS server is not running; 3.The NFS server does not export this directory."
readonly MSG_CHECK_CONFIG_JSON="Checking silent installation configuration file ..."
CDF_APISERVER_HOST="suite-installer-svc"
CDF_APISERVER_PORT=8443
BASE_URL="https://${CDF_APISERVER_HOST}:${CDF_APISERVER_PORT}"

export readonly FIRST_MASTER_MAIN_IMAGES_BUNDLE=$($JQ -r '.usage.first_master_main|.[]' ${CURRENTDIR}/image_pack_config.json 2>/dev/null | xargs)
export readonly MOVE_PACK_IMAGES_BUNDLE=$($JQ -r '.usage.move_pack|.[]' ${CURRENTDIR}/image_pack_config.json 2>/dev/null | xargs)
readonly INFRA_MAIN_IMAGES_BUNDLE=$($JQ -r '.usage.k8s_master_main|.[]' ${CURRENTDIR}/image_pack_config.json | xargs)

export readonly DEFAULT_TLS_MIN_VERSION="TLSv1.2"
export readonly DEFAULT_TLS_CIPHERS="TLS_AES_128_GCM_SHA256,\
TLS_AES_256_GCM_SHA384,\
TLS_CHACHA20_POLY1305_SHA256,\
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\
TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\
TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\
TLS_AES_128_CCM_8_SHA256,\
TLS_AES_128_CCM_SHA256"

CURRENT_PID=$$
spin(){
    sleep 1
    local lost=
    local spinner="\\|/-"
    trap 'lost=true' SIGTERM
    while :
    do
        if [[ -n "$lost" ]] ; then
            break
        fi
        for i in $(seq 0 3)
        do
            ps -p $CURRENT_PID > /dev/null 2>&1
            if [[ $? -ne 0 ]] ; then
                lost=true
                break
            fi
            printf "%c\010" "${spinner:$i:1}" 2>/dev/null
            # echo -n "${spinner:$i:1}"
            # echo -en "\010"
            ps -p $CURRENT_PID > /dev/null 2>&1
            if [[ $? -ne 0 ]] ; then
                lost=true
                break
            fi
            sleep 0.125
        done
    done
}

startLoading(){
    stopLoading
    spin &
    CDF_LOADING_LAST_PID=$!
}

stopLoading(){
    if [[ -n "$CDF_LOADING_LAST_PID" ]];then
        ps -p $CDF_LOADING_LAST_PID > /dev/null 2>&1
        if [[ $? == 0 ]]; then
            kill -s SIGTERM $CDF_LOADING_LAST_PID >/dev/null 2>&1
            wait $CDF_LOADING_LAST_PID >/dev/null 2>&1
        fi
        CDF_LOADING_LAST_PID=
    fi
}

loadingFunc(){
    local fn=$1
    startLoading
    "$fn"
    stopLoading
}

ctrlC(){
    echo "Cancelled by user!"
    echo "Cancelled by user!" >> $LOG_FILE
}

# A list of K8S configmap name used as write-locks.
# Need to be cleand on exit.
CDF_WRITE_LOCKS=
cleanup_on_exit() {
    ctrlC
    if [ -n $CDF_HOME ]; then
        for lock in ${CDF_WRITE_LOCKS}; do
            $CDF_HOME/bin/kubectl delete -n ${CDF_NAMESPACE} configmap ${lock} --force --grace-period=0 > /dev/null 2>&1
        done
    fi
    exit 2
}

# 2 SIGINT
trap "cleanup_on_exit" 2
# 3 SIGQUIT
trap "cleanup_on_exit" 3

exec_cmd(){
    local MASK_REG_EXP="(?i)(sessionId|token|password|pass|passPhrase|key|crt|cert|tls\.(key|cert|crt|ca)|\.dockerconfigjson|\.caCert)(\"?\s*[:=]\s*)[^',}\s]*"
    local msOption="-ms"
    if [[ "$CDF_DEV_INSECURITY_DEBUG_LOG" == "true" ]];then
        msOption=""
    fi
    $CURRENTDIR/bin/cmd_wrapper -c "$1" -f $LOG_FILE -x=DEBUG $msOption -mre $MASK_REG_EXP $2 $3 $4 $5
    return $?
}

getRfcTime(){
    local fmt=$1
    date --rfc-3339=${fmt}|sed 's/ /T/'
}

toUpper(){
    echo "$1"|tr '[:lower:]' '[:upper:]'
}

toLower(){
    echo "$1"|tr '[:upper:]' '[:lower:]'
}

write_log() {
    local level=$1
    local msg=$2
    local status=$3
    local consoleTimeFmt=$(getRfcTime 'seconds')
    local logTimeFmt=$(getRfcTime 'ns')
    [ -n "$status" ] && showStatus "$status"
    if [[ -n "$CDF_LOADING_LAST_PID" ]] && [[ "$level" =~ ^(cata|step|info|warn|error|loading|fatal)$ ]];then
        stopLoading
    fi
    case $level in
        cata)
            echo -e "$consoleTimeFmt INFO : [NODE:${THIS_NODE}] $msg";;
        debug)
            if [ -n "$TMP_FOLDER" -a -n "$LOG_FILE" ]; then
                echo -e "$logTimeFmt DEBUG $msg" >>$LOG_FILE
            else
                echo -e "$logTimeFmt DEBUG $msg"
            fi
            ;;
        step)
            echo -n "$consoleTimeFmt INFO : $msg" && uniformStepMsgLen "${#msg}"
            if [ -n "$TMP_FOLDER" -a -n "$LOG_FILE" ]; then
                echo -e "$logTimeFmt INFO  $msg" >>$LOG_FILE
            else
                echo -e "$logTimeFmt INFO  $msg"
            fi
            startLoading
            ;;
        info|warn|error)
            if [ -n "$TMP_FOLDER" -a -n "$LOG_FILE" ]; then
                echo -e "$consoleTimeFmt `echo $level|tr [:lower:] [:upper:]` : $msg" && echo -e "$logTimeFmt `echo $level|tr [:lower:] [:upper:]`  $msg" >>$LOG_FILE
            else
                echo -e "$consoleTimeFmt `echo $level|tr [:lower:] [:upper:]` : $msg"
            fi
            ;;
        loading)
            echo -n "$consoleTimeFmt INFO : $msg " && echo -e "$logTimeFmt `echo $level|tr [:lower:] [:upper:]`  $msg" >>$LOG_FILE
            startLoading
            ;;
        fatal)
            if [ -n "$TMP_FOLDER" -a -n "$LOG_FILE" ]; then
                echo -e "$consoleTimeFmt FATAL : $msg" && echo -e "$logTimeFmt FATAL $msg" >>$LOG_FILE
            else
                echo -e "$consoleTimeFmt FATAL : $msg"
            fi
            exit 1 ;;
        *)
            if [ -n "$TMP_FOLDER" -a -n "$LOG_FILE" ]; then
                echo -e "$consoleTimeFmt INFO : $msg" && echo -e "$logTimeFmt INFO  $msg" >>$LOG_FILE
            else
                echo -e "$consoleTimeFmt INFO : $msg"
            fi
            ;;
    esac
}

validatePwd(){
    local n=0
    local pwd="$1"

    for patten in '[0-9]' '[a-z]' '[A-Z]' '[^0-9a-zA-Z]'
    do
        if [[ $(echo $pwd|grep -P "$patten" >/dev/null 2>&1; echo $?) -eq 0 ]]; then
            n=$((n+1))
        fi
    done

    if [ $(echo $pwd|grep -P "\s" >/dev/null 2>&1; echo $?) -ne 0 -a ${#pwd} -ge 8 -a ${#pwd} -le 20 -a $n -ge 4 ]; then
        return 0
    else
        return 1
    fi
}

uniformStepMsgLen(){
    local msgLen=$1
    local maxLen=70
    local dots=""
    [ "$msgLen" -gt "$maxLen" ] && local dotLen=3 ||  local dotLen=$(($maxLen-$msgLen))
    while [ $dotLen -gt 0 ]
    do
        dots="${dots}."
        dotLen=$((dotLen-1))
    done
    echo -n "$dots "
}

showStatus(){
    stopLoading
    local status=$(echo $1|tr [:lower:] [:upper:])
    echo -e "[ $status ]"
}

checkParm(){
    # Do NOT use exec_cmd() in this function because exec_cmd needs log file,
    # but the tmp folder and log file has not been initialized.
    local key=$1;shift
    local val=$1;shift

    case "$key" in
        --cat|--cdf-admin-tasks)
            if [[ -z "$val" ]];then
                return
            fi
            if echo $val|grep -Pq '[^a-z,]';then
                write_log "fatal" "Invalid value for $key: $val, allowed values: ns,no,pv,cr,pc.(separate multiple types with commas)"
            fi
            local err_args;err_args=$(echo $val|awk -F, '{for(i=1;i<=NF;i++)switch($i){case /^(ns|no|pv|cr|pc)$/:break;default:printf("%s ",$i)}}')
            if [ -n "$err_args" ];then
                write_log "fatal" "Invalid value for $key: $val, error type: $err_args, allowed type: ns,no,pv,cr,pc.(separate multiple types with commas)"
            fi
            ;;
        --nfs-server|--nfsprov-server)
            if [ "$val" == "localhost" ] || [ "$val" == "127.0.0.1" ];then
                write_log "fatal" "Invalid value for $key: $val, you cannot use '$val' value for '$key' parameter, it must be either IPv4 address or FQDN instead";
            fi
            ;;
        --cluster-name|CLUSTER_NAME)
            if [ -n "$(echo  $val | grep '[^a-zA-Z0-9_-]' 2>/dev/null)" ] || [ $(echo $val | wc -c 2>/dev/null) -gt 65 ];then  #note: as string as treaded as null-terminated, charactor num of "" is 1
                write_log "fatal" "Invalid value for $key: $val, allowed values: alphanumeric,\"-\",\"_\", with max length 64";
            fi
            ;;
        --cdf-home|CDF_HOME|--k8s-home|K8S_HOME|--nfs-folder|--nfsprov-folder|--fluentd-log-cache-folder|FLUENTD_LOG_CACHE_FOLDER)
            if ! echo "$val"|grep -Pq '^/';then
                write_log "fatal" "Invalid value for $key: '$val', $key must be an absolute path.";
            fi
            ;;
        --cluster-wide-ingress)
            if [[ ! "$val" =~ ^(true|false)$ ]];then
                write_log "fatal" "Invalid value for $key: '$val', allowed values: true or false.";
            fi
            ;;
        --ha-virtual-ip|--aws-eip|HA_VIRTUAL_IP|AWS_EIP)
            local result=$(validateIPv4Formate "$val")
            if [ "$result" = "false" ]; then write_log "fatal" "Invalid value for $key: $val, allowed value: ipv4 address"; fi
            ;;
        -t|--timeout|--keepalived-virtual-router-id|--keepalived-advert-int|--master-api-ssl-port|--external-access-port|--system-user-id|--system-group-id|--pod-cidr-subnetlen|--k8s-user-id|--k8s-group-id|--etcd-user-id|--etcd-group-id|KEEPALIVED_VIRTUAL_ROUTER_ID|KEEPALIVED_ADVERT_INT|MASTER_API_SSL_PORT|EXTERNAL_ACCESS_PORT|SYSTEM_USER_ID|SYSTEM_GROUP_ID|K8S_USER_ID|K8S_GROUP_ID|ETCD_USER_ID|ETCD_GROUP_ID|POD_CIDR_SUBNETLEN|CDF_APISERVER_POD_START_LIMIT)
            if [ $(echo $val | grep '[^0-9]' |wc -l) -ne 0 ];then write_log "fatal" "Invalid value for $key: $val, allowed value: integer"; fi
            ;;
        --pod-cidr|--service-cidr|POD_CIDR|SERVICE_CIDR)
            if [[ "$val" =~ "/" ]];then
                local ip=${val%%/*}
                local netmask=${val#*/}
                local result=$(validateIPv4Formate "$ip")
                if [ "$result" = "false" ]; then
                    write_log "fatal" "Invalid value for $key: $val, allowed value: ipv4 address"
                fi
                if [ $(echo $netmask | grep '[^0-9]' |wc -l) -ne 0 ];then
                    write_log "fatal" "Invalid value for netmask of $key: $val, allowed value: integer"
                fi
            else
                write_log "fatal" "Invalid value for netmask of $key: $val, allowed value: ipv4/masklen"
            fi
            ;;
        --keepalived-nopreempt|--fail-swap-on|--auto-configure-firewall|--skip-check-on-node-lost|--skip-failed-worker-node|--db-tls-skip-hostname-verification|--ipv6|IPV6|SET_FQDN_IN_INGRESS|KEEPALIVED_NOPREEMPT|FAIL_SWAP_ON|AUTO_CONFIGURE_FIREWALL|SKIP_CHECK_ON_NODE_LOST|SKIP_FAILED_WORKER_NODE|SET_APPHUB_CLUSTER_ADMIN)
            if [ "$val" != "true" -a "$val" != "false" ];then  write_log "fatal" "Invalid value for $key: $val, allowed values: true/false"; fi
            ;;
        -fg|--feature-gates|FEATURE_GATES)
            if ! echo "$val"|grep -Pq '^(\w+=(true|false),)*(\w+=(true|false))$';then
                write_log "fatal" "Invalid value for $key: '$val', a set of key=value pairs that describe feature gates for alpha/experimental features, comma-delimited list of strings, each entry format is NameOfFeature=true|false";
            fi
            checkFeatureGates "$val"
            checkUnusedFeatureGates "$val"
            ;;
        --capabilities|CAPABILITIES)
            if ! echo "$val"|grep -Pq '^(\w+=(true|false),)*(\w+=(true|false))$';then
                write_log "fatal" "Invalid value for $key: '$val', \
a set of key=value pairs that describe feature for capabilities, \
comma-delimited list of strings, each entry format is NameOfOption=true|false. \
allowed names: Tools|Monitoring|MonitoringContent|LogCollection|DeploymentManagement|ClusterManagement|NfsProvisioner|K8sBackup. \
\nFor example: 'Tools=true,Monitoring=true,LogCollection=true,DeploymentManagement=true,ClusterManagement=true,K8sBackup=true'";
            fi
            local arr;arr=$(echo "$val"|sed 's/,/ /g'|xargs -n1|awk -F= '{print $1}')
            for name in $arr;do
                if [[ ! "$name" =~ ^(Tools|Monitoring|MonitoringContent|LogCollection|DeploymentManagement|SuiteDeploymentManagement|ClusterManagement|NfsProvisioner|K8sBackup)$ ]];then
                    write_log "fatal" "Invalid value for '--capabilities', \
allowed names: Tools|Monitoring|MonitoringContent|LogCollection|DeploymentManagement|ClusterManagement|NfsProvisioner|K8sBackup. \
\nFor example: 'Tools=true,Monitoring=true,LogCollection=true,DeploymentManagement=true,ClusterManagement=true,K8sBackup=true'";
                fi
            done
            ;;
        --storage-class|DEFAULT_STORAGE_CLASS)
            if ! echo "$val"|grep -Pq '^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$';then
                write_log "fatal" "Invalid value for $key: '$val', \
a storage class name must consist of lower case alphanumeric characters or '-', and must start and end with an alphanumeric character (e.g. 'my-name',  or '123-abc', regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?').";
            fi
            ;;
        --storage-class-mappings|STORAGE_CLASS_MAPPINGS)
            local exp='[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*'
            if ! exec_cmd "echo '$val'|grep -Pq '^($exp=$exp,)*($exp=$exp)$'";then
                write_log "fatal" "Invalid value for $key: '$val', \
a set of key=value pairs that mapping storage class name while creating persistent volumes and persistent volume claims, \
comma-delimited list of strings, each entry format is 'storageclass-a=storageclass-1', \
a key/value must consist of lower case alphanumeric characters or '-', and must start and end with an alphanumeric character (e.g. 'my-name',  or '123-abc', regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?'). \
\nFor example: 'itom-fast=demo-quick,itom-slow=demo-slow'.";
            fi
            local invalids="$(echo $val|awk -F'=|,' '{for(i=1;i<=NF;i++){if(length($i)>63)print $i}}')"
            if [[ -n "$invalids" ]];then
                write_log "fatal" "Invalid value: '$(echo "$invalids"|xargs|tr ' ' ',')': must be no more than 63 characters"
            fi
            local c1="$(echo $val|sed 's/,/ /g'|xargs -n1|awk -F= '{print $1}'|wc -l)"
            local c2="$(echo $val|sed 's/,/ /g'|xargs -n1|awk -F= '{print $1}'|sort|uniq|wc -l)"
            if [[ "$c1" != "$c2" ]];then
                write_log "fatal" "Invalid value for $key: '$val', there are duplicate keys in '$val'."
            fi
            ;;
        --tls-ciphers|TLS_CIPHERS)
            if ! echo "$val"|grep -Pq '^[a-zA-Z0-9_]+(,[a-zA-Z0-9_]+)*$';then
                write_log "fatal" "Invalid value for $key: $val, please use a comma-separated list of ciphers, for example: $DEFAULT_TLS_CIPHERS.";
            fi
            checkCipherSuiteNames "$val"
            ;;
        --tls-min-version|TLS_MIN_VERSION)
            if [[ ! "$val" =~ ^(TLSv1\.2|TLSv1\.3)$ ]];then
                write_log "fatal" "Invalid value for $key: $val, allowed values: TLSv1.2,TLSv1.3.";
            fi
            ;;
        --loadbalancer-info)
            if ! echo "$val"|grep -Pq '^([^ =;]+=[^ ;]+;)*[^ =;]+=[^ ;]+$';then
                write_log "fatal" "Invalid value for $key: '$val', \
a set of key=value pairs that describe loadbalancer info, \
semicolon list of strings, each entry format is NameOfOption=value.For example: 'aws-load-balancer-type=nlb;LOADBALANCERSOURCERANGES=172.10.0.0/16,172.20.0.0/16'";
            fi
            local ranges="$(echo "$val"|grep -Po '(?<=LOADBALANCERSOURCERANGES=)[^;]+')"
            if [[ -n "$ranges" ]];then
                # 172.20.0.0/16,172.20.0.0/16
                if ! echo "$ranges"|grep -Pq '^\d+(\.\d+){3}/\d+(,\d+(\.\d+){3}/\d+)*$';then
                    write_log "fatal" "Invalid value for $key: 'LOADBALANCERSOURCERANGES=$ranges', the correct format is'LOADBALANCERSOURCERANGES=x.x.x.x/x,y.y.y.y/y', for example: 'LOADBALANCERSOURCERANGES=172.10.0.0/16,172.20.0.0/16'."
                fi
            fi
            ;;
        --node-selector)
            if ! echo "$val"|grep -Pq '^([^ =,]+=[^ =,]+,)*[^ =,]+=[^ =,]+$';then
                write_log "fatal" "Invalid value for $key: '$val', \
must be a comma separated list of key value pairs and enclosed with single quoutes, such as: 'master=label,worker=label'";
            fi
            ;;
        -d|-n|--deployment-name|DEPLOYMENT_NAME)
            if [[ "$(echo "$val"|tr '[:upper:]' '[:lower:]')" =~ ^(default|kube-public|kube-system|kube-node-lease)$ ]];then
                write_log "fatal" "The '$val' is invalid: you cannot use the system's namespace name.";
            fi
            if ! echo "$val"|grep -P '^[a-z0-9]([-a-z0-9]*[a-z0-9])?$' -q;then
                write_log "fatal" "The '$val' is invalid: the name must consist of alphanumeric characters or '-', and must start and end with an alphanumeric character (e.g. 'my-name',  or '123-abc', regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?')";
            fi
            ;;
        --cdf-namespace|CDF_NAMESPACE)
            if [[ "$(echo "$val"|tr '[:upper:]' '[:lower:]')" =~ ^(default|kube-public|kube-system|kube-node-lease)$ ]];then
                write_log "fatal" "The '$val' is invalid: you cannot use the system's namespace name.";
            fi
            if ! echo "$val"|grep -P '^[a-z0-9]([-a-z0-9]*[a-z0-9])?$' -q;then
                write_log "fatal" "The '$val' is invalid: the name must consist of alphanumeric characters or '-', and must start and end with an alphanumeric character (e.g. 'my-name',  or '123-abc', regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?')";
            fi
            ;;
        --tmp-folder|TMP_FOLDER)
            if [ ! -d "$val" ]; then
                mkdir -p $val 2>/dev/null || write_log "fatal" "Temporary folder $val does not exist and failed to create it."
            fi
            if ! touch "$val/cdf_test_tmp_folder.txt" 2>/dev/null;then
                write_log "fatal" "The '$val' is invalid: permission denied: no write permission under $val";
            fi
            ;;
        --flannel-backend-type|FLANNEL_BACKEND_TYPE)
            if [ "$val" != "host-gw" -a "$val" != "vxlan" ];then write_log "fatal" "Invalid value for $key: $val, allowed values: host-gw/vxlan"; fi
            ;;
        --cloud-provider|CLOUD_PROVIDER)
            val=$(echo $val|tr '[:upper:]' '[:lower:]')
            if [[ ! "$val" =~ ^(aws|azure|gcp|openshift|generic|none)$ ]];then
                write_log "fatal" "Invalid value for $key: $val, allowed values: $(echo 'aws|azure|gcp|openshift|generic'|sed -e 's@|@/@g'), 'generic' allows to install a generic kubernetes.";
            fi
            ;;
        -e|--end-state)
            if [ "$val" != "full-cdf" -a "$val" != "suite" ];then write_log "fatal" "Invalid value for $key: $val, allowed values: full-cdf/suite";fi
            ;;
        -m|--metadata|-p|--properties|--kube-dns-hosts|-c|--config|--registry-password-file|--registry-ca|--backup-storage-credential-file|--backup-storage-api-ca|REGISTRY_CA|KUBE_DNS_HOSTS)
            if [ ! -f "$val" ];then write_log "fatal" "File of $key: $val, but does not exist"; fi
            if [[ ! "$val" =~ ^/ ]];then write_log "fatal" "File of $key: $val, file is not absolute path"; fi
            ;;
        --node-type)
            if [ "$val" != "master" -a "$val" != "worker" ];then write_log "fatal" "Invalid value for $key: $val, allowed values: master/worker"; fi
            ;;
        -i|--image-folder)
            local silent_ifolder_array=${val//,/ }
            silent_ifolder_array=(${silent_ifolder_array})
            for folder in ${silent_ifolder_array[@]};do
                if [ ! -d $folder ] || [ "$(ls $folder | wc -w)" -eq 0 ]; then
                    write_log "fatal" "$folder not exist or empty"
                fi
            done
            ;;
        -P|--password)
            if [ $(validatePwd "$val"; echo $?) -ne 0 ]; then write_log "fatal" "Password does not meet policy requirement.\n$(printPasswordPolicy)"; fi;
            ;;
        --validity|CERTIFICATE_PERIOD)
            expr $val "+" 1 &>/dev/null
            if [ $? -ne 0 ] || [ $val -lt $CERTIFICATE_MINIMUM_PERIOD ] || [ $val -ge $CERTIFICATE_MAXIMUM_PERIOD ];then
                write_log "fatal" "Invalid value for $key: $val, the certificate period cannot be greater than $CERTIFICATE_MAXIMUM_PERIOD or less than $CERTIFICATE_MINIMUM_PERIOD, recommended value: [1-365]";
            fi
            if [ $val -gt $CERTIFICATE_RECOMMEND_PERIOD ];then
                write_log "warn" "The certificate validity is set to $val days. The recommended certificate validity period is less than or equal to 365 days";
            fi
            ;;
        --logging-vol-size)
            checkVolumeSize "$key" "$val"
            ;;
        --device-type|DEVICE_TYPE)
            # if [ "$val" != "looplvm" ] && [ "$val" != "directlvm" ] && [ "$val" != "thinpool" ] && [ "$val" != "overlay2" ] && [ "$val" != "overlayfs" ];then
            #     write_log "fatal" "Invalid value for $key: $val, allowed value: overlayfs";
            # fi
            if [ "$val" != "overlayfs" ];then
                write_log "warn" "Supporting *only* the overlayfs storage driver. Ignoring user-supplied storage driver configuration."
            fi
            ;;
        --app-http-proxy|--app-https-proxy|--crt-http-proxy|--crt-https-proxy|APP_HTTP_PROXY|APP_HTTPS_PROXY|CRT_HTTP_PROXY|CRT_HTTPS_PROXY)
            if ! echo "$val" | grep -qP '^\s*([1-9]|[1-9]\d|1\d{2}|2([0-4]\d|5[0-5]))(\.(\d|[1-9]\d|1\d{2}|2([0-4]\d|5[0-5]))){3}(:([1-9]\d*))*\s*$|^\s*[a-zA-Z][\da-zA-Z.-]*(:([1-9]\d*))*\s*$|^\s*https?://([a-zA-Z][\da-zA-Z.-]*|([1-9]|[1-9]\d|1\d{2}|2([0-4]\d|5[0-5]))(\.(\d|[1-9]\d|1\d{2}|2([0-4]\d|5[0-5]))){3})(:([1-9]\d*))?/?\s*$'; then
                write_log "fatal" "Invalid value for $key: $val";
            fi
            ;;
        --app-no-proxy|--crt-no-proxy|APP_NO_PROXY|CRT_NO_PROXY)
            local oldIFS=$IFS
            IFS=","
            for item in ${val}
            do
                                            #ipv4 address                                                                                                    #other formats
                if ! echo $item | grep -qP '^\s*([1-9]|[1-9]\d|1\d{2}|2([0-4]\d|5[0-5]))(\.(\d|[1-9]\d|1\d{2}|2([0-4]\d|5[0-5]))){3}(/([1-9]|[1-2]\d|3[0-2]))?\s*$|^\s*[a-zA-Z.*][\da-zA-Z.*-]*\s*$'; then
                    IFS=$oldIFS
                    write_log "fatal" "Invalid value for $key: $item";
                fi
            done
            IFS=$oldIFS
            ;;
        --load-balancer-host|LOAD_BALANCER_HOST)
            if echo $val|grep -qP '^(\d+\.){3}\d+$';then
                if ! echo $val | grep -qP '^([1-9]|[1-9]\d|1\d{2}|2([0-4]\d|5[0-5]))(\.(\d|[1-9]\d|1\d{2}|2([0-4]\d|5[0-5]))){3}$'; then
                    write_log "fatal" "Invalid value for $key: $val";
                fi
            else
                if ! echo $val | grep -qP '^[\da-zA-Z][\da-zA-Z._-]*[\da-zA-Z]$'; then
                    write_log "fatal" "Invalid value for $key: $val";
                fi
            fi
            ;;
        --registry-orgname|REGISTRY_ORGNAME)
            if [[ $val =~ [A-Z] ]]; then
                write_log "fatal" "Invalid value for $key: $val, registry orgnization name must be lowercase."
            fi
            ;;
        --fips-entropy-threshold|FIPS_ENTROPY_THRESHOLD|--persistence-threshold)
            expr $val "+" 0 >/dev/null 2>&1
            if [ $? -ne 0 ] || [ $val -lt 1 ];then
                write_log "fatal" "Invalid value for $key: $val, recommended value: the digit greater than 0";
            fi
            ;;
        --external-access-host)
            # absolute: xxx.xxx.    xxx.
            # relative: xxx.xxx
            # not support: xxx
            if ! echo "$val"|grep -iqP '^[a-z0-9.-]+$';then
                write_log "fatal" "Invalid value for $key: $val, FQDN can contain characters \"a to z\", \"0 to 9\", and \"-\" (hyphen) only. Other common characters are not allowed."
            fi
            if echo "$val"|grep -iqP '^[a-z0-9-]+$';then
                write_log "fatal" "Invalid value for $key: $val, invalid FQDN: '$val'"
            fi
            if echo "$val"|grep -iqP '^\.|\.{2}';then
                write_log "fatal" "Invalid value for $key: $val, each sub-domain does not allow empty."
            fi
            local relative_fqdn=$(echo "$val"|sed -e 's/.$//')
            if [[ "$(echo "$relative_fqdn"|awk -F. '{for(i=1;i<=NF;i++)if(length($i)>63)print "false"}')" == "false" ]];then
                write_log "fatal" "Invalid value for $key: $val, the length of each sub-domain cannot be greater than 63."
            fi
            ;;
    esac
}
checkInstallProperty(){
    local kv_array
    local old_ifs=$IFS
    IFS=$'\n'
    kv_array=$(cat $CONFIGFILE | grep "^[^#]")
    kv_array=(${kv_array[@]})
    for kv in ${kv_array[@]}; do
        local key=${kv%%=*}
        local val=${kv#*=}
        val=$(echo $val | sed "s/^['\"]//g" | sed "s/['\"]$//g")  #only trim the quote charactors
        checkParm "$key" "$val"
    done
    IFS=$old_ifs
}

checkCaNumber(){
    local cert="$1"
    local certTips="$2"
    local originCert="${3:-"$cert"}"
    if [[ "$(grep -P '\-+\s*BEGIN\s+' $cert 2>/dev/null|wc -l)" -gt 64 ]];then
        echo "! Warning: \"$certTips\" contains too many CA certificates. please remove irrelevant CA from \"$originCert\". For AWS RDS, please use the region-specific CA bundle instead of global-bundle which contains all of region CA."
        if [[ "$CLI_SKIP_PRECHECK_WARNING" != "true" ]];then
            read -p "Are you sure you want to continue? (Yy/Nn) " confirm
            if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                exit 1
            fi
        fi
    fi
}

checkAllCaNumber(){
    if [[ -n "$REGISTRY_CA" ]];then
        checkCaNumber "$REGISTRY_CA" "Certificate file specified in command line --registry-ca: $REGISTRY_CA"
    fi
    if [[ -n "$SUITEDB_CERT" ]];then
        checkCaNumber "$SUITEDB_CERT" "Certificate file specified in command line --db-crt: $SUITEDB_CERT"
    fi
    if [[ -n "$BACKUP_STORAGE_API_CA" ]];then
        checkCaNumber "$BACKUP_STORAGE_API_CA" "Certificate file specified in command line --backup-storage-api-ca: $BACKUP_STORAGE_API_CA"
    fi

    if [ -n "$SILENT_CONFIG_FILE" ]; then
        local dbcert=
        dbcert="$(getValueFromConfig '.database.param.dbCert')"
        if [[ -n "$dbcert" ]];then
            local mergeCert="${TMP_FOLDER}/.cdf_dbcacerts.tmp"
            createDbCertsMergeFile "$dbcert" "$mergeCert"
            checkCaNumber "$mergeCert" "In config file ${SILENT_CONFIG_FILE}, the file in item .database.param.dbCert: $dbcert" "$dbcert"
            exec_cmd "$MV -f $mergeCert"
        fi

        local rootCrt=
        rootCrt="$(getValueFromConfig '.connection.rootCrt')"
        if [[ -n "$rootCrt" ]];then
            checkCaNumber "$rootCrt" "In config file ${SILENT_CONFIG_FILE}, the file in item .connection.rootCrt: $rootCrt"
        fi
    fi
}

checkSilentConfig(){
    local masters=$(getValueFromConfig '.masterNodes|length')
    local workers=$(getValueFromConfig '.workerNodes|length')
    local n=0
    for (( n=0; n<masters; n++ ));do
        local device_type=$(getValueFromConfig ".masterNodes[$n].deviceType")
        local host=$(getValueFromConfig ".masterNodes[$n].hostname")
        if [[ -z "$device_type" ]];then
            write_log "debug" "Supporting *only* the overlayfs storage driver. Ignoring deviceType=$device_type for $host."
        elif [[ "$device_type" != "overlayfs" ]]; then
            write_log "warn" "Supporting *only* the overlayfs storage driver. Ignoring deviceType=$device_type for $host."
        fi
    done
    for (( n=0; n<workers; n++ ));do
        local device_type=$(getValueFromConfig ".workerNodes[$n].deviceType")
        local host=$(getValueFromConfig ".workerNodes[$n].hostname")
        if [[ -z "$device_type" ]];then
            write_log "debug" "Supporting *only* the overlayfs storage driver. Ignoring deviceType=$device_type for $host."
        elif [[ "$device_type" != "overlayfs" ]]; then
            write_log "warn" "Supporting *only* the overlayfs storage driver. Ignoring deviceType=$device_type for $host."
        fi
    done
}

getCapabilitiesValue(){
    if [[ "$K8S_PROVIDER" =~ ^cdf ]];then
        local defaultTools=true
        local defaultMonitoring=true
        local defaultLogCollection=true
        local defaultDeploymentManagement=true
        local defaultClusterManagement=true
        local defaultK8sBackup=true
    else
        local defaultTools=true
        local defaultMonitoring=false
        local defaultLogCollection=false
        local defaultDeploymentManagement=true
        local defaultClusterManagement=false
        local defaultK8sBackup=false
    fi

    local val

    val=$(echo "$CAPABILITIES"|grep -Po '(^|,)Tools=(true|false)'|awk -F= '{print $2}'|tail -n1)
    export CAPS_TOOLS="${val:-"$defaultTools"}"

    val=$(echo "$CAPABILITIES"|grep -Po '(^|,)Monitoring=(true|false)'|awk -F= '{print $2}'|tail -n1)
    export CAPS_MONITORING="${val:-"$defaultMonitoring"}"

    val=$(echo "$CAPABILITIES"|grep -Po '(^|,)LogCollection=(true|false)'|awk -F= '{print $2}'|tail -n1)
    export CAPS_LOG_COLLECTION="${val:-"$defaultLogCollection"}"

    val=$(echo "$CAPABILITIES"|grep -Po '(^|,)DeploymentManagement=(true|false)'|awk -F= '{print $2}'|tail -n1)
    export CAPS_DEPLOYMENT_MANAGEMENT="${val:-"$defaultDeploymentManagement"}"

    val=$(echo "$CAPABILITIES"|grep -Po '(^|,)ClusterManagement=(true|false)'|awk -F= '{print $2}'|tail -n1)
    export CAPS_CLUSTER_MANAGEMENT="${val:-"$defaultClusterManagement"}"

    local defaultMonitoringContent=$CAPS_MONITORING
    val=$(echo "$CAPABILITIES"|grep -Po '(^|,)MonitoringContent=(true|false)'|awk -F= '{print $2}'|tail -n1)
    export CAPS_MONITORING_CONTENT="${val:-"$defaultMonitoringContent"}"

    local defaultSuiteDeploymentManagement=false
    if [ -z "$SILENT_CONFIG_FILE" ]; then
        defaultSuiteDeploymentManagement=true
    else
        if [[ -n "$METADATA" ]];then
            defaultSuiteDeploymentManagement=true
        fi
    fi
    # val=$(echo "$CAPABILITIES"|grep -Po 'SuiteDeploymentManagement=(true|false)'|awk -F= '{print $2}'|tail -n1)
    export CAPS_SUITE_DEPLOYMENT_MANAGEMENT="$defaultSuiteDeploymentManagement"

    local defaultNfsProvisioner=false
    if [[ "$K8S_PROVIDER" =~ ^cdf ]] && [[ "$defaultSuiteDeploymentManagement" == "false" ]];then
        # onPremise helm/bosun: NfsProvisioner default is true
        defaultNfsProvisioner=true
    fi
    val=$(echo "$CAPABILITIES"|grep -Po '(^|,)NfsProvisioner=(true|false)'|awk -F= '{print $2}'|tail -n1)
    export CAPS_NFS_PROVISIONER="${val:-"$defaultNfsProvisioner"}"

    if [[ ! "$K8S_PROVIDER" =~ ^cdf ]];then
        # BYOK
        if [[ "$CAPS_CLUSTER_MANAGEMENT" == "true" ]];then
            write_log "warn" "In the BYOK environment, install will automatically set the 'ClusterManagement' capability to false."
            CAPS_CLUSTER_MANAGEMENT=false
        fi
        if [[ "$CAPS_LOG_COLLECTION" == "true" ]];then
            write_log "warn" "LogCollection may not collect the container standard out log because install cannot determine the k8s container runtime type and log location. please configure it later if log collection doesn't work."
        fi
    fi

    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]];then
        CAPS_CLUSTER_MANAGEMENT=false
    fi

    val=$(echo "$CAPABILITIES"|grep -Po '(^|,)K8sBackup=(true|false)'|awk -F= '{print $2}'|tail -n1)
    export CAPS_K8S_BACKUP="${val:-"$defaultK8sBackup"}"

    checkCapabilities
}

checkCapabilities(){
    if [[ "$CAPS_TOOLS" == "false" ]] && [[ "$CAPS_LOG_COLLECTION" == "false" ]] && [[ "$CAPS_MONITORING" == "false" ]] && [[ "$CAPS_MONITORING_CONTENT" == "false" ]] && [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]] && [[ "$CAPS_CLUSTER_MANAGEMENT" == "false" ]];then
        write_log "fatal" "Doesn't make sense installing nothing, because all capabilities are false."
    fi
    if [[ "$K8S_PROVIDER" =~ ^cdf ]];then
        if [[ "$CAPS_TOOLS" == "false" ]];then
            write_log "fatal" "For $PRODUCT_SHORT_NAME K8S environment, $PRODUCT_SHORT_NAME always deploy 'Tools' capability."
        fi
    fi
    if [[ "$K8S_PROVIDER" == "openshift" ]] && [[ "$CAPS_MONITORING" == "true" ]];then
        write_log "fatal" "On Openshift Kubernetes environment, it does not support enabling 'Monitoring' capability."
    fi
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]] && [ "$CAPS_LOG_COLLECTION" == "true" -o "$CAPS_MONITORING" == "true" -o "$CAPS_CLUSTER_MANAGEMENT" == "true" -o "$CAPS_MONITORING_CONTENT" == "true" ];then
        if [[ -z "$SILENT_CONFIG_FILE" ]];then
            write_log "fatal" "Abort installation because the '-c|--config' is not provided when 'Monitoring=$CAPS_MONITORING,MonitoringContent=$CAPS_MONITORING_CONTENT,LogCollection=$CAPS_LOG_COLLECTION,DeploymentManagement=false'. \
If you want to install $PRODUCT_SHORT_NAME for classic suite, please don't set SuiteDeploymentManagement=false and DeploymentManagement=false. If you want to install $PRODUCT_SHORT_NAME for helmified product, please add -c option."
        fi
    fi

    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]] && [[ "$(isEnabledByFeatureName AppHubUI)" == "true" ]];then
        write_log "warn" "Dependent capability \"DeploymentManagement\" is not enabled, feature gate \"AppHubUI\" will be ignored."
    fi

    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]] && [ -n "$SUITEDB_URL" -o -n "$SUITEDB_USER" -o -n "$SUITEDB_PASSWORD" ];then
        write_log "warn" "Dependent capability \"DeploymentManagement\" is not enabled, external cdfapiserver database configuration parameters will be ignored."
    fi

    if [[ "$CAPS_MONITORING_CONTENT" == "true" ]] && [ "$CAPS_CLUSTER_MANAGEMENT" == "false" -a "$CAPS_MONITORING" == "false" -a "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ];then
        write_log "fatal" "Abort installation because monitoring content cannot be deployed independently when 'Monitoring=false,MonitoringContent=true,DeploymentManagement=false,ClusterManagement=false'."
    fi

    if [[ "$CAPS_LOG_COLLECTION" == "true" ]] && [[ "$CAPS_CLUSTER_MANAGEMENT" == "false" ]] && [[ "$CAPS_MONITORING" == "false" ]] && [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]];then
        write_log "fatal" "Abort installation because LogCollection cannot be deployed independently when 'Monitoring=false,DeploymentManagement=false'."
    fi
}

checkUnusedFeatureGates(){
    local input_val=$1

    local selected_json
    for json in "$CURRENTDIR/cdf/cfg/feature-gates.json" "$CURRENTDIR/cfg/feature-gates.json" "$CURRENTDIR/feature-gates.json";do
        if [[ -f "$json" ]];then
            selected_json=$json
            break
        fi
    done

    if [[ -z "$selected_json" ]];then
        write_log "warn" "feature-gates.json not found"
        return
    fi

    local warn_fgs=""
    local unuseds="$(cat $selected_json|$JQ -r '.[]|select(.display==false).feature')"
    for fg_name in $(echo "$input_val"|sed -r 's/=(true|false),?/ /g');do
        if [[ "$(echo "$unuseds"|grep -Po "\b$fg_name\b")" == "$fg_name" ]];then
            warn_fgs="$fg_name $warn_fgs"
        fi
    done

    if [[ -n "$warn_fgs" ]];then
        write_log "warn" "The installation will ignore the current feature gates: $(echo "$warn_fgs"|xargs|sed 's/ /,/g')."
    fi
}

checkCipherSuiteNames(){
    local tlsCiphers=$1
    local cipherCheckList="$CURRENTDIR/cdf/cfg/cipher-suite-name.checklist"
    if [[ -n "$tlsCiphers" ]] && [[ -f "$cipherCheckList" ]];then
        local cipherNames=""
        for name in $(echo "$tlsCiphers"|sed 's/,/ /g');do
            if ! grep -Pq "^${name}\$" "$cipherCheckList";then
                cipherNames="${cipherNames} ${name}"
            fi
        done
        if [[ -n "$cipherNames" ]];then
            write_log "warn" "ciphers $(echo "$cipherNames"|xargs|sed 's/ /,/g') specified by --tls-ciphers are not secure or unknown."
        fi
    fi

    if [[ -n "$tlsCiphers" ]];then
        local tls12Cipher=false
        local tls13Cipher=false
        for name in $(echo "$tlsCiphers"|sed 's/,/ /g');do
            if [[ "$name" =~ ^(TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256)$ ]];then
                tls12Cipher=true
            elif [[ "$name" =~ ^(TLS_AES_128_GCM_SHA256|TLS_AES_256_GCM_SHA384)$ ]];then
                tls13Cipher=true
            fi
        done
        if [[ "$tls12Cipher" == "false" ]] || [[ "$tls13Cipher" == "false" ]];then
            write_log "fatal" "Customized cipher doens't contain the mandatory ciphers \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_AES_128_GCM_SHA256 or TLS_AES_256_GCM_SHA384\""
        fi
    fi
}

checkFeatureGates(){
    local input_val=$1

    local selected_json
    for json in "$CURRENTDIR/cdf/cfg/feature-gates.json" "$CURRENTDIR/cfg/feature-gates.json" "$CURRENTDIR/feature-gates.json";do
        if [[ -f "$json" ]];then
            selected_json=$json
            break
        fi
    done

    if [[ -z "$selected_json" ]];then
        write_log "warn" "feature-gates.json not found"
        return
    fi

    # check feature-name is exist in feature-gates.json
    local arr;arr=$(echo "$input_val"|awk -F, '{for(i=1;i<=NF;i++)print $i}')
    # change [{k1},{k2},...] to {k1,k2,...}
    local feature_gates;feature_gates=$(cat $selected_json|$JQ -r 'map({(.feature):(.default)})|add')
    local result=""
    for row in $arr
    do
        local feature_name=${row%=*}
        local feature_bool=${row#*=}
        result=$(echo $feature_gates|$JQ -r ".$feature_name")
        if [[ -z "$result" ]] || [[ "$result" == "null" ]];then
            local options="$(cat $selected_json|$JQ -r '.[]|select(.until=="").feature'|xargs|sed -e 's/ /,/g')"
            if [[ -z "$options" ]];then
                write_log "fatal" "Invalid feature parameter: '$feature_name', there are currently no feature gates available."
            fi
            write_log "fatal" "Invalid feature parameter: '$feature_name', currently supported features: $options."
        fi
        feature_gates=$(echo $feature_gates|$JQ -r ".$feature_name=\"$feature_bool\"")
    done
    # Used for generate literals
    FEATURE_GATES_CHECKED=$feature_gates
}

generateFeatureGatesLiterals(){
    checkFeatureGates $1

    FEATURE_GATES_LITERALS=""
    local keys;keys=$(echo $FEATURE_GATES_CHECKED|$JQ -r 'keys')
    local num;num=$(echo $keys|$JQ -r '.|length|.-1')
    local key=""
    local val=""
    for i in $(seq 0 "$num");do
        key=$(echo $keys|$JQ -r ".[$i]")
        val=$(echo $FEATURE_GATES_CHECKED|$JQ -r ".$key")
        if [[ -z "$key" ]] || [[ -z "$val" ]];then
            write_log "fatal" "Failed to generate feature-gates literals. $LOG_SUPPORT_MSG"
        fi
        FEATURE_GATES_LITERALS="$FEATURE_GATES_LITERALS --from-literal=$key=$val"
    done
}

createFeatureGatesConfigMap(){
    if [ "$NODE_TYPE" = "first" ]; then
      local cm_name="feature-gates"
      write_log "step" "Create the ${cm_name} configmap ..."
      if stepNotDone $FUNCNAME; then
        if [[ -z "$FEATURE_GATES_LITERALS" ]];then
            generateFeatureGatesLiterals "$FEATURE_GATES"
        fi
        local reTryTimes=0
        while true; do
            exec_cmd "kubectl create --save-config configmap ${cm_name} -n ${CDF_NAMESPACE} $FEATURE_GATES_LITERALS"

            if [ $? -eq 0 ] || [ $(exec_cmd "kubectl get configmap ${cm_name} -n ${CDF_NAMESPACE}"; echo $?) -eq 0 ] ; then
                write_log "debug" "Create ${cm_name} configmap successfully."
                break
            elif [ $reTryTimes -eq $RETRY_TIMES ]; then
                write_log "fatal" "Failed to create ${cm_name} configmap. $LOG_SUPPORT_MSG" "failed"
            else
                write_log "debug" "Failed to create ${cm_name} configmap. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
            fi
            reTryTimes=$(( $reTryTimes + 1 ))
            sleep $SLEEP_TIME
        done
        if ! exec_cmd "kubectl label configmap ${cm_name} -n ${CDF_NAMESPACE} deployments.microfocus.com/cleanup=uninstall";then
            write_log "fatal" "Failed to label ${cm_name} configmap. $LOG_SUPPORT_MSG" "failed"
        fi
        setStepDone $FUNCNAME
        showStatus "ok"
      else
        showStatus "Already done"
      fi
    fi
}

listFeatureGates(){
    local keys
    local selected_json
    for json in "$CURRENTDIR/cdf/cfg/feature-gates.json" "$CURRENTDIR/cfg/feature-gates.json" "$CURRENTDIR/feature-gates.json";do
        if [[ -f "$json" ]];then
            selected_json=$json
            keys=$(cat $selected_json|$JQ -r '.[]|select(.display==true).feature')
            break
        fi
    done
    if [[ -z "$keys" ]];then
        echo -e "                               There are currently no feature gates available."
        return
    fi
    local stage
    local default
    for feature in $keys;do
        stage=$(cat $selected_json|$JQ -r ".[]|select(.feature==\"$feature\").stage")
        default=$(cat $selected_json|$JQ -r ".[]|select(.feature==\"$feature\").default")
        echo -e "                               $feature=true|false ($stage - default=$default)"
    done
    echo -e "                           For example,\"$(echo $keys|head|awk '{print $1}')=true\"."
}

evaluateVariable(){
    local var=$1;shift
    local cli=$1;shift
    local default=$1;shift

    local str="if [ -z \"\$$cli\" -a -z \"\$$var\" ];then $var=$default; else $var=\${$cli:-\"\$$var\"}; fi "
    eval "$str"
    export $var
}

validateRegistryUsername(){
    local user="$1"
    if [ "$user" != "" ]; then
        return 0
    else
        return 1
    fi
}

inputRegistryUsername(){
    if [ -z "$REGISTRY_USERNAME" ]; then
        read -p "Registry username:   > " user_name_1
        while [ $(validateRegistryUsername "$user_name_1"; echo $?) -ne 0 ]; do
            echo -e "\nSorry, username cannot be empty."
            read -p "Registry username:   > " user_name_1
        done
        REGISTRY_USERNAME=$user_name_1
    fi
}

checkFeatureEnabled(){
    checkFeatureGates $FEATURE_GATES
    local feature="$(echo "$1"|tr '[:upper:]' '[:lower:]')"
    if [[ "$(echo $FEATURE_GATES_CHECKED|tr '[:upper:]' '[:lower:]'|$JQ -r ".$feature")" == "true" ]];then
        return 0
    fi
    return 1
}

checkSilentJsonFormat(){
    if [ -n "$SILENT_CONFIG_FILE" ]; then
        if ! $JQ -r . $SILENT_CONFIG_FILE >/dev/null 2>&1;then
            write_log "fatal" "Config file $SILENT_CONFIG_FILE is not a valid json file."
        fi
    fi
}

initEndState(){
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ]];then
        if [ -n "$SILENT_CONFIG_FILE" ]; then
            local try_deploy_suite=$($JQ -r 'has("capabilities")' $SILENT_CONFIG_FILE)
            if [ -z "$METADATA" ] && [ "$try_deploy_suite" == "true" ];then
                write_log "fatal" "When the 'capabilities' field exists in the configuration file, metadata is required."
            fi
        fi
    fi
    # check SILENT_END_STATE
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]];then
        if [ -n "$METADATA" ];then
            write_log "fatal" "Abort installation because when DeploymentManagement=false in capabilities, no metadata is required."
        fi
    fi
    if [[ -z "$METADATA" ]];then
        END_STATE="full-cdf"
    fi
    SILENT_END_STATE=${END_STATE:-"suite"}
}

checkUserHomeExist(){
    if [[ "$USER" != "root" ]] && [[ "$HOME" == "/root" ]] || [[ "$HOME" == "/" ]];then
        write_log "fatal" "Abort installation because the current user does not have a home directory."
    fi
}

checkExternalAccessHost(){
    if [[ -n "$SILENT_CONFIG_FILE" ]];then
        if [[ ! "$K8S_PROVIDER" =~ ^cdf ]];then
            # BYOK
            local externalHostname="$(getValueFromConfig '.connection.externalHostname')"
            if [[ -n "$externalHostname" ]] && [[ -n "$EXTERNAL_ACCESS_HOST" ]] && [[ "${externalHostname,,}" != "${EXTERNAL_ACCESS_HOST,,}" ]];then
                write_log "fatal" "Abort installation because the '.connection.externalHostname' in '$SILENT_CONFIG_FILE' is inconsistent with '--external-access-host' in the command line."
            fi
        fi

        local externalAccessPort="$(getValueFromConfig '.connection.externalAccessPort')"
        if [[ -n "$externalAccessPort" ]] && [[ -n "$CLI_EXTERNAL_ACCESS_PORT" ]] && [[ "${externalAccessPort,,}" != "${CLI_EXTERNAL_ACCESS_PORT,,}" ]];then
            write_log "fatal" "Abort installation because the '.connection.externalAccessPort' in '$SILENT_CONFIG_FILE' is inconsistent with '--external-access-port' in the command line."
        fi
    fi
}

checkApphubSecurityWarning(){
    if [[ "$CLI_SKIP_PRECHECK_WARNING" != "true" ]] && [[ "$SET_APPHUB_CLUSTER_ADMIN" == "true" ]];then
        echo "! Warning: You are about to deploy AppHub with cluster admin privileges. In normal operation this is not necessary and should only be enabled if instructed by OpenText Technical Support. If not then OpenText does not recommend the use of cluster admin privileges for AppHub."
        read -p "Are you sure you want to continue? (Yy/Nn) " confirm
        if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
            exit 1
        fi
    fi
}

getProductVersions(){
    # PLATFORM_VERSION
    if [ -f "${CURRENTDIR}/version.txt" ]; then
        PLATFORM_VERSION=$(cat ${CURRENTDIR}/version.txt)
        if [ -z ${PLATFORM_VERSION} ]; then
            write_log "fatal" "Failed to get platform version in ${CURRENTDIR}/version.txt. $MF_SUPPORT_MSG"
        fi
    else
        write_log "fatal" "File ${CURRENTDIR}/version.txt is not found. $MF_SUPPORT_MSG"
    fi
    export PLATFORM_VERSION

    # INTERNAL_VERSION
    if [ -f "${CURRENTDIR}/version_internal.txt" ]; then
        INTERNAL_VERSION=$(cat ${CURRENTDIR}/version_internal.txt)
        if [ -z ${INTERNAL_VERSION} ]; then
            write_log "fatal" "Failed to get internal version in ${CURRENTDIR}/version_internal.txt. $MF_SUPPORT_MSG"
        fi
    else
        write_log "fatal" "File ${CURRENTDIR}/version_internal.txt is not found. $MF_SUPPORT_MSG"
    fi
    export INTERNAL_VERSION
}

init_BYOK(){
    evaluateVariable "CDF_HOME" "CLI_CDF_HOME" "$HOME/cdf"
    evaluateVariable "CDF_NAMESPACE" "CLI_CDF_NAMESPACE" "$DEFAULT_CDF_NAMESPACE"
    #This is fresh install (not rerun) and CDF_HOME already exists and not empty
    if [ ! -f "$STEPS_FILE" ] && [ -d "$CDF_HOME" ] && [ $(ls $CDF_HOME | wc -l) -gt 0 ]; then
            write_log "fatal" "CDF_HOME:$CDF_HOME is not empty; it must be empty before installation. Clean up $CDF_HOME directory or specify a new CDF HOME with --cdf-home CLI parameter."
    fi
    local defaultCapabilites="Tools=true,Monitoring=false,LogCollection=false,DeploymentManagement=true,ClusterManagement=false"
    local enabledCapabilites="$(echo "$defaultCapabilites,$CLI_CAPABILITIES"|sed 's/,/ /g'|xargs -n1|awk -F= '{m[$1]=$2}END{for(k in m)if(m[k]=="true")print k}'|xargs)"
    if [[ "$enabledCapabilites" == "Tools" ]];then
        runCopyTools && setenv "is_byok_tools" || exit 1
        exit 0
    fi

    export readonly CDF_ALIAS="$CDF_HOME/scripts/itom-cdf-alias.sh"
    getMasterNodeTimeZone

    evaluateVariable "IPV6" "CLI_IPV6" "false"
    evaluateVariable "CAPABILITIES" "CLI_CAPABILITIES" ""
    evaluateVariable "CLUSTER_WIDE_INGRESS" "CLI_CLUSTER_WIDE_INGRESS" "" # default is false
    evaluateVariable "AWS_CERTIFICATE_ARN" "CLI_AWS_CERTIFICATE_ARN" ""
    evaluateVariable "APPHUB_HELM_VALUES" "CLI_APPHUB_HELM_VALUES" ""
    evaluateVariable "APP_HTTP_PROXY" "CLI_APP_HTTP_PROXY" ""
    evaluateVariable "APP_HTTPS_PROXY" "CLI_APP_HTTPS_PROXY" ""
    evaluateVariable "APP_NO_PROXY" "CLI_APP_NO_PROXY" ""
    evaluateVariable "FEATURE_GATES" "CLI_FEATURE_GATES" ""
    evaluateVariable "CERTIFICATE_PERIOD" "CLI_CERTIFICATE_PERIOD" "365"
    checkFeatureGatesSilentVols
    NODE_TYPE=${NODE_TYPE:-"first"}

    local usersetCdfAdminTask="${CDF_ADMIN_TASKS:-"${CLI_CDF_ADMIN_TASKS}"}"
    evaluateVariable "CDF_ADMIN_TASKS" "CLI_CDF_ADMIN_TASKS" "ns,no,pv,cr,pc"
    evaluateVariable "REGISTRY_ORGNAME" "CLI_REGISTRY_ORGNAME" "hpeswitom"
    evaluateVariable "SYSTEM_USER_ID" "CLI_SYSTEM_USER_ID" "1999"
    evaluateVariable "SYSTEM_GROUP_ID" "CLI_SYSTEM_GROUP_ID" "1999"
    evaluateVariable "CLOUD_PROVIDER" "CLI_CLOUD_PROVIDER" ""
    CLOUD_PROVIDER=$(echo ${CLOUD_PROVIDER}| tr '[:upper:]' '[:lower:]')
    evaluateVariable "K8S_PROVIDER" "CLI_K8S_PROVIDER" ""
    K8S_PROVIDER=$(echo ${K8S_PROVIDER}| tr '[:upper:]' '[:lower:]')
    evaluateVariable "SERVICE_CIDR" "CLI_SERVICE_CIDR" "172.17.0.0/16"
    evaluateVariable "ENABLE_FIPS" "CLI_ENABLE_FIPS" "false"
    evaluateVariable "LOGGING_VOL_SIZE" "CLI_LOGGING_VOL_SIZE" "5Gi"
    evaluateVariable "SET_FQDN_IN_INGRESS" "CLI_SET_FQDN_IN_INGRESS" "false"
    evaluateVariable "STORAGE_CLASS_MAPPINGS" "CLI_STORAGE_CLASS_MAPPINGS" ""
    evaluateVariable "SKIP_CHECK_ON_NODE_LOST" "CLI_SKIP_CHECK_ON_NODE_LOST" "true"
    evaluateVariable "SET_APPHUB_CLUSTER_ADMIN" "CLI_SET_APPHUB_CLUSTER_ADMIN" "false"
    evaluateVariable "PERSISTENCE_THREHOLD" "CLI_PERSISTENCE_THREHOLD" "128"

    initTLSVersionAndCiphers

    ## fluentd
    initFluentdParameters

    ## backup parms for byok
    evaluateVariable "BACKUP_STORAGE_API_CA" "CLI_BACKUP_STORAGE_API_CA" ""
    evaluateVariable "BACKUP_STORAGE_API_URL" "CLI_BACKUP_STORAGE_API_URL" ""
    evaluateVariable "BACKUP_STORAGE_BUCKET" "CLI_BACKUP_STORAGE_BUCKET" ""
    evaluateVariable "BACKUP_STORAGE_CREDENTIAL_FILE" "CLI_BACKUP_STORAGE_CREDENTIAL_FILE" ""
    evaluateVariable "BACKUP_STORAGE_SECRET" "CLI_BACKUP_STORAGE_SECRET" ""
    evaluateVariable "BACKUP_STORAGE_ACCOUNT" "CLI_BACKUP_STORAGE_ACCOUNT" ""
    evaluateVariable "BACKUP_RESOURCE_GROUP" "CLI_BACKUP_RESOURCE_GROUP" ""
    ##
    checkApphubSecurityWarning

    REGISTRY_ORGNAME=$(echo $REGISTRY_ORGNAME | sed 's/^\/\(.*\)/\1/' | sed 's/\(.*\)\/$/\1/')
    DEPLOYMENT_NAME=$(toLower "$DEPLOYMENT_NAME")

    if [ -z "$K8S_PROVIDER" ];then
        if [ -z "$CLOUD_PROVIDER" ];then
            write_log "fatal" "Abort installation because the '--k8s-provider' is not provided, allowed values: aws/azure/gcp/openshift/generic."
        else
            write_log "warn" "Note: --cloud-provider is deprecated. Use --k8s-provider instead."
            K8S_PROVIDER="$CLOUD_PROVIDER"
        fi
    else
        if [[ ! "$K8S_PROVIDER" =~ ^(aws|azure|gcp|openshift|generic)$ ]];then
            write_log "fatal" "Invalid value for '--k8s-provider', allowed values: aws/azure/gcp/openshift/generic.";
        fi
        CLOUD_PROVIDER="$K8S_PROVIDER"
    fi

    if [[ "$CLUSTER_WIDE_INGRESS" == "true" ]] && [[ -n "$LOADBALANCER_INFO" ]];then
        write_log "fatal" "Abort installation because don't allow setting --loadbalancer-info and --cluster-wide-ingress simultaneously."
    fi

    # LBINFO_FROM_LITERALS=""
    if [ -n "$LOADBALANCER_INFO" ];then
        local arr=$(echo "$LOADBALANCER_INFO"|sed "s/;/ /g")
        for kv in $arr;do
            local key=$(echo $kv|cut -d'=' -f1)
            local val=$(echo $kv|cut -d'=' -f2-)
            if [ "$key" == "LOADBALANCERID" ];then
                LOADBALANCER_ID=$val
            elif [ "$key" == "LOADBALANCERIP" ];then
                LOADBALANCER_IP=$val
            elif [ "$key" == "LOADBALANCERSOURCERANGES" ];then
                LOADBALANCERSOURCERANGES=$val
            elif [ "$key" == "aws-load-balancer-type" ];then
                AWS_LOADBALANCER_TYPE=$val
            elif [ "$key" == "aws-load-balancer-internal" ];then
                AWS_LOADBALANCER_INTERNAL=$val
            elif [ "$key" == "azure-load-balancer-internal" ];then
                AZURE_LOADBALANCER_INTERNAL=$val
            fi
            # LBINFO_FROM_LITERALS="$LBINFO_FROM_LITERALS --from-literal=$key=$val"
        done;
    fi

    checkSilentJsonFormat
    getCapabilitiesValue
    evaluateVariable "DEFAULT_STORAGE_CLASS" "CLI_DEFAULT_STORAGE_CLASS" ""
    if [[ "$CAPS_NFS_PROVISIONER" == "true" ]];then
        if [ -z "$NFS_PROV_SERVER" ] || [ -z "$NFS_PROV_FOLDER" ];then
            write_log "fatal" "Enabling NfsProvisioner requires specifying '--nfsprov-server' and '--nfsprov-folder'."
        fi
        if [ -n "$NFS_FOLDER" ] || [ -n "$NFS_SERVER" ];then
            write_log "fatal" "Options '--nfs-server' and '--nfs-folder' conflict with enabling capability NfsProvisioner."
        fi
        if [[ "$(echo $usersetCdfAdminTask|grep -o 'pv')" == "pv" ]];then
             write_log "fatal" "A value of 'pv' in '--cat|--cdf-admin-tasks' conflicts with capability NfsProvisioner=true. Remove 'pv' from '--cat|--cdf-admin-tasks' or disable the NfsProvisioner capability."
        fi

        DEFAULT_STORAGE_CLASS="${DEFAULT_STORAGE_CLASS:-"cdf-nfs"}"
    else
        if [ -n "$NFS_PROV_SERVER" ] || [ -n "$NFS_PROV_FOLDER" ];then
            write_log "fatal" "Options '--nfsprov-server' and '--nfsprov-folder' only supported for capability NfsProvisioner=true."
        fi
    fi
    DEFAULT_STORAGE_CLASS="${DEFAULT_STORAGE_CLASS:-"cdf-default"}"

    if [[ "$(echo $usersetCdfAdminTask|grep -o 'pv')" == "pv" ]];then
        if [ -z "$NFS_FOLDER" ] || [ -z "$NFS_SERVER" ];then
            write_log "fatal" "PV managed by CDF requires specifying '--nfs-server' and '--nfs-folder'."
        fi
    fi

    if [[ -z "$(echo $CDF_ADMIN_TASKS|grep -o 'pv')" ]];then
        # PV-ADMIN
        if [ -n "$NFS_FOLDER" ] || [ -n "$NFS_SERVER" ];then
            write_log "fatal" "A value of 'pv' in '--cat|--cdf-admin-tasks' conflicts with PV managed by $PRODUCT_SHORT_NAME. Remove '--nfs-server' and '--nfs-folder'."
        fi
    fi

    if [ -n "$NFS_FOLDER" ] && [ -z "$NFS_SERVER" ];then
        write_log "fatal" "Abort installation because the '--nfs-server' was not provided."
    fi
    if [ -n "$NFS_SERVER" ] && [ -z "$NFS_FOLDER" ];then
        write_log "fatal" "Abort installation because the '--nfs-folder' was not provided."
    fi

    if [[ ! "$CDF_ADMIN_TASKS" =~ (^|,)ns(,|$) ]] && [[ -z "$DEPLOYMENT_NAME" ]];then
        write_log "fatal" "Abort installation because the '-d, --deployment-name' was not provided in NS-ADMIN mode."
    fi

    if [ -z "$EXTERNAL_ACCESS_HOST" ];then
        write_log "fatal" "Abort installation because the '--external-access-host' was not provided."
    fi
    if [ -z "$CLI_DOCKER_REPOSITORY" ];then
        write_log "fatal" "Abort installation because the '--registry-url' was not provided."
    fi
    DOCKER_REPOSITORY=$CLI_DOCKER_REPOSITORY
    REGISTRY_CA=$CLI_REGISTRY_CA

    if [ -f "$REGISTRY_PASSWORD_FILE" ];then
        REGISTRY_PASSWORD="$(cat $REGISTRY_PASSWORD_FILE)"
        if [ -z "$REGISTRY_PASSWORD" ];then
            write_log "fatal" "Abort installation because file '$REGISTRY_PASSWORD_FILE' is empty."
        fi
    fi

    if [ -n "$DOCKER_REPOSITORY" ] && [ -z "$REGISTRY_USERNAME" -o -z "$REGISTRY_PASSWORD" ];then
        if [ "$CLI_SKIP_PRECHECK_WARNING" != "true" ]; then
            read -p "! Warning: Do you want to continue to pull the image anonymously? (yY/nN):" confirm
            if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                inputRegistryUsername
                inputRegistryPassword
            fi
        else
            if [ -n "$REGISTRY_USERNAME" ];then
                write_log "fatal" "Abort installation because the '--registry-password/--registry-password-file' was not provided."
            fi
            if [ -n "$REGISTRY_PASSWORD" ];then
                write_log "fatal" "Abort installation because the '--registry-username' was not provided."
            fi
        fi
    fi
    export REGISTRY_USERNAME
    export REGISTRY_PASSWORD

    # PLATFORM_VERSION, INTERNAL_VERSION
    getProductVersions

    # 1.PV_ADMIN, 2.CAPS_NFS_PROVISIONER=true
    if [ -z "$NFS_SERVER" ] && [ -z "$NFS_FOLDER" ];then
        # remove pv
        CDF_ADMIN_TASKS="$(echo $CDF_ADMIN_TASKS|sed -e 's/,/ /g' -e 's/pv/ /g'|xargs|tr ' ' ',')"
        if [ "$CLI_SKIP_PRECHECK_WARNING" != "true" ] && [ "$CAPS_NFS_PROVISIONER" == "false" ]; then
            read -p "! Warning: You did not set the parameters '--nfs-server' and '--nfs-folder' for the persistent volume 'itom-vol'. Do you want to continue the installation? If yes, the installer will use the persistent volume information provided by the cluster admin? (Y/N):" confirm
            if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                exit 1
            fi
        fi
    fi

    # In the future, byok may handle k8s (including on-premise) uniformly, and the value of $K8S_PROVIDER may be cdf|cdf-aws|cdf-azure
    if [[ "$K8S_PROVIDER" =~ ^(cdf|cdf-aws|cdf-azure)$ ]];then
        if [[ ! "$CDF_ADMIN_TASKS" =~ (^|,)cr(,|$) ]];then
            # add cr
            CDF_ADMIN_TASKS="$(echo "$CDF_ADMIN_TASKS,cr"|sed -e 's/,/ /g'|xargs|tr ' ' ',')"
            write_log "debug" "If k8s-provider is cdf, cdf-azure or cdf-aws then cr and pc values are always set in CDF_ADMIN_TASKS"
        fi
        if [[ ! "$CDF_ADMIN_TASKS" =~ (^|,)pc(,|$) ]];then
            # add pc
            CDF_ADMIN_TASKS="$(echo "$CDF_ADMIN_TASKS,pc"|sed -e 's/,/ /g'|xargs|tr ' ' ',')"
            write_log "debug" "If k8s-provider is cdf, cdf-azure or cdf-aws then cr and pc values are always set in CDF_ADMIN_TASKS"
        fi
    fi

    checkExternalAccessHost

    # EXTERNAL_ACCESS_PORT
    if [[ -z "$EXTERNAL_ACCESS_PORT" ]] && [[ -n "$SILENT_CONFIG_FILE" ]];then
        EXTERNAL_ACCESS_PORT="$(getValueFromConfig '.connection.externalAccessPort')"
    fi
    evaluateVariable "EXTERNAL_ACCESS_PORT" "CLI_EXTERNAL_ACCESS_PORT" ""

    local user_not_set_external_access_port=
    if [[ -z "$EXTERNAL_ACCESS_PORT" ]];then
        user_not_set_external_access_port=true
    fi

    EXTERNAL_ACCESS_PORT="${EXTERNAL_ACCESS_PORT:-"$DEFAULT_EXTERNAL_ACCESS_PORT"}"

    if [ "$CLI_SKIP_PRECHECK_WARNING" != "true" ];then
        if [[ "$K8S_PROVIDER" == "generic" ]] && [[ ! "$LOADBALANCER_INFO" =~ (^|;)LOADBALANCER=true(;|$) ]]; then
            if [ "$EXTERNAL_ACCESS_PORT" -lt "$SVC_DEFAULT_PORT_RANGE_LOW" ] || [ "$EXTERNAL_ACCESS_PORT" -gt "$SVC_DEFAULT_PORT_RANGE_HIGH" ]; then
                local current_external_access_port=$EXTERNAL_ACCESS_PORT
                if [[ "$user_not_set_external_access_port" == "true" ]];then
                    current_external_access_port="empty"
                fi
                echo "! Warning: By default, Kubernetes service node port range is between $SVC_DEFAULT_PORT_RANGE_LOW and $SVC_DEFAULT_PORT_RANGE_HIGH; now, external access port is $current_external_access_port; please make sure it's within the range of Kubernetes allowed service node port range; otherwise, may result in installation failure or logon management portal failure. You can set the external access port with command line parameter: --external-access-port."
                read -p "Do you want to continue the installation?  (Y/N):" confirm
                if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                    exit 1
                fi
            fi
        fi
    fi

    if [ "$CAPS_K8S_BACKUP" = "true" ]; then
        if [ -z "$BACKUP_STORAGE_BUCKET" ]; then
            write_log "fatal" "You have enabled k8s backup capability. Please set the backup storage bucket name."
        fi
        if [ -z "$BACKUP_STORAGE_CREDENTIAL_FILE" -a -z "$BACKUP_STORAGE_SECRET" ]; then
            write_log "fatal" "You have enabled k8s backup capability. Please set the backup storage credential file or pre-existing storage secret."
        fi
        if [ -n "$BACKUP_STORAGE_CREDENTIAL_FILE" -a -n "$BACKUP_STORAGE_SECRET" ]; then
            write_log "fatal" "Cannot set backup storage credential file and storage secret both. Either set backup storage credential file or backup storage secret."
        fi
        if [ "$K8S_PROVIDER" = "aws" ]; then
            AWS_BUCKET_REGION=$(aws configure get region 2>/dev/null)
            if [ "$?" != "0" -o -z "$AWS_BUCKET_REGION" ]; then
                write_log "fatal" "Bucket region is required for k8s backup capability. Failed to get bucket region on bastion node with command 'aws configure get region'; please configure the bastion node correctly."
            fi
        elif [ "$K8S_PROVIDER" = "azure" ]; then
            if [ -z "$BACKUP_STORAGE_ACCOUNT" -o -z "$BACKUP_RESOURCE_GROUP" ]; then
                write_log "fatal" "Resource group and storage account name are required for k8s backup capability. Please set both resource group and storage account name."
            fi
        elif [[ "$K8S_PROVIDER" =~ ^(openshift|generic)$ ]]; then
            if [ -z "$BACKUP_STORAGE_API_URL" ]; then
                write_log "fatal" "Storage api url is required for k8s backup capability on openshift/generic external k8s."
            elif [[ "$BACKUP_STORAGE_API_URL" =~ ^https:// ]]; then
                if [ -z "$BACKUP_STORAGE_API_CA" ]; then
                    write_log "fatal" "Storage api url is https protocol; must provide storage api ca certificate file for storage server validation."
                fi
            elif [[ "$BACKUP_STORAGE_API_URL" =~ ^http:// ]] && [ "$CLI_SKIP_PRECHECK_WARNING" != "true" ]; then
                echo "! Warning: You are trying to connect to the storage api in an unsecured way; strongly recommends to use 'https://' api url."
                read -p "Do you want to continue connecting to storage api with 'http://' url? (yY/nN):" confirm
                if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                    exit 1
                fi
            fi
        fi
    else
        if [ -n "$BACKUP_STORAGE_BUCKET" -o -n "$BACKUP_STORAGE_CREDENTIAL_FILE" -o -n "$BACKUP_STORAGE_SECRET" -o -n "$BACKUP_STORAGE_ACCOUNT" -o -n "$BACKUP_RESOURCE_GROUP" -o -n "$BACKUP_STORAGE_API_URL" ]; then
            write_log "fatal" "Backup storage settings are specified but K8S backup capability is NOT enabled. You can enable the K8s backup capability or unset the backup storage settings."
        fi
    fi

    initEndState
    validateConnectionObjectForSilentInstall

    # remove none
    CDF_ADMIN_TASKS="$(echo $CDF_ADMIN_TASKS|sed -e 's/,/ /g' -e 's/none/ /g'|xargs|tr ' ' ',')"

    warningSuiteDbOnHelm
}

initFluentdParameters(){
    export FLUENTD_LOG_RECEIVER_OUTPUT_FORMAT="csv"
    export FLUENTD_LOG_RECEIVER_OUTPUT_DELIMITER=","
    export FLUENTD_LOG_RECEIVER_ES_CLOUDID=""
    export FLUENTD_LOG_RECEIVER_URL=""
    export FLUENTD_LOG_RECEIVER_TYPE="file"
    export FLUENTD_LOG_RECEIVER_USER=""
    export FLUENTD_LOG_RECEIVER_PASSWORD=""
    export FLUENTD_LOG_RECEIVER_TOKEN=""
    export FLUENTD_LOG_RECEIVER_CA=""
    export FLUENTD_LOG_RECEIVER_CA_STRING=""
    export FLUENTD_LOG_CACHE_FOLDER=""
    export FLUENTD_LOG_CACHE_LIMIT_SIZE=""
}

initTLSVersionAndCiphers(){
    export USER_SET_TLS_MIN_VERSION=false
    export USER_SET_TLS_CIPHERS=false
    if [[ -n "$TLS_MIN_VERSION" ]] || [[ -n "$CLI_TLS_MIN_VERSION" ]];then
        export USER_SET_TLS_MIN_VERSION=true
    fi
    if [[ -n "$TLS_CIPHERS" ]] || [[ -n "$CLI_TLS_CIPHERS" ]];then
        export USER_SET_TLS_CIPHERS=true
    fi

    evaluateVariable "TLS_MIN_VERSION" "CLI_TLS_MIN_VERSION" "$DEFAULT_TLS_MIN_VERSION"
    evaluateVariable "TLS_CIPHERS" "CLI_TLS_CIPHERS" "$DEFAULT_TLS_CIPHERS"

    export SET_HELM_CHART_TLS_OPTIONS=""
    if [[ "$USER_SET_TLS_MIN_VERSION" == "true" ]];then
        SET_HELM_CHART_TLS_OPTIONS="--set global.tls.tlsMinVersion=$TLS_MIN_VERSION"
    fi
    if [[ "$USER_SET_TLS_CIPHERS" == "true" ]];then
        SET_HELM_CHART_TLS_OPTIONS="$SET_HELM_CHART_TLS_OPTIONS --set global.tls.tlsCiphers='{$TLS_CIPHERS}'"
    fi
}

initFlannelDirectrouting(){
    if [[ "$FLANNEL_BACKEND_TYPE" != "vxlan" ]];then
        export FLANNEL_DIRECTROUTING="${FLANNEL_DIRECTROUTING:-"true"}"
        return
    fi
    local use_set_flannel_type=false
    if [[ "$CLI_FLANNEL_BACKEND_TYPE" == "vxlan" ]];then
        use_set_flannel_type=true
    elif [[ -f "$CONFIGFILE" ]];then
        if grep -Pq '^ *FLANNEL_BACKEND_TYPE=.?vxlan.?' "$CONFIGFILE";then
            use_set_flannel_type=true
        fi
    fi

    if [[ "$use_set_flannel_type" == "true" ]];then
        export FLANNEL_DIRECTROUTING="${FLANNEL_DIRECTROUTING:-"false"}"
    else
        export FLANNEL_DIRECTROUTING="${FLANNEL_DIRECTROUTING:-"true"}"
    fi
}

initTmpFolderAndLogfile(){
  export CDF_INSTALL_RUNTIME_HOME="$HOME/.cdf/install"
  if [ ! -d "${CDF_INSTALL_RUNTIME_HOME}" ]; then
    mkdir -p "$CDF_INSTALL_RUNTIME_HOME" || write_log "fatal" "Failed to create install temporary folder ${CDF_INSTALL_RUNTIME_HOME}."
  fi
  # this func is used to init the tmp folder and the
  # parameters which dependences on the value of the tmp folder
  export NODE_TYPE=${NODE_TYPE:-"first"}
  if [ "$NODE_TYPE" = "first" ]; then
    if [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
      # source install.properties for first node here in order to
      # get the value of TMP_FOLDER
      CONFIGFILE=${CLI_CONFIGFILE:-"${CURRENTDIR}/install.properties"}
      if [ -f "$CONFIGFILE" ]; then
          checkInstallProperty
          source $CONFIGFILE
          if [ $? -ne 0 ]; then
              echo -e "The format of $CONFIGFILE is incorrect; the parameters should match key=\"value\" format. The value should be in quotation marks and no spaces around '=' character."
          fi
      fi
      export CONFIGFILE
    fi
    evaluateVariable "TMP_FOLDER" "CLI_TMP_FOLDER" "/tmp"
  else
      export TMP_FOLDER=${CLI_TMP_FOLDER}
  fi
  if [ ! -d ${TMP_FOLDER} ]; then
    mkdir -p ${TMP_FOLDER} || write_log "fatal" "Failed to create temporary folder ${TMP_FOLDER}."
  fi
  export LOG_FILE=${TMP_FOLDER}/${LOGFILENAME}
  export LOG_SUPPORT_MSG="Refer to $LOG_FILE file for detail information. If need, please contact system administrator or OpenText support."
  write_log "debug" "##FLAG_CDF_LOG_OWER:INSTALL##"
  local silentType="install"
  if [[ "$SILENT_LIFECYCLE" == "update" ]];then
    silentType="update"
    LOG_FILE=${TMP_FOLDER}/update.`date "+%Y%m%d%H%M%S"`.log
  fi
  if [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
    export readonly PREVIOUS_INSTALL_CONFIG="${CDF_INSTALL_RUNTIME_HOME}/.cdf_previous_${silentType}.properties"
  else
    export PREVIOUS_INSTALL_CONFIG="${CDF_INSTALL_RUNTIME_HOME}/.cdf_previous_${silentType}_$(cat ${CURRENTDIR}/version.txt).properties"
  fi
  export TMP_CLI_ARGS_BASE64_CONFIG="${CDF_INSTALL_RUNTIME_HOME}/.cdf_cli_arg_b64.conf"
}

checkFlannelIface(){
    local iface=$1
    local node=$2
    if [[ "$IPV6" == "true" ]] && [[ -n "$iface" ]];then
        # if FLANNEL_IFACE is IPv4 or IPv6, throw error
        if [[ "$(validateIPv4Formate "$iface")" == "true" ]] || [[ "$iface" =~ :.*: ]]; then
            write_log "fatal" "You have enabled IPv4/IPv6 dual-stack networking. The FLANNEL_IFACE of the current node($node) does not allow the use of IP address($iface), only the interface name is allowed."
        fi
    fi
}

init(){
    export readonly CDF_ALIAS="/etc/profile.d/itom-cdf-alias.sh"
    getMasterNodeTimeZone
    # ns: Namespace, no: node, pv: persistentVolumes, cr: clusterrole, pc: priorityclass
    export CDF_ADMIN_TASKS="ns,no,pv,cr,pc"
    export ETCDCTL_API=3
    export NODE_TYPE=${NODE_TYPE:-"first"}

    export DEPLOYMENT_NAME=$(toLower "$DEPLOYMENT_NAME")

    if [ "$NODE_TYPE" = "first" ]; then
        # source install.properties for first node
        CONFIGFILE=${CLI_CONFIGFILE:-"${CURRENTDIR}/install.properties"}
        if [ -f "$CONFIGFILE" ]; then
            checkInstallProperty
            source $CONFIGFILE
            if [ $? -ne 0 ]; then
                write_log "fatal" "The format of $CONFIGFILE is incorrect; the parameters should match key=\"value\" format. The value should be in quotation marks and no spaces around '=' character."
            fi
        fi
        export CONFIGFILE
        evaluateVariable "FEATURE_GATES" "CLI_FEATURE_GATES" ""

        checkFeatureGatesSilentVols

        if [ -n "$SILENT_CONFIG_FILE" ];then
            checkSilentJsonFormat
            checkSilentConfig
        fi

        # THIS_NODE
        local first_node_fqdn=$(hostname -f | tr '[:upper:]' '[:lower:]')
        if [ ${#first_node_fqdn} -gt 63 ]; then
            THIS_NODE=$(getLocalIP)
        else
            THIS_NODE=$first_node_fqdn
            if [ -z "$(echo $THIS_NODE | grep -P '(?=^.{1,254}$)(^(?>(?!\d+\.)[a-zA-Z0-9\-]{1,63}\.?)+(?:[a-zA-Z0-9\-]{1,63})$)')" ]; then
                write_log "fatal" "Get unqualified FQDN:\"$THIS_NODE\" with command 'hostname -f' on current node. $LOG_SUPPORT_MSG"
            fi
        fi
        export THIS_NODE

        # K8S_MASTER_IP
        if [ -z "$CLI_HA_VIRTUAL_IP" -a -z "$HA_VIRTUAL_IP" ]; then
            if [ -z "$CLI_LOAD_BALANCER_HOST" -a -z "$LOAD_BALANCER_HOST" ]; then
                K8S_MASTER_IP=${THIS_NODE}
            else
                K8S_MASTER_IP=${CLI_LOAD_BALANCER_HOST:-"$LOAD_BALANCER_HOST"}
            fi
        else
            K8S_MASTER_IP=${CLI_HA_VIRTUAL_IP:-"$HA_VIRTUAL_IP"}
            validateFqdnIPFormat "$K8S_MASTER_IP"
        fi
        export K8S_MASTER_IP

        # ETCD_ENDPOINT
        export ETCD_ENDPOINT="https://${K8S_MASTER_IP}:4001"
        export ETCD_LOCAL="https://${THIS_NODE}:4001"
        ###########################################################################
        # Bellow parametes get from CLI or install.properties, need default value #
        ###########################################################################
        evaluateVariable "IPV6" "CLI_IPV6" "false"
        evaluateVariable "IPV6_SERVICE_CIDR" "CLI_IPV6_SERVICE_CIDR" "fd00:1234:5678:1::/108"
        evaluateVariable "IPV6_POD_CIDR" "CLI_IPV6_POD_CIDR" "fd00:1234:5678::/64"
        evaluateVariable "IPV6_POD_CIDR_SUBNETLEN" "CLI_IPV6_POD_CIDR_SUBNETLEN" "80"
        evaluateVariable "CDF_NAMESPACE" "CLI_CDF_NAMESPACE" "$DEFAULT_CDF_NAMESPACE"
        evaluateVariable "DEPLOYMENT_LOG_LOCATION" "CLI_DEPLOYMENT_LOG_LOCATION" "/var/log/cdf-deployments"
        evaluateVariable "MASTER_API_SSL_PORT" "CLI_MASTER_API_SSL_PORT" "8443"
        evaluateVariable "REGISTRY_ORGNAME" "CLI_REGISTRY_ORGNAME" "hpeswitom"
        evaluateVariable "SYSTEM_USER_ID" "CLI_SYSTEM_USER_ID" "1999"
        evaluateVariable "SYSTEM_GROUP_ID" "CLI_SYSTEM_GROUP_ID" "1999"
        evaluateVariable "K8S_USER_ID" "CLI_K8S_USER_ID" "$SYSTEM_USER_ID"
        evaluateVariable "K8S_GROUP_ID" "CLI_K8S_GROUP_ID" "$SYSTEM_GROUP_ID"
        evaluateVariable "ETCD_USER_ID" "CLI_ETCD_USER_ID" "$SYSTEM_USER_ID"
        evaluateVariable "ETCD_GROUP_ID" "CLI_ETCD_GROUP_ID" "$SYSTEM_GROUP_ID"
        evaluateVariable "FLANNEL_BACKEND_TYPE" "CLI_FLANNEL_BACKEND_TYPE" "vxlan"
        evaluateVariable "SERVICE_CIDR" "CLI_SERVICE_CIDR" "172.17.0.0/16"
        evaluateVariable "FAIL_SWAP_ON" "CLI_FAIL_SWAP_ON" "true"
        evaluateVariable "ENABLE_FIPS" "CLI_ENABLE_FIPS" "false"
        evaluateVariable "ENABLE_K8S_AUDIT_LOG" "CLI_ENABLE_K8S_AUDIT_LOG" "false"
        evaluateVariable "AUTO_CONFIGURE_FIREWALL" "CLI_AUTO_CONFIGURE_FIREWALL" "true"
        evaluateVariable "SKIP_CHECK_ON_NODE_LOST" "CLI_SKIP_CHECK_ON_NODE_LOST" "true"
        evaluateVariable "SKIP_FAILED_WORKER_NODE" "CLI_SKIP_FAILED_WORKER_NODE" "true"
        evaluateVariable "CERTIFICATE_PERIOD" "CLI_CERTIFICATE_PERIOD" "365"
        evaluateVariable "LOGGING_VOL_SIZE" "CLI_LOGGING_VOL_SIZE" "5Gi"
        evaluateVariable "SET_FQDN_IN_INGRESS" "CLI_SET_FQDN_IN_INGRESS" "false"
        evaluateVariable "FIPS_ENTROPY_THRESHOLD" "CLI_FIPS_ENTROPY_THRESHOLD" "2000"
        evaluateVariable "KUBELET_PROTECT_KERNEL_DEFAULTS" "CLI_KUBELET_PROTECT_KERNEL_DEFAULTS" "false"
        evaluateVariable "STORAGE_CLASS_MAPPINGS" "CLI_STORAGE_CLASS_MAPPINGS" ""
        evaluateVariable "CAPABILITIES" "CLI_CAPABILITIES" ""
        evaluateVariable "SET_APPHUB_CLUSTER_ADMIN" "CLI_SET_APPHUB_CLUSTER_ADMIN" "false"
        evaluateVariable "PERSISTENCE_THREHOLD" "CLI_PERSISTENCE_THREHOLD" "128"
        evaluateVariable "APPHUB_HELM_VALUES" "CLI_APPHUB_HELM_VALUES" ""
        evaluateVariable "FLANNEL_PORT" "CLI_FLANNEL_PORT" "8472"

        initFlannelDirectrouting

        initTLSVersionAndCiphers

        checkApphubSecurityWarning

        # --cdf-home, deprecated --k8s-home
        evaluateVariable "K8S_HOME" "CLI_K8S_HOME" ""
        evaluateVariable "CDF_HOME" "CLI_CDF_HOME" ""

        if [[ -n "$K8S_HOME" ]] && [[ -z "$CDF_HOME" ]];then
            write_log "warn" "Note: --k8s-home is deprecated. Use --cdf-home instead."
            CDF_HOME="$K8S_HOME"
        fi

        CDF_HOME="${CDF_HOME:-"/opt/cdf"}"
        evaluateVariable "RUNTIME_CDFDATA_HOME" "CLI_RUNTIME_CDFDATA_HOME" "$CDF_HOME/data"

        # --k8s-provider, deprecated --cloud-provider
        evaluateVariable "CLOUD_PROVIDER" "CLI_CLOUD_PROVIDER" ""
        export CLOUD_PROVIDER=$(echo ${CLOUD_PROVIDER}| tr '[:upper:]' '[:lower:]')
        evaluateVariable "K8S_PROVIDER" "CLI_K8S_PROVIDER" ""
        export K8S_PROVIDER=$(echo ${K8S_PROVIDER}| tr '[:upper:]' '[:lower:]')

        if [[ -n "$K8S_PROVIDER" ]] && [[ -n "$CLOUD_PROVIDER" ]];then
            write_log "fatal" "Abort installation because '--k8s-provider' and '--cloud-provider' cannot be used at the same time."
        fi

        if [[ -n "$K8S_PROVIDER" ]] && [[ ! "$K8S_PROVIDER" =~ ^(cdf|cdf-aws|cdf-azure)$ ]];then
            write_log "fatal" "Invalid value for '--k8s-provider', allowed values: cdf/cdf-aws/cdf-azure";
        fi

        if [[ -n "$K8S_PROVIDER" ]] && [[ -z "$CLOUD_PROVIDER" ]];then
            [[ "$K8S_PROVIDER" == 'cdf-aws' ]] && CLOUD_PROVIDER='aws'
            [[ "$K8S_PROVIDER" == 'cdf-azure' ]] && CLOUD_PROVIDER='azure'
        fi

        if [[ -n "$CLOUD_PROVIDER" ]] && [[ -z "$K8S_PROVIDER" ]];then
            write_log "warn" "Note: --cloud-provider is deprecated. Use --k8s-provider instead."
            [[ "$CLOUD_PROVIDER" == 'aws' ]] && K8S_PROVIDER='cdf-aws'
            [[ "$CLOUD_PROVIDER" == 'azure' ]] && K8S_PROVIDER='cdf-azure'
        fi

        K8S_PROVIDER="${K8S_PROVIDER:-"cdf"}"
        CLOUD_PROVIDER="${CLOUD_PROVIDER:-"none"}"

        getCapabilitiesValue
        evaluateVariable "DEFAULT_STORAGE_CLASS" "CLI_DEFAULT_STORAGE_CLASS" ""
        if [[ "$CAPS_NFS_PROVISIONER" == "true" ]];then
            CDF_ADMIN_TASKS="ns,no,cr,pc"
            DEFAULT_STORAGE_CLASS="${DEFAULT_STORAGE_CLASS:-"cdf-nfs"}"
        fi
        DEFAULT_STORAGE_CLASS="${DEFAULT_STORAGE_CLASS:-"cdf-default"}"

        initEndState

        if [ ! -d ${TMP_FOLDER} ]; then
            exec_cmd "mkdir -p ${TMP_FOLDER}" || write_log "fatal" "Failed to create temporary folder ${TMP_FOLDER}. $LOG_SUPPORT_MSG"
        fi
        export REGISTRY_ORGNAME=$(echo $REGISTRY_ORGNAME | sed 's/^\/\(.*\)/\1/' | sed 's/\(.*\)\/$/\1/')
        export KUBELET_HOME=${RUNTIME_CDFDATA_HOME}
        # POD_CIDR
        if [ -z "$CLI_POD_CIDR" -a -z "$POD_CIDR" ]; then
            POD_CIDR="172.16.0.0/16"
            if [ -z "$CLI_POD_CIDR_SUBNETLEN" -a -z "$POD_CIDR_SUBNETLEN" ]; then
                POD_CIDR_SUBNETLEN=24
            else
                POD_CIDR_SUBNETLEN=${CLI_POD_CIDR_SUBNETLEN:-"$POD_CIDR_SUBNETLEN"}
            fi
        else
            POD_CIDR=${CLI_POD_CIDR:-"$POD_CIDR"}
            if [ -z "$CLI_POD_CIDR_SUBNETLEN" -a -z "$POD_CIDR_SUBNETLEN" ]; then
                local podprefixlen=$(echo $POD_CIDR | awk -F/ '{print $NF}')
                if [ $podprefixlen -lt 22 ]; then
                    POD_CIDR_SUBNETLEN=24
                else
                    POD_CIDR_SUBNETLEN=$(($podprefixlen + 3))
                fi
            else
                POD_CIDR_SUBNETLEN=${CLI_POD_CIDR_SUBNETLEN:-"$POD_CIDR_SUBNETLEN"}
            fi
        fi
        export POD_CIDR
        export POD_CIDR_SUBNETLEN

        # IPV6 params reset to empty
        if [ "$IPV6" == "false" ];then
            IPV6_POD_CIDR=
            IPV6_POD_CIDR_SUBNETLEN=
            IPV6_SERVICE_CIDR=
        fi

        # DNS_SVC_IP
        local svcipaddress=$(echo $SERVICE_CIDR | awk -F/ '{print $1}')
        local svcprefixlen=$(echo $SERVICE_CIDR | awk -F/ '{print $NF}')
        local svcnetmask=$(cidr2mask $svcprefixlen)
        local svcnetworkaddress=$(getIpInSameSubnet $svcipaddress $svcnetmask)
        if [ $svcprefixlen -le 24 ]; then
            DNS_SVC_IP="$(echo $svcnetworkaddress | cut -d. -f1-3).78"
        else
            DNS_SVC_IP="$(echo $svcnetworkaddress | cut -d. -f1-3).$(($(echo $svcnetworkaddress | cut -d. -f4)+2))"
        fi
        export DNS_SVC_IP

        # K8S_DEFAULT_SVC_IP
        export K8S_DEFAULT_SVC_IP="$(echo $svcnetworkaddress | cut -d. -f1-3).$(($(echo $svcnetworkaddress | cut -d. -f4)+1))"

        if [[ "$CAPS_NFS_PROVISIONER" == "true" ]];then
            if [ -z "$NFS_PROV_SERVER" ] && [ -z "$NFS_PROV_FOLDER" ];then
                write_log "fatal" "Enabling NfsProvisioner requires specifying '--nfsprov-server' and '--nfsprov-folder'."
            fi
            if [ -z "$NFS_PROV_SERVER" ];then
                write_log "fatal" "Enabling NfsProvisioner requires specifying '--nfsprov-server'."
            fi
            if [ -z "$NFS_PROV_FOLDER" ];then
                write_log "fatal" "Enabling NfsProvisioner requires specifying '--nfsprov-folder."
            fi
            if [ -n "$NFS_SERVER" ] || [ -n "$NFS_FOLDER" ];then
                write_log "fatal" "Options '--nfs-server' and '--nfs-folder' conflict with enabling capability NfsProvisioner."
            fi
        else
            if [ -z "$NFS_SERVER" ] && [ -z "$NFS_FOLDER" ];then
                write_log "fatal" "Abort installation because the '--nfs-server' and '--nfs-folder were not provided."
            fi
            if [ -z "$NFS_SERVER" ];then
                write_log "fatal" "Abort installation because the '--nfs-server' was not provided."
            fi
            if [ -z "$NFS_FOLDER" ];then
                write_log "fatal" "Abort installation because the '--nfs-folder' was not provided."
            fi
            if [ -n "$NFS_PROV_SERVER" ] || [ -n "$NFS_PROV_FOLDER" ];then
                write_log "fatal" "Options '--nfsprov-server' and '--nfsprov-folder' only supported for capability NfsProvisioner=true."
            fi
        fi
        export NFS_SERVER
        export NFS_FOLDER

        checkExternalAccessHost

        export EXTERNAL_ACCESS_HOST=${THIS_NODE}  #QCCR8B33729

        if [[ -z "$EXTERNAL_ACCESS_PORT" ]] && [[ -n "$SILENT_CONFIG_FILE" ]];then
            EXTERNAL_ACCESS_PORT="$(getValueFromConfig '.connection.externalAccessPort')"
        fi
        evaluateVariable "EXTERNAL_ACCESS_PORT" "CLI_EXTERNAL_ACCESS_PORT" "$DEFAULT_EXTERNAL_ACCESS_PORT"

        if [ -n "$CLI_DOCKER_REPOSITORY" ] && [ -z "$REGISTRY_USERNAME" -o -z "$REGISTRY_PASSWORD" ];then
            if [ "$CLI_SKIP_PRECHECK_WARNING" != "true" ]; then
                read -p "! Warning: Do you want to continue to pull the image anonymously? (Y/N):" confirm
                if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                    inputRegistryUsername
                    inputRegistryPassword
                fi
            else
                if [ -n "$REGISTRY_USERNAME" ];then
                    write_log "fatal" "Abort installation because the '--registry-password' is not provided."
                fi
                if [ -n "$REGISTRY_PASSWORD" ];then
                    write_log "fatal" "Abort installation because the '--registry-username' is not provided."
                fi
            fi
        fi
        export REGISTRY_USERNAME
        export REGISTRY_PASSWORD

        # DOCKER_REPOSITORY
        if [ -z "$DOCKER_REPOSITORY" -a -z "$CLI_DOCKER_REPOSITORY" ]; then
            DOCKER_REPOSITORY="localhost:5000"
        else
            DOCKER_REPOSITORY=${CLI_DOCKER_REPOSITORY:-"$DOCKER_REPOSITORY"}
        fi

        export DOCKER_REPOSITORY

        ALLOW_WORKLOAD_ON_MASTER="false"
        ########FOR_SILENT_INSTALL_START##########
        if [ -n "$SILENT_CONFIG_FILE" ]; then
            local try_deploy_suite=$($JQ -r 'has("capabilities")' $SILENT_CONFIG_FILE)
            if [ "$DOCKER_REPOSITORY" = "localhost:5000" ]; then
                if [ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ] && [ "$try_deploy_suite" == "true" ];then
                    if [ -z "$SILENT_IMAGE_FOLDER" ]; then
                        write_log "fatal" "When the 'capabilities' field exists in the configuration file, please provide the absolute path of image tar folder using -i option to upload the images of the suite."
                    fi
                    if [ -n "$SILENT_IMAGE_FOLDER" ];then
                        SILENT_IMAGE_FOLDER=$(echo "$SILENT_IMAGE_FOLDER" | tr -d ' ')
                        silent_imgfolder_opt="-i $SILENT_IMAGE_FOLDER"
                    fi
                fi
            else
                silent_ext_rep="--external-rep"
            fi
            if [ -n "$SILENT_TIMEOUT_MINUTES" ]; then
                silent_timeout_opt="-t $SILENT_TIMEOUT_MINUTES"
            fi
            #validate crt existing of master nodes
            local masterNum=$($JQ -r '.masterNodes | length' $SILENT_CONFIG_FILE)
            if [ $masterNum -eq 2 ]; then
                local n=0
                while [ $n -lt $masterNum ]; do
                    local privateKey=$($JQ -r ".masterNodes[$n].privateKey" $SILENT_CONFIG_FILE)
                    if [ -n "$privateKey" -a "$privateKey" != "null" ]; then
                        if [ ! -f "$privateKey" ]; then
                            write_log "fatal" "File not found: '$privateKey' which specified in $SILENT_CONFIG_FILE"
                        elif [ $(cat "$privateKey" | grep -i 'PRIVATE KEY' | wc -l) -eq 0 ]; then
                            write_log "fatal" "'$privateKey' is not a valid private key which specified in $SILENT_CONFIG_FILE"
                        fi
                    fi
                    n=$((n+1))
                done
            elif [ $masterNum -ne 0 -a $masterNum -ne 2 ]; then
                write_log "fatal" "The number of configured control plane nodes is incorrect: $masterNum. Leave 'masterNodes' empty for a single control plane node cluster or define 2 additional control plane nodes for a 3-control-plane node HA cluster."
            fi
            #validate crt existing of worker nodes
            local workerNum=$($JQ -r '.workerNodes | length' $SILENT_CONFIG_FILE)
            local n=0
            while [ $n -lt $workerNum ]; do
                local privateKey=$($JQ -r ".workerNodes[$n].privateKey" $SILENT_CONFIG_FILE)
                if [ -n "$privateKey" -a "$privateKey" != "null" ]; then
                    if [ ! -f "$privateKey" ]; then
                        write_log "fatal" "File not found: '$privateKey' which specified in $SILENT_CONFIG_FILE"
                    elif [ $(cat "$privateKey" | grep -i 'PRIVATE KEY' | wc -l) -eq 0 ]; then
                        write_log "fatal" "'$privateKey' is not a valid private key which specified in $SILENT_CONFIG_FILE"
                    fi
                fi
                n=$((n+1))
            done
            #validate certs of external host
            validateConnectionObjectForSilentInstall

            # check FLANNEL_IFACE for node2, node3, ...
            n=0
            while [ $n -lt $masterNum ]; do
                local flannelIface=$($JQ -r ".masterNodes[$n].flannelIface // empty" $SILENT_CONFIG_FILE)
                local nodeName=$($JQ -r ".masterNodes[$n].hostname // empty" $SILENT_CONFIG_FILE)
                checkFlannelIface "$flannelIface" "$nodeName"
                n=$((n+1))
            done

            n=0
            while [ $n -lt $workerNum ]; do
                local flannelIface=$($JQ -r ".workerNodes[$n].flannelIface // empty" $SILENT_CONFIG_FILE)
                local nodeName=$($JQ -r ".workerNodes[$n].hostname // empty" $SILENT_CONFIG_FILE)
                checkFlannelIface "$flannelIface" "$nodeName"
                n=$((n+1))
            done

            #get adminPassword if exist
            if [ -z "$SUPER_USERPWD" ]; then
                local hasAdminPwd=$($JQ 'has("adminPassword")' $SILENT_CONFIG_FILE)
                if [ "$hasAdminPwd" = "true" ]; then
                    local adminPassword=$($JQ -r '.adminPassword' $SILENT_CONFIG_FILE)
                    validatePwd "$adminPassword" && SUPER_USERPWD="$adminPassword" || write_log "fatal" "Password does not meet policy requirement. Please update the password and try again.\n$(printPasswordPolicy)"
                fi
            fi

            local allowWorkloadOnMaster=$($JQ -r '.allowWorkerOnMaster' $SILENT_CONFIG_FILE)
            if [[ "$allowWorkloadOnMaster" == "true" ]];then
                ALLOW_WORKLOAD_ON_MASTER="true"
            fi

            if [[ -n "$METADATA" ]];then
                # This parameter is only available in helm/bosun mode, suite mode is false.
                SKIP_FAILED_WORKER_NODE=false
            fi
        fi
        export ALLOW_WORKLOAD_ON_MASTER
        export SILENT_CONFIG_FILE
        export SUPER_USERPWD
        ########FOR_SILENT_INSTALL_END##########
        ###############################################################################
        # Below parameters get from CLI or install.properties, NOT need default value #
        ###############################################################################
        export CRT_HTTP_PROXY=$(echo ${CLI_CRT_HTTP_PROXY:-"$CRT_HTTP_PROXY"} | tr -d [:space:])
        export CRT_HTTPS_PROXY=$(echo ${CLI_CRT_HTTPS_PROXY:-"$CRT_HTTPS_PROXY"} | tr -d [:space:])
        export CRT_NO_PROXY=$(echo ${CLI_CRT_NO_PROXY:-"$CRT_NO_PROXY"} | tr -d [:space:])
        export FLANNEL_IFACE=${CLI_FLANNEL_IFACE:-"$FLANNEL_IFACE"}
        export AWS_REGION=${CLI_AWS_REGION:-"$AWS_REGION"}
        export AWS_EIP=${CLI_AWS_EIP:-"$AWS_EIP"}
        export HA_VIRTUAL_IP=${CLI_HA_VIRTUAL_IP:-"$HA_VIRTUAL_IP"}
        export LOAD_BALANCER_HOST=${CLI_LOAD_BALANCER_HOST:-"$LOAD_BALANCER_HOST"}
        export CDF_API_SERVER_SESSION_NAME=${CLI_SESSION_NAME:-"$CDF_API_SERVER_SESSION_NAME"}
        export SKIP_PRECHECK_WARNING=${CLI_SKIP_PRECHECK_WARNING:-"$SKIP_PRECHECK_WARNING"}
        export KUBE_DNS_HOSTS=${CLI_KUBE_DNS_HOSTS:-"$KUBE_DNS_HOSTS"}

        # check FLANNEL_IFACE for first node
        checkFlannelIface "$FLANNEL_IFACE" "$THIS_NODE"

        export FLUENTD_LOG_LOCATION="/var/log/cdf"
        initFluentdParameters

        if [ "$CLOUD_PROVIDER" = "aws" ]; then
            if [ -n "$HA_VIRTUAL_IP" ]; then
                if [ -z "$AWS_REGION" ]; then
                    write_log "fatal" "You have set CLOUD_PROVIDER and HA_VIRTUAL_IP; but AWS region is not defined. Please define the AWS region."
                fi
                if [ -z "$AWS_EIP" ]; then
                    write_log "fatal" "You have set multiple control plane nodes and HA_VIRTUAL_IP, but AWS_EIP is not defined. Please define the AWS_EIP."
                else
                    validateFqdnIPFormat "$AWS_EIP"
                fi
            fi
        else
            if [ "$CLOUD_PROVIDER" = "azure" -a ! -z "$HA_VIRTUAL_IP" -a ! -f "$AZURE_CONFIG_FILE" ]; then
                write_log "fatal" "The azure configuration file for keepalived \"$AZURE_CONFIG_FILE\" doesn't exist. Please provide the configuration file."
            fi
            if [ ! -z "$AWS_REGION" ]; then
                write_log "fatal" "You have set AWS_REGION. No cloud provider is entered. Please enter the cloud provider or unset AWS_REGION."
            fi
            if [ ! -z "$AWS_EIP" ]; then
                write_log "fatal" "You have set AWS_EIP. No cloud provider is entered. Please enter the cloud provider or unset AWS_EIP."
            fi
        fi
        export CLOUD_PROVIDER
        export HA_VIRTUAL_IP
        export AWS_REGION
        export AWS_EIP
        export AZURE_CONFIG_FILE

        # KEEPALIVED_NOPREEMPT
        if [ -z "$HA_VIRTUAL_IP" ]; then
            KEEPALIVED_NOPREEMPT=""
        else
            evaluateVariable "KEEPALIVED_NOPREEMPT" "CLI_KEEPALIVED_NOPREEMPT" "true"
        fi
        export KEEPALIVED_NOPREEMPT

        evaluateVariable "KEEPALIVED_VIRTUAL_ROUTER_ID" "CLI_KEEPALIVED_VIRTUAL_ROUTER_ID" "51"
        evaluateVariable "KEEPALIVED_ADVERT_INT" "CLI_KEEPALIVED_ADVERT_INT" "1"
        # REGISTRY_CA
        export REGISTRY_CA=$CLI_REGISTRY_CA
        # APPLICATION PROXY
        export APP_HTTP_PROXY=${CLI_APP_HTTP_PROXY:-"$APP_HTTP_PROXY"}
        export APP_HTTPS_PROXY=${CLI_APP_HTTPS_PROXY:-"$APP_HTTPS_PROXY"}
        export APP_NO_PROXY=${CLI_APP_NO_PROXY:-"$APP_NO_PROXY"}

        # remove none
        CDF_ADMIN_TASKS="$(echo $CDF_ADMIN_TASKS|sed -e 's/,/ /g' -e 's/none/ /g'|xargs|tr ' ' ',')"

    else  # extend master or worker node
        ###########################################################
        # Below parameters should get from CLI and cannot be null #
        ###########################################################
        export THIS_NODE=$(echo $NODE_HOST | tr '[:upper:]' '[:lower:]')
        export CDF_NAMESPACE=${CLI_CDF_NAMESPACE:-"$DEFAULT_CDF_NAMESPACE"}
        export CDF_HOME=${CLI_CDF_HOME}
        export RUNTIME_CDFDATA_HOME=${CLI_RUNTIME_CDFDATA_HOME}
        export KUBELET_HOME=${CLI_KUBELET_HOME}
        export K8S_MASTER_IP=${K8S_MASTER_IP}
        export MASTER_API_SSL_PORT=${CLI_MASTER_API_SSL_PORT}
        export ETCD_ENDPOINT=${CLI_ETCD_ENDPOINT}
        export REGISTRY_ORGNAME=${CLI_REGISTRY_ORGNAME}
        export SYSTEM_USER_ID=${CLI_SYSTEM_USER_ID}
        export SYSTEM_GROUP_ID=${CLI_SYSTEM_GROUP_ID}
        export K8S_USER_ID=${CLI_K8S_USER_ID:-"${SYSTEM_USER_ID}"}
        export K8S_GROUP_ID=${CLI_K8S_GROUP_ID:-"${SYSTEM_GROUP_ID}"}
        export ETCD_USER_ID=${CLI_ETCD_USER_ID:-"${SYSTEM_USER_ID}"}
        export ETCD_GROUP_ID=${CLI_ETCD_GROUP_ID:-"${SYSTEM_GROUP_ID}"}
        export FLANNEL_BACKEND_TYPE=${CLI_FLANNEL_BACKEND_TYPE}
        export FLANNEL_PORT=${CLI_FLANNEL_PORT}
        export FLANNEL_DIRECTROUTING=${CLI_FLANNEL_DIRECTROUTING}
        export CLOUD_PROVIDER=$(echo ${CLI_CLOUD_PROVIDER}| tr '[:upper:]' '[:lower:]')
        export POD_CIDR=${CLI_POD_CIDR}
        export POD_CIDR_SUBNETLEN=${CLI_POD_CIDR_SUBNETLEN}
        export SERVICE_CIDR=${CLI_SERVICE_CIDR}
        export IPV6=${CLI_IPV6}
        export IPV6_POD_CIDR=${CLI_IPV6_POD_CIDR}
        export IPV6_POD_CIDR_SUBNETLEN=${CLI_IPV6_POD_CIDR_SUBNETLEN}
        export IPV6_SERVICE_CIDR=${CLI_IPV6_SERVICE_CIDR}
        export DOCKER_REPOSITORY=${CLI_DOCKER_REPOSITORY}
        export DNS_SVC_IP=${CLI_DNS_SVC_IP}
        export FAIL_SWAP_ON=${CLI_FAIL_SWAP_ON}
        export ALL_CERTS_DIR=${CLI_ALL_CERTS_DIR:-"/tmp/all-certs"}
        export DEPLOYMENT_LOG_LOCATION=${CLI_DEPLOYMENT_LOG_LOCATION}
        export AUTO_CONFIGURE_FIREWALL=${CLI_AUTO_CONFIGURE_FIREWALL}
        #####################################################
        # Below parameters should get from CLI, can be null #
        #####################################################
        export AWS_REGION=${CLI_AWS_REGION}
        export AWS_EIP=${CLI_AWS_EIP}
        export CRT_HTTP_PROXY=$(echo ${CLI_CRT_HTTP_PROXY} | tr -d [:space:])
        export CRT_HTTPS_PROXY=$(echo ${CLI_CRT_HTTPS_PROXY} | tr -d [:space:])
        export CRT_NO_PROXY=$(echo ${CLI_CRT_NO_PROXY}| tr -d [:space:])
        export FLANNEL_IFACE=${CLI_FLANNEL_IFACE}
        export HA_VIRTUAL_IP=${CLI_HA_VIRTUAL_IP}
        export LOAD_BALANCER_HOST=${CLI_LOAD_BALANCER_HOST}
        export KEEPALIVED_NOPREEMPT=${CLI_KEEPALIVED_NOPREEMPT}
        export KEEPALIVED_VIRTUAL_ROUTER_ID=${CLI_KEEPALIVED_VIRTUAL_ROUTER_ID}
        export KEEPALIVED_ADVERT_INT=${CLI_KEEPALIVED_ADVERT_INT}
        export ENABLE_FIPS=${CLI_ENABLE_FIPS}
        export FIPS_ENTROPY_THRESHOLD=${CLI_FIPS_ENTROPY_THRESHOLD}
        export ENABLE_K8S_AUDIT_LOG=${CLI_ENABLE_K8S_AUDIT_LOG}
        export KUBELET_PROTECT_KERNEL_DEFAULTS=${CLI_KUBELET_PROTECT_KERNEL_DEFAULTS:-"false"}
        export TLS_MIN_VERSION=${CLI_TLS_MIN_VERSION}
        export TLS_CIPHERS=${CLI_TLS_CIPHERS}

        if [ "$NODE_TYPE" = "master" -a -z "$HA_VIRTUAL_IP" -a -z "$LOAD_BALANCER_HOST" ]; then
            write_log "fatal" "Cannot extend control plane nodes because parameter HA_VIRTUAL_IP or LOAD_BALANCER_HOST is not set when install first control plane node."
        fi
    fi
    # ETCD_SSL_CONN_PARAM
    ETCD3_SSL_CONN_PARAM=" --cacert=${CDF_HOME}/ssl/ca.crt --cert ${CDF_HOME}/ssl/common-etcd-client.crt --key ${CDF_HOME}/ssl/common-etcd-client.key "
    ETCD2_SSL_CONN_PARAM=" --ca-file=${CDF_HOME}/ssl/ca.crt --cert-file=${CDF_HOME}/ssl/common-etcd-client.crt --key-file=${CDF_HOME}/ssl/common-etcd-client.key "
    export ETCD2_SSL_CONN_PARAM
    export ETCD3_SSL_CONN_PARAM

    # evaluateVariable "DEVICE_TYPE" "CLI_DEVICE_TYPE" "overlayfs"
    # TODO: hard code
    export DEVICE_TYPE="overlayfs"

    # For containerd images import
    SNAPSHOTTER_TYPE="--snapshotter overlayfs"
    export SNAPSHOTTER_TYPE

    # LOCAL_IP
    export LOCAL_IP=$(getLocalIP)
    export NETWORK_ADDRESS=`getIpInSameSubnet ${LOCAL_IP}`
    # PLATFORM_VERSION,INTERNAL_VERSION
    getProductVersions

    export STEPS_FILE=$CDF_INSTALL_RUNTIME_HOME/.cdfInstallCompletedSteps.tmp

    export SELINUX_MODE=$(getenforce)

    warningSuiteDbOnHelm
}

checkDBConflicts(){
    if [[ -n "$SUITEDB_URL" ]] && [[ -f "$SILENT_CONFIG_FILE" ]];then
        # example: jdbc:postgresql://test.postgres.database.azure.com:5432/cdfapiserverdb
        local suite_db_type="$(echo "$SUITEDB_URL"|awk -F: '{print $2}')"
        local idm_db_type="$(getValueFromConfig '.database.type')"
        if [[ "$idm_db_type" == "extpostgres" ]];then
            idm_db_type="postgresql"
        elif [[ "$idm_db_type" == "extoracle" ]];then
            idm_db_type="oracle"
        fi

        if [[ "$idm_db_type" == "$suite_db_type" ]];then
            local idm_db_user="$(getValueFromConfig '.database.param.dbUser')"
            local idm_db_name="$(getValueFromConfig '.database.param.dbName')"
            local suite_db_name="${SUITEDB_URL##*/}"

            if [[ "$idm_db_type" == "postgresql" ]] && [[ -n "$idm_db_name" ]] && [[ "$idm_db_name" == "$suite_db_name" ]];then
                write_log "fatal" "Db connection parameter (--db-url) check failed: external cdfapiserver database is not allowed to be the same as $SILENT_CONFIG_FILE"
            fi
            if [[ "$idm_db_type" == "oracle" ]] && [[ -n "$idm_db_user" ]] && [[ "$idm_db_user" == "$SUITEDB_USER" ]];then
                write_log "fatal" "Db connection parameter (--db-user) check failed: external cdfapiserver database is not allowed to be the same as $SILENT_CONFIG_FILE"
            fi
        fi
    fi
}

checkCdfapiserverDbParameter(){
    if stepNotDone testCdfapiserverDbConnection; then
        if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ]] || [[ "$CAPS_CLUSTER_MANAGEMENT" == "true" ]];then
            if [ -z "$SUITEDB_USER" ];then
                #all db related opt are empty, using embeded db
                if [ -z "$SUITEDB_PASSWORD" ] && [ -z "$SUITEDB_URL" ] && [ -z "$SUITEDB_CERT" ];then
                    if [[ "$CLI_SKIP_PRECHECK_WARNING" != "true" ]];then
                        echo -e "You are setting up $PRODUCT_APP_NAME with embedded postgresql database which are used for deployment management. To use an external PostgreSQL/Oracle database, set the following parameters: --db-url, --db-user, --db-password, --db-crt."
                        read -p "Are you sure to continue(Y/N)?" confirm
                        if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                            exit 1
                        fi
                    fi
                else #SUITEDB_USER is empty, and any of the other option is not empty is invalid
                    write_log "fatal" "Db connection parameter check failed: cdf-apiserver database related username/password/connection-url are not allow to be empty. Please provide them with --db-user/--db-password/--db-url."
                fi
            else
                #if SUITEDB_USER is provided, SUITEDB_URL must not empty
                if [ -z "$SUITEDB_URL" ];then
                    write_log "fatal" "Db connection parameter check failed: database related username/password/connection-url are not allow to be empty. Please provide them with --db-user/--db-password/--db-url."
                else
                    #now, SUITEDB_USER is provided, SUITEDB_URL is not empty
                    if [ -z "$SUITEDB_PASSWORD" ];then
                        read -s -r -p "Warning: password for external db should not be empty! Please input db password: " SUITEDB_PASSWORD
                        echo ""
                    fi
                    #we had request user to provide the password, but user did not provide, then quit
                    if [ -z "$SUITEDB_PASSWORD" ];then
                        write_log "fatal" "Db connection parameter check failed: database related username/password/connection-url are not allow to be empty. Please provide them with --db-user/--db-password/--db-url."
                    fi
                    #now, SUITEDB_USER,SUITEDB_URL and SUITEDB_PASSWORD are provided, check SUITEDB_CERT next
                    if [ -z "$SUITEDB_CERT" ];then
                        if [ "$CLI_SKIP_PRECHECK_WARNING" != "true" ];then
                            echo -e "Warning: This capability is provided 'as is', please see product documentation for further information. Trying to connect to the database in an unsecured way, please provide the database certificate with --db-crt."
                            read -p "Are you sure to continue(Y/N)?" confirm
                            if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                                exit 1
                            fi
                        fi
                    else
                        if [ ! -f "$SUITEDB_CERT" ];then
                            write_log "fatal" "Db connection parameter check failed: certificate not exists. Please provide a correct certificate with --db-crt."
                        fi
                    fi

                    local fields=(${SUITEDB_URL//:/ })
                    SUITEDB_TYPE=${fields[1]}
                    ##  Does not support oracle external db in 2020.02 release ##
                    if [ "$SUITEDB_TYPE" != "oracle" ] && [ "$SUITEDB_TYPE" != "postgresql" ];then
                        write_log "fatal" "Db connection test failed: not supported database type \"$SUITEDB_TYPE\" in --db-url"
                    fi

                    if [ "$SUITEDB_TYPE" == "oracle" ] && [ -n "$SUITEDB_CERT" ];then
                        if [ "$CLI_SKIP_PRECHECK_WARNING" != "true" ];then
                            echo -e "Warning: You are trying to connect the Oracle database server over SSL. Please make sure the database connection information is correct, otherwise, the component cdf-apiserver cannot start as expected!"
                            read -p "Are you sure to continue(Y/N)?" confirm
                            if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                                exit 1
                            fi
                        fi
                    fi
                fi
            fi
        fi
    fi
}
testDbConnection(){
    local job_name=$1
    local tmp_secret=$2
    local image_name="${DOCKER_REPOSITORY}/${REGISTRY_ORGNAME}/${IMAGE_ITOM_TOOLS_BASE}"
    local tmp_file="${TMP_FOLDER}/.cdf_test_db_connection.tmp"
    > ${tmp_file}
    #delete the pod in case of rerun
    if [ $(exec_cmd "kubectl get pod ${job_name} -n ${CDF_NAMESPACE}" -p=false; echo $?) -eq 0 ] ; then
        exec_cmd "kubectl delete pod ${job_name} -n ${CDF_NAMESPACE} --force" -p=false
    fi

    echo "
apiVersion: v1
kind: Pod
metadata:
  name: ${job_name}
  namespace: ${CDF_NAMESPACE}
spec:
  securityContext:
    runAsUser: ${SYSTEM_USER_ID}
    runAsGroup: ${SYSTEM_GROUP_ID}
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: ${job_name}
    image: ${image_name}
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
    command: ['/base_apiserver/scripts/dbCheck.sh']
#    command: ['sh','-c','sleep 3600']
    envFrom:
      - secretRef:
          name: ${tmp_secret}
    resources:
      limits:
        cpu: \"1\"
        memory: 2Gi
      requests:
        cpu: 100m
        memory: 200Mi
    volumeMounts:
    - name: tmp
      mountPath: /tmp
  imagePullSecrets:
    - name: registrypullsecret
  restartPolicy: Never
  volumes:
  - name: tmp
    emptyDir: {}
" | kubectl create -f - 1>${tmp_file} 2>>${tmp_file}
    local reTryTimes=0
    local totalTimes=180
    local pod_status
    while (( $reTryTimes <  $totalTimes )); do
        reTryTimes=$(( $reTryTimes + 1 ))
        sleep 5
        #the stderr msg may interfere getting the right pod status
        pod_status=$(exec_cmd "kubectl get pods $job_name -n ${CDF_NAMESPACE} --no-headers 2>/dev/null | awk '{print \$3}'" -p=true)
        if [[ "$pod_status" == "Completed" ]] || [[ "$pod_status" == "Error" ]];then
            break
        fi
    done
    if [[ $reTryTimes -ge $totalTimes ]];then
        pod_status="Timeout"
    fi
    if [[ "$pod_status" == "Error" ]]; then
        kubectl logs $job_name -n ${CDF_NAMESPACE} >> $LOG_FILE
    fi
    echo "$pod_status"
}
testCdfapiserverDbConnection(){
    #parameter check is done in checkCdfapiserverDbParameter
    if [ "$NODE_TYPE" = "first" ] && [ -n "$SUITEDB_USER" ] && ( [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ]] || [[ "$CAPS_CLUSTER_MANAGEMENT" == "true" ]] );then
        write_log "step" "Test external cdf-apiserver database connection ..."
        if stepNotDone $FUNCNAME; then
            local reTryTimes=0
            local job_name="cdf-apiserverdb-check"
            local tmp_secret="tmp-cdfapiserverdb-check-secret"

            local sslEnabled
            local cert_content=""
            if [ -n "$SUITEDB_CERT" ];then
                sslEnabled="true"
            else
                sslEnabled="false"
            fi

            ##delete the secret in case of rerun
            if [ $(exec_cmd "kubectl get secret ${tmp_secret} -n ${CDF_NAMESPACE}" -p=false; echo $?) -eq 0 ] ; then
                exec_cmd "kubectl delete secret ${tmp_secret} -n ${CDF_NAMESPACE}" -p=false
            fi
            if [ -n "${SUITEDB_CERT}" ];then
                cert_content=$(cat ${SUITEDB_CERT})
            fi
            #when rerun install script will not run in checkCdfapiserverDbParameter, we need calculate SUITEDB_TYPE here
            local fields=(${SUITEDB_URL//:/ })
            SUITEDB_TYPE=${fields[1]}
            while true; do
                exec_cmd "kubectl create secret generic ${tmp_secret} -n ${CDF_NAMESPACE} --save-config \\
                    --from-literal=ENABLE_FIPS='${ENABLE_FIPS}' \\
                    --from-literal=TLS_MIN_VERSION='${TLS_MIN_VERSION}' \\
                    --from-literal=DB_SSL_ENABLE='${sslEnabled}' \\
                    --from-literal=DB_TYPE='${SUITEDB_TYPE}' \\
                    --from-literal=DB_USER='${SUITEDB_USER}' \\
                    --from-literal=DB_PASSWORD='$(echo "${SUITEDB_PASSWORD}"|sed -e "s/'/'\\\\''/g")' \\
                    --from-literal=DB_URL='${SUITEDB_URL}' \\
                    --from-literal=DB_CERT='${cert_content}' \\
                    --from-literal=DB_TLS_SKIP_HOSTNAME_VERIFICATION='${SUITEDB_TLS_SKIP_HOSTNAME_VERIFICATION}' \\
                    --from-literal=DB_PASSWORD_FLAG='password' \\
                    --from-literal=DB_TEST_CONNECTION='true' \\
                    --from-literal=DB_CHECK_EMPTY='true' " -m=false
                if [ $? -eq 0 ];then
                    break
                else
                    reTryTimes=$(( $reTryTimes + 1 ))
                    if [ $reTryTimes -eq $RETRY_TIMES ]; then
                        write_log "fatal" "Failed to create ${tmp_secret} while checking cdf-apiserver database. $LOG_SUPPORT_MSG" "failed"
                    else
                        write_log "debug" "Failed to create ${tmp_secret} while checking cdf-apiserver database. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                    fi
                    sleep $SLEEP_TIME
                fi
            done
            local pod_status
            pod_status=$(testDbConnection "$job_name" "$tmp_secret")
            if [[ $pod_status != "Completed" ]];then
                write_log "fatal" "Db connection test failed. $LOG_SUPPORT_MSG" "failed"
            fi
            #delete the tmp secret and pod if check pass
            if [ $(exec_cmd "kubectl get secret ${tmp_secret} -n ${CDF_NAMESPACE}" -p=false; echo $?) -eq 0 ] ; then
                exec_cmd "kubectl delete secret ${tmp_secret} -n ${CDF_NAMESPACE}" -p=false
            fi
            if [ $(exec_cmd "kubectl get pod ${job_name} -n ${CDF_NAMESPACE}" -p=false; echo $?) -eq 0 ] ; then
                exec_cmd "kubectl delete pod ${job_name} -n ${CDF_NAMESPACE} --force" -p=false
            fi
            setStepDone $FUNCNAME
            showStatus "ok"
        else
            showStatus "Already done"
        fi
    fi
}

warningSuiteDbOnHelm(){
    if [[ "$CAPS_SUITE_DEPLOYMENT_MANAGEMENT" == "false" ]];then
        if [ -n "$SUITEDB_URL" ] || [ -n "$SUITEDB_USER" ] || [ -n "$SUITEDB_PASSWORD" ] || [ -n "$SUITEDB_CERT" ] || [ -n "$SUITEDB_TLS_SKIP_HOSTNAME_VERIFICATION" ];then
            write_log "warn" "On helm base application, cdf-apiserver is no longer deployed, and parameters related to external cdf-apiserver database are no longer required."
        fi
        SUITEDB_URL=
        SUITEDB_USER=
        SUITEDB_PASSWORD=
        SUITEDB_CERT=
        SUITEDB_TLS_SKIP_HOSTNAME_VERIFICATION=
    fi
}

setStepDone(){
    exec_cmd "echo $1 >>$STEPS_FILE"
}

stepNotDone(){
    [ "$(grep $1 $STEPS_FILE 2>/dev/null|wc -l)" -eq 0 ] && return 0 || return 1
}

handleCertCheck(){
    local externalHostname=$1
    local rootCrt=$2
    local serverCrt=$3
    local serverKey=$4
    local checkOutput="$TMP_FOLDER/.cdf_certCheck_output"
    local rc=0
    exec_cmd "$CURRENTDIR/scripts/certCheck -host $externalHostname -ca $rootCrt -cert $serverCrt -key $serverKey -debug=true" -p=true &>"$checkOutput"
    rc=$?
    if [ "$rc" -ne 0 ];then
        # 31 : "WARNING: Root or server certificate is expired or soon"
        if [ "$rc" -eq 31 ] && grep -q 'WARNING:' $checkOutput 2>/dev/null ;then
            if [[ "$CLI_SKIP_PRECHECK_WARNING" != "true" ]];then
                read -p "! Warning: The ca or server certificate in $SILENT_CONFIG_FILE is about to expire, and the validity period is less than 30 days. Do you want to continue the installation? (yY/nN):" confirm
                if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                    exit 1
                fi
            else
                write_log "warn" "The ca or server certificate in $SILENT_CONFIG_FILE is about to expire, and the validity period is less than 30 days"
            fi
        else
            write_log "fatal" "Validate external host certificate(s) in $SILENT_CONFIG_FILE failure: $(cat $checkOutput|sed -r 's/^[0-9]{4}-[^ ]+ +//'|sed -r 's/WARNING: +//'). $LOG_SUPPORT_MSG"
        fi
    fi
    exec_cmd "$CURRENTDIR/scripts/certCheck -host $externalHostname -ca $rootCrt -cert $serverCrt -key $serverKey -debug=true -skip-warning" -p=true &>"$checkOutput"
    if [ $? -ne 0 ]; then
        write_log "fatal" "Validate external host certificate(s) failure: $(cat $checkOutput|sed -r 's/^[0-9]{4}-[^ ]+ +//'|sed -r 's/WARNING: +//'). $LOG_SUPPORT_MSG"
    fi
}

silentValidatePfx(){
    local connectionObject=$1
    local externalHostname=$2
    local hasRootCrt=$(echo $connectionObject | $JQ 'has("rootCrt")')
    local hasServerCrtFile=$(echo $connectionObject | $JQ 'has("serverCrt")')
    local serverCrtFile=
    if [[ "$hasServerCrtFile" == "true" ]];then
        serverCrtFile=$(echo $connectionObject | $JQ -r '.serverCrt')
    else
        # We Will deprecate serverCrtFile but still keep the backward compatibility.
        hasServerCrtFile=$(echo $connectionObject | $JQ 'has("serverCrtFile")')
        serverCrtFile=$(echo $connectionObject | $JQ -r '.serverCrtFile')
    fi
    local hasServerCrtPassword=$(echo $connectionObject | $JQ 'has("serverCrtPassword")')
    local hasServerKeyPassword=$(echo $connectionObject | $JQ 'has("serverKeyPassword")')
    local validateCertsResult=
    if [ "$hasRootCrt" = "true" -a "$hasServerCrtFile" = "true" -a "$hasServerCrtPassword" = "true" ]; then
        local rootCrt=$(echo $connectionObject | $JQ -r '.rootCrt')
        local serverCrtPassword=$(echo $connectionObject | $JQ '.serverCrtPassword')
        if [ ! -f "$rootCrt" ]; then
            write_log "fatal" "Certificate file of external host was not found: '$rootCrt'."
        elif [ ! -f "$serverCrtFile" ]; then
            write_log "fatal" "Certificate file of external host was not found: '$serverCrtFile'."
        elif [ "$serverCrtPassword" = 'null' ]; then
            write_log "fatal" "Value of serverCrtPassword cannot be null; please use \"\" to indicate empty password."
        else
            if [ "$hasServerKeyPassword" = "true" ]; then
                local serverKeyPassword=$(echo $connectionObject | $JQ '.serverKeyPassword')
                if [ "$serverKeyPassword" = '""' -o "$serverKeyPassword" = 'null' ]; then # server key password is null or "", no need to decrypt private key
                    local serverKeyPassword_option=""
                else
                    serverKeyPassword=$(echo $connectionObject | $JQ -r '.serverKeyPassword')
                    local serverKeyPassword_option="--p12-key-pass '$(echo -n "$serverKeyPassword"|base64 -w0)'"
                fi
            else #no serverKeyPassword field, no need to decrypt private key
                local serverKeyPassword_option=""
            fi
            if [ "$serverCrtPassword" != '""' ]; then serverCrtPassword=$(echo $connectionObject | $JQ -r '.serverCrtPassword'); fi
            exec_cmd "$CURRENTDIR/bin/cdfctl tool parse-cert --output-dir $CDF_INSTALL_RUNTIME_HOME --output-name pfx_server --p12 $serverCrtFile --p12-pass '$(echo -n "$serverCrtPassword"|base64 -w0)' $serverKeyPassword_option --base64-pw" -m=false
            if [ $? -ne 0 ] || [ ! -f $CDF_INSTALL_RUNTIME_HOME/pfx_server.crt -o ! -f $CDF_INSTALL_RUNTIME_HOME/pfx_server.key ]; then
                write_log "fatal" "Failed to export certificate and key from $serverCrtFile"
            else
                handleCertCheck "$externalHostname" "$rootCrt" "$CDF_INSTALL_RUNTIME_HOME/pfx_server.crt" "$CDF_INSTALL_RUNTIME_HOME/pfx_server.key"
            fi
        fi
    else
        local tips="Missing PKCS#12 certificate field for external host: '__field__'."
        if [ "$hasRootCrt" != "true" ]; then
            write_log "fatal" "${tips//__field__/rootCrt}"
        fi
        if [ "$hasServerCrtFile" != "true" ]; then
            write_log "fatal" "${tips//__field__/serverCrt}"
        fi
        if [ "$hasServerCrtPassword" != "true" ]; then
            write_log "fatal" "${tips//__field__/serverCrtPassword}"
        fi
    fi
}

silentValidatePem(){
    local connectionObject=$1
    local externalHostname=$2
    local hasServerKey=$(echo $connectionObject | $JQ 'has("serverKey")')
    local hasServerCrt=$(echo $connectionObject | $JQ 'has("serverCrt")')
    local hasRootCrt=$(echo $connectionObject | $JQ 'has("rootCrt")')
    local hasServerKeyPassword=$(echo $connectionObject | $JQ 'has("serverKeyPassword")')
    local num=0
    local validateCertsResult=
    for fileld in hasServerKey hasServerCrt hasRootCrt
    do
        eval local result=\$$fileld
        if [ "$result" = "true" ]; then
            num=$((num+1))
        fi
    done
    if [ $num -eq 3 ]; then
        local serverKey=$(echo $connectionObject | $JQ -r '.serverKey')
        local serverCrt=$(echo $connectionObject | $JQ -r '.serverCrt')
        local rootCrt=$(echo $connectionObject | $JQ -r '.rootCrt')
        if [ -f "$serverKey" -a -f "$serverCrt" -a -f "$rootCrt" ]; then
            if [ "$hasServerKeyPassword" = "true" ]; then
                local serverKeyPassword=$(echo $connectionObject | $JQ '.serverKeyPassword')
                if [ "$serverKeyPassword" = '""' -o "$serverKeyPassword" = 'null' ]; then # serverKeyPassword is null or "", no need to decrypt private key
                    handleCertCheck "$externalHostname" "$rootCrt" "$serverCrt" "$serverKey"
                else # need decrypt the private key with serverKeyPassword
                    local serverKeyPassword=$(echo $connectionObject | $JQ -r '.serverKeyPassword')
                    local keyName=$(basename $serverKey)
                    local dirName=$(dirname $serverKey)
                    local decryptedKeyName="decrypted_${keyName}"
                    if exec_cmd "openssl rsa -in $serverKey -passin '$(echo "pass:${serverKeyPassword}"|sed -e "s/'/'\\\\''/g")' -out ${dirName}/${decryptedKeyName}" -m=false; then
                        handleCertCheck "$externalHostname" "$rootCrt" "$serverCrt" "${dirName}/${decryptedKeyName}"
                        exec_cmd "$MV -f $serverKey ${serverKey}.original.$(md5sum $serverKey|cut -d ' ' -f1)" && exec_cmd "$MV -f ${dirName}/${decryptedKeyName} $serverKey"
                    else
                        write_log "fatal" "Failed to decrypt the private key '$serverKey' with the key password provided in 'serverKeyPassword' field."
                    fi
                fi
            else #no serverKeyPassword field, no need to decrypt private key
                handleCertCheck "$externalHostname" "$rootCrt" "$serverCrt" "$serverKey"
            fi
        else
            local tips="Certificate file of external host was not found: '__field__'. \nTo use self-signed certificates on external host, remove all three fields: 'serverKey', 'serverCrt' and 'rootCrt'. \nOr provide customized certificates of external host on those three fields."
            if [ ! -f "$serverKey" ]; then
                write_log "fatal" "${tips//__field__/serverKey}"
            fi
            if [ ! -f "$serverCrt" ]; then
                write_log "fatal" "${tips//__field__/serverCrt}"
            fi
            if [ ! -f "$rootCrt" ]; then
                write_log "fatal" "${tips//__field__/rootCrt}"
            fi
        fi
    elif [ $num -ne 0 ]; then
        local tips="Missing certificate field for external host: '__field__'. \nTo use self-signed certificates on external host, remove all three fields: 'serverKey', 'serverCrt' and 'rootCrt'. \nOr provide customized certificates of external host on those three fields."
        if [ "$hasServerKey" != "true" ]; then
            write_log "fatal" "${tips//__field__/serverKey}"
        fi
        if [ "$hasServerCrt" != "true" ]; then
            write_log "fatal" "${tips//__field__/serverCrt}"
        fi
        if [ "$hasRootCrt" != "true" ]; then
            write_log "fatal" "${tips//__field__/rootCrt}"
        fi
    fi
}

# validate the connection object in silent configuration file
validateConnectionObjectForSilentInstall(){
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]];then
        return
    fi
    # not silent install
    if [[ -z "$SILENT_CONFIG_FILE" ]];then
        return
    fi
    # silent install
    local connectionObject=$($JQ -r '.connection' $SILENT_CONFIG_FILE)
    local hasServerCrtType=$(echo $connectionObject | $JQ 'has("serverCrtType")')
    local externalHostname=$(echo $connectionObject | $JQ -r '.externalHostname')
    # check externalHostname, must provide
    if [ -z "$externalHostname" -o "$externalHostname" = "null" ]; then
        write_log "fatal" "Field 'externalHostname' is not defined in .connection object"
    fi
    # validate certificates if provided
    if [ "$hasServerCrtType" = "false" ]; then
        # not set "serverCrtType", validate them as PEM certificates
        silentValidatePem "$connectionObject" "$externalHostname"
    else
        local serverCrtType=$(echo $connectionObject | $JQ -r '.serverCrtType')
        if [ "$serverCrtType" = 'PKCS#1_PKCS#8' ]; then
            silentValidatePem "$connectionObject" "$externalHostname"
        elif [ "$serverCrtType" = 'PKCS#12' ]; then
            silentValidatePfx "$connectionObject" "$externalHostname"
        else
            write_log "fatal" "Invalid certificate type: '$serverCrtType' in '.connection.serverCrtType' field. Allowed values: 'PKCS#1_PKCS#8' or 'PKCS#12'"
        fi
    fi

    # The server.crt file is a full certificate chain including the server certificate, any intermediate CA certificates, and root CA in order.
    local hasRootCrt=$($JQ -r '.connection|has("rootCrt")' $SILENT_CONFIG_FILE)
    if [[ "$hasRootCrt" == "true" ]];then
        local rootCrt="$(getValueFromConfig '.connection.rootCrt')"
        local serverCrt=
        if [ "$serverCrtType" = 'PKCS#12' ]; then
            serverCrt="$CDF_INSTALL_RUNTIME_HOME/pfx_server.crt"
        else
            serverCrt="$(getValueFromConfig '.connection.serverCrt')"
        fi

        local caBeginLine="$(exec_cmd "grep -Pn '\-\s*BEGIN ' $rootCrt|cut -d ':' -f1" -p=true)"
        local caEndLine="$(exec_cmd "grep -Pn '\-\s*END ' $rootCrt|cut -d ':' -f1" -p=true)"
        if [[ -z "$caBeginLine" ]] || [[ -z "$caEndLine" ]];then
            write_log "fatal" "The certificate $rootCrt configured in $SILENT_CONFIG_FILE ('.connection.rootCrt') should start with '-----BEGIN CERTIFICATE-----' and end with '-----END CERTIFICATE-----'."
        fi

        local caContent="$(sed -n "$(( caBeginLine+1 )),$(( caEndLine-1 ))p" $rootCrt|sed ':a;N;$!ba;s/\n//g'|sed 's/ //g')"
        if [[ -z "$caContent" ]];then
            write_log "fatal" "The certificate $rootCrt configured in $SILENT_CONFIG_FILE ('.connection.rootCrt') should not be empty."
        fi

        exec_cmd "echo '[$caContent]'"

        local count="$(exec_cmd "grep -Pn '\-\s*BEGIN ' $serverCrt|wc -l" -p=true)"
        local countVerify="$(exec_cmd "grep -Pn '\-\s*END ' $serverCrt|wc -l" -p=true)"

        if [[ "$count" != "$countVerify" ]];then
            write_log "fatal" "Each certificate in $serverCrt configured in $SILENT_CONFIG_FILE should start with '-BEGIN CERTIFICATE' and end with 'END CERTIFICATE'."
        fi

        local isExistCaInCrt=false
        local beginLine=
        local endLine=
        local crtContent=

        for (( n=1; n<=count; n++ ));do
            beginLine="$(exec_cmd "grep -Pn '\-\s*BEGIN ' $serverCrt|cut -d ':' -f1|sed -n '${n}p'" -p=true)"
            endLine="$(exec_cmd "grep -Pn '\-\s*END ' $serverCrt|cut -d ':' -f1|sed -n '${n}p'" -p=true)"
            crtContent="$(sed -n "$(( beginLine+1 )),$(( endLine-1 ))p" $serverCrt|sed ':a;N;$!ba;s/\n//g'|sed 's/ //g')"
            exec_cmd "echo '[$crtContent]'"
            if [[ "$caContent" == "$crtContent" ]];then
                isExistCaInCrt=true
                break
            fi
        done

        if [[ "$isExistCaInCrt" == "true" ]];then
            write_log "debug" "The current server certificate '$serverCrt' already contains $rootCrt."
        else
            exec_cmd "$CP -f $serverCrt ${serverCrt}.original.$(md5sum $serverCrt|cut -d ' ' -f1)"
            exec_cmd "echo '' >> $serverCrt"
            exec_cmd "cat $rootCrt >> $serverCrt"
        fi
    fi
}

cmdPrecheckNode(){
    local node_type=$1
    local node_obj=$2
    local node_type_display=$3
    local options=""
    local skip_warning=
    for pk in $(echo "
                --flannel-iface:flannelIface
                --key:privateKey
                --key-pass:privateKeyPassword
                --node:hostname
                --node-pass:password
                --node-user:user
                --skip-warning:skipWarning
                "|xargs)
    do
        local option="${pk%:*}"
        local key="${pk#*:}"
        local has_key=$(echo "$node_obj"|$JQ "has(\"$key\")")
        local val=""
        if [[ "$has_key" == "true" ]];then
            val="$(echo "$node_obj"|$JQ -r ".${key} // empty")"
            if [[ -n "$val" ]];then
                if [[ "$key" == "password" ]] || [[ "$key" == "privateKeyPassword" ]];then
                    val="$(echo -n "$val"|base64 -w0)"
                fi
            fi
        fi
        if [[ "$has_key" != "true" ]] || [[ -z "$val" ]];then
            local gobal_key=""
            gobal_key="node$(echo "${key:0:1}"|tr '[:lower:]' '[:upper:]')${key:1}"
            val="$(cat $SILENT_CONFIG_FILE|$JQ -r ".${gobal_key} // empty")"
            if [[ -n "$val" ]];then
                if [[ "$key" == "password" ]] || [[ "$key" == "privateKeyPassword" ]];then
                    val="$(echo -n "$val"|base64 -w0)"
                fi
            fi
        fi
        if [[ "$option" == "--skip-warning" ]];then
            if [[ -z "$val" ]];then
                val=$CLI_SKIP_PRECHECK_WARNING
            fi
            if [[ -z "$val" ]];then
                val=false
            fi
            skip_warning=$val
        fi
        if [[ -n "$val" ]];then
            options="$options $option=\"$val\""
        fi
        if [[ "$key" == "hostname" ]];then
            local hostname="$val"
        fi
    done
    createCdfClusterHostOptions
    cd $CURRENTDIR
    local cdfctl_output="$TMP_FOLDER/cdf-precheck-node-$hostname.log"
    local cmd_output="$TMP_FOLDER/cdf-precheck-node-$hostname.output"
    exec_cmd "$RM -f $cdfctl_output"
    exec_cmd "$RM -f $cmd_output"
    local ext_opts=
    if [[ -n "$EXTERNAL_ACCESS_PORT" ]];then
        ext_opts=" --external-access-port $EXTERNAL_ACCESS_PORT "
    fi
    local rc=
    local warnings=
    local faileds=
    exec_cmd "${CDF_CLUSTER_HOST_OPTIONS//--from-literal=/} $CURRENTDIR/bin/cdfctl node precheck --node-type='$node_type' $options $ext_opts --base64-pw --run-phase=no_k8s --cmd-output=$cmd_output &>$cdfctl_output"
    rc=$?
    warnings="$(getPrecheckWarnings "$cmd_output")"
    faileds="$(getPrecheckFaileds "$cmd_output")"
    if [ "$rc" -ne 0 ]; then
        if [ -f "$cmd_output" ];then
            if [ "$faileds" -eq 0 ] && [ "$warnings" -gt 0 ];then
                showStatus "warning"
                userConfirmSkipPrecheckWarning "${node_name}" "$cmd_output" "$warnings" "$skip_warning"
            else
                showStatus "failed"
                exec_cmd "cat $cmd_output" -p true
                write_log "fatal" "$PRODUCT_SHORT_NAME installation pre-check ${node_type_display} node $node_name failed. Please correct the setting(s) according to the pre-check information then install again. $LOG_SUPPORT_MSG"
            fi
        else
            showStatus "failed"
            exec_cmd "cat $cdfctl_output"
            write_log "fatal" "Attempts to execute pre-check.sh on the remote node $node_name failed. $LOG_SUPPORT_MSG"
        fi
    else
        if [ "$warnings" -gt 0 ];then
            showStatus "warning"
            userConfirmSkipPrecheckWarning "${node_name}" "$cmd_output" "$warnings" "$skip_warning"
        else
            showStatus "ok"
        fi
    fi
    exec_cmd "cat $cdfctl_output"
    exec_cmd "cat $cmd_output"
    exec_cmd "$RM -f $cdfctl_output"
    exec_cmd "$RM -f $cmd_output"
}

precheckRemoteNode(){
    local node_name=$1
    local node_type=worker
    local node_type_display="worker"
    local obj=
    obj=$(cat $SILENT_CONFIG_FILE|$JQ -r ".workerNodes[]|select(.hostname==\"$node_name\")")
    if [[ -z "$obj" ]];then
        node_type=master
        node_type_display="control plane"
        obj=$(cat $SILENT_CONFIG_FILE|$JQ -r ".masterNodes[]|select(.hostname==\"$node_name\")")
    fi
    if [[ -z "$obj" ]];then
        write_log "fatal" "No such node ($node_name) in $SILENT_CONFIG_FILE."
    fi
    write_log "step" "Pre-checking $node_type_display node: ${node_name} ..."
    cmdPrecheckNode "$node_type" "$obj" "$node_type_display"
}

checkConfigNodesChanged(){
    if [[ -n "$PREVIOUS_INSTALL_CONFIG" ]] && [[ -f "$PREVIOUS_INSTALL_CONFIG" ]];then
        # If full pre-check has already been run, the pre-check before installation will not be run.
        if ! stepNotDone "@precheckAllNodes"; then
            return 1
        fi
        local masterNodes_sha=$(cat $SILENT_CONFIG_FILE|$JQ  -r '.masterNodes[]|with_entries(.key=.key|.value=.value)'|sha256sum |awk '{print $1}')
        local workerNodes_sha=$(cat $SILENT_CONFIG_FILE|$JQ  -r '.workerNodes[]|with_entries(.key=.key|.value=.value)'|sha256sum |awk '{print $1}')
        source $PREVIOUS_INSTALL_CONFIG
        exec_cmd "echo \"_masterNodes_sha=$masterNodes_sha\"                 >> $PREVIOUS_INSTALL_CONFIG"
        exec_cmd "echo \"_workerNodes_sha=$workerNodes_sha\"                 >> $PREVIOUS_INSTALL_CONFIG"
        if [[ "$masterNodes_sha" == "$_masterNodes_sha" ]] && [[ "$workerNodes_sha" == "$_workerNodes_sha" ]];then
            return 1
        fi
    fi
    return 0
}

precheckOtherNodes(){
    local master_nodes="$(cat $SILENT_CONFIG_FILE|$JQ -r '.masterNodes[].hostname'|xargs)"
    local worker_nodes="$(cat $SILENT_CONFIG_FILE|$JQ -r '.workerNodes[].hostname'|xargs)"
    if checkConfigNodesChanged;then
        local nodes="${master_nodes} ${worker_nodes}"
        for node_name in ${nodes};do
            precheckRemoteNode "$node_name"
        done
        [[ -f "$STEPS_FILE" ]] && setStepDone "@precheckOtherNodes"
    else
        for node_name in ${master_nodes};do
            write_log "step" "Pre-checking control plane node: ${node_name} ..."
            showStatus "Already done"
        done
        for node_name in ${worker_nodes};do
            write_log "step" "Pre-checking worker node: ${node_name} ..."
            showStatus "Already done"
        done
    fi
}

checkLBConnection(){
    if [[ -n "$LOAD_BALANCER_HOST" ]];then
        for port in $MASTER_API_SSL_PORT 4001;do
            if ! exec_cmd "timeout 5 bash -c \"echo > /dev/tcp/${LOAD_BALANCER_HOST}/${port}\"";then
                write_log "fatal" "Failed to connect to $LOAD_BALANCER_HOST port $port, please make sure the '--load-balancer-host|LOAD_BALANCER_HOST' configuration is correct. $LOG_SUPPORT_MSG"
            fi
        done
    fi
}

cleanUserConfirmFlag(){
    exec_cmd "$RM -f $CDF_INSTALL_RUNTIME_HOME/user_confirm_skip_precheck_warning_*"
}

getPrecheckWarnings(){
    local precheck_output=$1
    if [ ! -f "$precheck_output" ];then
        echo "0"
        return
    fi
    local warnings="$(grep -oc '\[ WARNING \]' $precheck_output 2>/dev/null)"
    echo "${warnings:-"0"}"
}

getPrecheckFaileds(){
    local precheck_output=$1
    if [ ! -f "$precheck_output" ];then
        echo "0"
        return
    fi
    local faileds="$(grep -oc '\[ FAILED \]' $precheck_output 2>/dev/null)"
    echo "${faileds:-"0"}"
}

userConfirmSkipPrecheckWarning(){
    local nodename=$1
    local precheck_output=$2
    local warnings=$3
    local skip_warning=$4
    exec_cmd "$RM -f $CDF_INSTALL_RUNTIME_HOME/user_confirm_skip_precheck_warning_$nodename"
    exec_cmd "cat $precheck_output" -p true
    if [ "$SKIP_PRECHECK_WARNING" = "true" ] || [ "$skip_warning" = "true" ]; then
        return
    fi
    read -p "! Warning: Got $warnings warning(s) during precheck of $nodename; do you want to skip and continue (Y/N):" confirm
    if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
        write_log "fatal" "$PRODUCT_SHORT_NAME installation pre-check node ${nodename} failed. Please correct the setting(s) according to the pre-check information then install again."
    fi
    exec_cmd "echo '$confirm' > $CDF_INSTALL_RUNTIME_HOME/user_confirm_skip_precheck_warning_$nodename"
}

precheckAll(){
    if [ "$NODE_TYPE" = "first" ]; then
      write_log "info" "Start node pre-check before $PRODUCT_SHORT_NAME installation"
      write_log "step" "Pre-checking control plane node: ${THIS_NODE}"
      if [ ! -f "$STEPS_FILE" ]; then
        # write_log "info" "Pre-checking control plane node: ${THIS_NODE} ..."
        if [ ! -z "$HA_VIRTUAL_IP" ]; then
            local vip_option="--virtual-ip ${HA_VIRTUAL_IP}"
        fi
        if [ ! -z "$LOAD_BALANCER_HOST" ]; then
            local load_balancer_option="--load-balancer-host ${LOAD_BALANCER_HOST}"
        fi
        if [[ -z "$HA_VIRTUAL_IP" ]] && [[ -z "$LOAD_BALANCER_HOST" ]];then
            local cpu_option="--cpu 4"
        fi
        if [ ! -z "$FLANNEL_IFACE" ]; then
            local iface_option="--flannel-iface ${FLANNEL_IFACE}"
        fi
        if [ ! -z "$FLANNEL_BACKEND_TYPE" ]; then
            local flannel_backend_option="--flannel-backend-type ${FLANNEL_BACKEND_TYPE}"
        fi
        if [ "$SKIP_PRECHECK_WARNING" = "true" ]; then
            local skip_warn_option="--skip-warning"
        fi
        if [ ! -z "$CLOUD_PROVIDER" ]; then
            local k8s_provider="--k8s-provider $CLOUD_PROVIDER"
        fi
        #CR#1631656 - need to adjust the disk free requirement if nfs server is on first cp node and image registry is local.
        if [ "$(nfsServerIsThisNode)" = "true" -a "$DOCKER_REPOSITORY" = "localhost:5000" ]; then
            local nfs_option="--nfs-folder ${NFS_FOLDER:-$NFS_PROV_FOLDER}"
        fi
        [ ! -z "$FLUENTD_LOG_RECEIVER_URL" ] && local log_receiver_url="--fluentd-log-receiver-url $FLUENTD_LOG_RECEIVER_URL"
        [ ! -z "$FLUENTD_LOG_RECEIVER_CA" ] && local log_receiver_ca="--fluentd-log-receiver-ca $FLUENTD_LOG_RECEIVER_CA"
        [ ! -z "$FLUENTD_LOG_RECEIVER_USER" ] && local log_receiver_user="--fluentd-log-receiver-user $FLUENTD_LOG_RECEIVER_USER"
        [ ! -z "$FLUENTD_LOG_RECEIVER_TYPE" ] && local log_receiver_type="--fluentd-log-receiver-type $FLUENTD_LOG_RECEIVER_TYPE"
        if [ ! -z "$FLUENTD_LOG_RECEIVER_URL" -a ! -z "$FLUENTD_LOG_RECEIVER_USER" ]; then
            if [ -z "$FLUENTD_LOG_RECEIVER_PASSWORD" ]; then
                write_log "info" "The user for fluentd log receiver connection: $FLUENTD_LOG_RECEIVER_USER"
                read -s -r -p "Please input the password of this user: " FLUENTD_LOG_RECEIVER_PASSWORD
                echo ""
                [ -z "$FLUENTD_LOG_RECEIVER_PASSWORD" ] && write_log "fatal" "The password for fluentd log receiver connection is empty."
            fi
            local log_receiver_pwd="--fluentd-log-receiver-pwd $FLUENTD_LOG_RECEIVER_PASSWORD"
        fi
        if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ]];then
            local deploymentMode="suite"
        else
            local deploymentMode="helm"
        fi
        if [ "$IPV6" == "true" ];then
            local ipv6_options="--ipv6 true --ipv6-service-cidr $IPV6_SERVICE_CIDR --ipv6-pod-cidr $IPV6_POD_CIDR --ipv6-pod-cidr-subnetlen $IPV6_POD_CIDR_SUBNETLEN"
        fi
        local rc=
        local warnings=
        local faileds=
        local precheck_output="$TMP_FOLDER/cdf-precheck-node-${THIS_NODE}.output"
        local precheck_log="$TMP_FOLDER/cdf-precheck-node-${THIS_NODE}.log"
        exec_cmd "$RM -f ${precheck_log}"
        cleanUserConfirmFlag
        # write_log "info" "Pre-checking first control plane node: ${THIS_NODE}"
        timeout 8m $CURRENTDIR/scripts/pre-check.sh --integrated --no-verbose \
                                         --node-type "first" --tmp "$TMP_FOLDER" --node-host "${THIS_NODE}" \
                                         --cdf-home "$CDF_HOME" \
                                         --api-port "$MASTER_API_SSL_PORT" \
                                         --uid "$SYSTEM_USER_ID" \
                                         --gid "$SYSTEM_GROUP_ID" \
                                         --pod-cidr "$POD_CIDR" \
                                         --pod-cidr-subnetlen ${POD_CIDR_SUBNETLEN} \
                                         --service-cidr "$SERVICE_CIDR" \
                                         --fail-swap-on "$FAIL_SWAP_ON" \
                                         --runtime-home "$RUNTIME_CDFDATA_HOME" \
                                         --auto-configure-firewall "$AUTO_CONFIGURE_FIREWALL"\
                                         --device-type "$DEVICE_TYPE" \
                                         --enable-fips "$ENABLE_FIPS" \
                                         --fips-entropy-threshold "$FIPS_ENTROPY_THRESHOLD" \
                                         --external-access-port "$EXTERNAL_ACCESS_PORT" \
                                         --tls-min-version "$TLS_MIN_VERSION" \
                                         ${vip_option} ${load_balancer_option} ${flannel_backend_option} ${cpu_option} ${ipv6_options} ${nfs_option}\
                                         ${iface_option} ${skip_warn_option} ${k8s_provider} ${log_receiver_url} \
                                         ${log_receiver_ca} ${log_receiver_user} ${log_receiver_pwd} ${log_receiver_type} -l $precheck_log &>$precheck_output
        rc=$?
        warnings="$(getPrecheckWarnings "$precheck_output")"
        faileds="$(getPrecheckFaileds "$precheck_output")"
        if [ "$rc" -gt 0 ]; then
            if [ "$faileds" -eq 0 ] && [ "$warnings" -gt 0 ];then
                showStatus "warning"
                userConfirmSkipPrecheckWarning "${THIS_NODE}" "$precheck_output" "$warnings"
            else
                showStatus "failed"
                if [ -f "$precheck_output" ];then
                    exec_cmd "cat $precheck_output" -p true
                fi
                write_log "fatal" "$PRODUCT_SHORT_NAME installation pre-check current node ${THIS_NODE} failed. Please correct the setting(s) according to the pre-check information then install again."
            fi
        else
            # exec_cmd "cat $precheck_log"
            if [ "$warnings" -gt 0 ];then
                showStatus "warning"
                exec_cmd "cat $precheck_output" -p true
            else
                showStatus "ok"
            fi
        fi
      else
        # write_log "step" "Pre-checking control plane node: ${THIS_NODE} ..."
        showStatus "Already done"
      fi
      if [[ -n "$SILENT_CONFIG_FILE" ]] && [[ -f "$SILENT_CONFIG_FILE" ]];then
        precheckOtherNodes
      fi
    fi
}

printPasswordPolicy(){
    write_log "info" "Create password for the administrator.
*********************************************************************
Passwords must meet the following requirements:
1) Minimum Length - 8 characters
2) Maximum length - 20 characters
3) Must contain all the following types of characters:
 . numbers (0-9)
 . lowercase letters (a-z)
 . uppercase letters (A-Z)
 . special characters, not including the space character (!,@,#,etc.)
*********************************************************************"
}

createSuperUser(){
    if [ -z "$SUPER_USERPWD" ]; then
        printPasswordPolicy
        read -s -r -p "Administrator password: " user_pwd_1
        while [ $(validatePwd "$user_pwd_1"; echo $?) -ne 0 ]; do
            echo -e "\nSorry, password does not meet strength policy."
            read -s -r -p "Administrator password: " user_pwd_1
        done
        echo ""
        read -s -r -p "Confirm the password: " user_pwd_2
        while [ "$user_pwd_1" != "$user_pwd_2" ];do
            echo -e "\nSorry, passwords does not match."
            read -s -r -p "Administrator password: " user_pwd_1
            while [ $(validatePwd "$user_pwd_1"; echo $?) -ne 0 ]; do
                echo -e "\nSorry, password does not meet strength policy."
                read -s -r -p "Administrator password: " user_pwd_1
            done
            echo ""
            read -s -r -p "Confirm the password: " user_pwd_2
        done
        echo ""
        SUPER_USERPWD=$user_pwd_1
    fi
}

validateRegistryPwd(){
    local pwd="$1"
    if [ "$pwd" != "" ]; then
        return 0
    else
        return 1
    fi
}

inputRegistryPassword(){
    if [ -z "$REGISTRY_PASSWORD" ]; then
        read -s -r -p "Registry password:   > " user_pwd_1
        while [ $(validateRegistryPwd "$user_pwd_1"; echo $?) -ne 0 ]; do
            echo -e "\nSorry, password cannot be empty."
            read -s -r -p "Registry password:   > " user_pwd_1
        done
        echo ""
        REGISTRY_PASSWORD=$user_pwd_1
    fi
}

uncompressMetadata(){
    local level=
    # if first node, uncompress metadata package to destination.
    if [ "$NODE_TYPE" = "first" ] && [ -n "$METADATA" ]; then
        exec_cmd "mkdir -p ${CDF_HOME}/cfg/suite-metadata/package && chmod 755 ${CDF_HOME}/cfg/suite-metadata"
        level=$(exec_cmd "$TAR -tf ${METADATA} 2>/dev/null | awk -F/ '/suiteinfo.json/ {print NF}'" -p=true)
        if [ ! -z "$level" ]; then
            local metadata_dir="${CDF_HOME}/cfg/suite-metadata"
            exec_cmd "$TAR -zxf ${METADATA} --strip-components $(($level-1)) -C ${metadata_dir}"
            if [ $? -ne 0 ]; then
                write_log "fatal" "The metadata package $METADATA does not have the correct internal structure. $MF_SUPPORT_MSG" "failed"
            else
                if [ $($JQ 'has("suiteInfoList")' ${metadata_dir}/suiteinfo.json) = "false" ]; then
                    exec_cmd "$MV -f ${metadata_dir}/suiteinfo.json ${metadata_dir}/suiteinfo.json.ori"
                    exec_cmd "cat ${metadata_dir}/suiteinfo.json.ori | $JQ '{suiteInfoList: [ .]}' > ${metadata_dir}/suiteinfo.json"
                    exec_cmd "$RM -f ${metadata_dir}/suiteinfo.json.ori"
                fi
            fi
            exec_cmd "$CP -f ${METADATA} ${metadata_dir}/package/metadata.tar.gz"
            exec_cmd "chmod 755 \$(find ${metadata_dir} -type d) && chmod 644 \$(find ${metadata_dir} -type f)"
        else
            write_log "fatal" "The metadata package $METADATA does not have the correct internal structure. $MF_SUPPORT_MSG" "failed"
        fi
    fi
}

createEnvShell(){
    #set env.sh for shell scripts
    exec_cmd "mkdir -p ${CDF_HOME}/bin"

    echo "
#!/bin/bash
source $CDF_PROFILE
export THIS_NODE=${THIS_NODE}
export K8S_MASTER_IP=${K8S_MASTER_IP}
export no_proxy=\${K8S_MASTER_IP},\${THIS_NODE},127.0.0.1,\$no_proxy
export SUITE_REGISTRY=${DOCKER_REPOSITORY}
export REGISTRY_ORGNAME=${REGISTRY_ORGNAME}
export K8S_MASTER_ENDPOINT=https://\${K8S_MASTER_IP}:${MASTER_API_SSL_PORT}
    ">> ${CDF_HOME}/bin/env.sh

    exec_cmd "chmod 700 ${CDF_HOME}/bin/env.sh"
    source ${CDF_HOME}/bin/env.sh
}

switchLogPath(){
    # switch log path
    local old_log_file=$LOG_FILE
    local new_log_file=${CDF_HOME}/log/$COMPONENTNAME/$LOGFILENAME
    [[ "$old_log_file" == "$new_log_file" ]] && return

    exec_cmd "/bin/mkdir -p $(dirname $new_log_file)"
    if [ $? -ne 0 ]; then
        write_log "fatal" "Failed to create $(dirname $new_log_file). $LOG_SUPPORT_MSG" "failed"
    fi
    if [[ -f "$old_log_file" ]];then
        $MV -f $old_log_file $new_log_file
        LOG_FILE=${new_log_file}
        # Compatible with previous versions --by 2021.05
        exec_cmd "ln -s $new_log_file $old_log_file"
    else
        LOG_FILE=${new_log_file}
    fi
    export LOG_SUPPORT_MSG="Refer to $LOG_FILE file for detail information. If need, please contact system administrator or OpenText support."
}

# remove all the access control lists (ACL)
removeACL(){
    if [[ ! -d "${CDF_HOME}" ]];then
        return
    fi
    if [[ "$(ls -ld ${CDF_HOME} 2>/dev/null|awk '{print $1}'|grep -o '+$')" == "+" ]];then
        if ! exec_cmd "setfacl -bnR ${CDF_HOME}";then
            write_log "fatal" "Failed to remove all extended ACL entries for ${CDF_HOME}. $LOG_SUPPORT_MSG" "failed"
        fi
    fi
}

copyFile2Dest() {
  write_log "step" "Copy the base installation files to ${CDF_HOME} ..."
  if stepNotDone $FUNCNAME; then
    cd ${CURRENTDIR}
    removeACL
    createEnvShell
    removeACL
    # Make sure you can uninstall at any time
    exec_cmd "$CP -rf uninstall.sh ${CDF_HOME}/."

    switchLogPath

    #After remove jdbc, cicd no longer create images folder under <CDF Package folder>.
    #But this folder is needed in Addnode job. So create it manually, so that all the logic
    #can keep no changed.
    exec_cmd "mkdir -p $CURRENTDIR/images"

    exec_cmd "mkdir -p ${CDF_HOME}/runconf ${CDF_HOME}/ssl ${RUNTIME_CDFDATA_HOME}/etcd ${RUNTIME_CDFDATA_HOME}/fluentd ${CDF_HOME}/bin"
    exec_cmd "mkdir -p ${CDF_HOME}/log/scripts ${CDF_HOME}/cfg/kube-dns-hosts ${DEPLOYMENT_LOG_LOCATION}/${CDF_NAMESPACE}"
    [ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ] && uncompressMetadata

    # comm
    exec_cmd "$CP -rf bin images scripts tools uninstall.sh version.txt version_internal.txt moduleVersion.json node_prereq install image_pack_config.json ${CDF_HOME}/."
    if [ $? -ne 0 ]; then
        write_log "fatal" "Failed to copy files from ${CURRENTDIR} to ${CDF_HOME}. $LOG_SUPPORT_MSG" "failed"
    fi

    exec_cmd "$CP -rf $(ls cdf|xargs -n1|awk '$0 !~ /cdf-components/{print "cdf/" $0}'|xargs) ${CDF_HOME}/."
    if [ $? -ne 0 ]; then
        write_log "fatal" "Failed to copy files from ${CURRENTDIR} to ${CDF_HOME}. $LOG_SUPPORT_MSG" "failed"
    fi

    #exec_cmd "$RM -rf ${CDF_HOME}/scripts/downloadimages.sh"
    #add link for some commands
    write_log "debug" "Create symlinks under /usr/bin for the binaries in ${CDF_HOME}/bin ..."
    exec_cmd "ln -sf ${CDF_HOME}/bin/vault /usr/bin/vault"
    exec_cmd "ln -sf ${CDF_HOME}/bin/helm /usr/bin/helm"
    exec_cmd "ln -f ${CDF_HOME}/bin/jq ${CDF_HOME}/scripts/jq"
    exec_cmd "ln -sf ${CDF_HOME}/bin/velero /usr/bin/velero"

    #system_user_id/k8s_user_id/etcd_user_id should have the permission to access $CDF_HOME/ssl
    exec_cmd "chmod 755 ${CDF_HOME} ${CDF_HOME}/ssl ${CDF_HOME}/bin ${CDF_HOME}/scripts ${CDF_HOME}/tools"
    exec_cmd "chmod 700 ${CDF_HOME}/images ${RUNTIME_CDFDATA_HOME} ${CDF_HOME}/cfg ${CDF_HOME}/log ${CDF_HOME}/runconf ${DEPLOYMENT_LOG_LOCATION} ${DEPLOYMENT_LOG_LOCATION}/${CDF_NAMESPACE}"
    exec_cmd "chown -R ${ETCD_USER_ID} ${RUNTIME_CDFDATA_HOME}/etcd"
    exec_cmd "chown -R ${SYSTEM_USER_ID} ${RUNTIME_CDFDATA_HOME}/fluentd ${CDF_HOME}/log/scripts ${CDF_HOME}/scripts ${CDF_HOME}/cfg/cdf-phase2.json ${DEPLOYMENT_LOG_LOCATION}"
    exec_cmd "chmod -R u+x ${CDF_HOME}/install ${CDF_HOME}/uninstall.sh ${CDF_HOME}/node_prereq ${CDF_HOME}/scripts ${CDF_HOME}/bin"
    [ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ] && exec_cmd "chown -R ${SYSTEM_USER_ID} ${CDF_HOME}/cfg/suite-metadata"

    #note: etcdctl is modified in install-k8s.sh
    local bin4AllUser="aws-ecr-create-repository cdfctl changeRegistry cmd_wrapper deployment-status.sh env.sh helm jq kubectl notary updateExternalDbInfo velero vault yq"
    local scripts4AllUser="alertmanager cdfctl.sh certCheck cleanRegistry common.sh downloadimages.sh generateCerts.sh generate_secrets generateSilentTemplate gen_secrets.sh gs_utils.sh itom-cdf-alias.sh renewCert replaceExternalAccessHost.sh uploadimages.sh volume_admin.sh"
    local tools4AllUser="generate-download postgres-backup"
    for binary in ${bin4AllUser}; do
        exec_cmd "chmod 755 $CDF_HOME/bin/$binary"
    done
    for script in ${scripts4AllUser};do
        exec_cmd "chmod a+rx $CDF_HOME/scripts/$script"
    done
    for tool in $tools4AllUser; do
        exec_cmd "chmod -R a+rx $CDF_HOME/tools/$tool"
    done

    setStepDone $FUNCNAME
    showStatus "ok"
  else
    showStatus "Already done"
  fi
}

copyFile2DestForBYOK() {
  write_log "step" "Copy the base installation files to ${CDF_HOME} ..."
  if stepNotDone $FUNCNAME; then
    removeACL
    switchLogPath
    runCopyTools "install"
    if [ $? -ne 0 ]; then
        write_log "fatal" "Failed to copy files from ${CURRENTDIR} to ${CDF_HOME}. $LOG_SUPPORT_MSG" "failed"
    fi
    removeACL
    exec_cmd "/bin/mkdir -p $CDF_HOME/objectdefs"
    setStepDone $FUNCNAME
    showStatus "ok"
  else
    showStatus "Already done"
  fi
}

runCopyTools(){
    local type=$1
    if [[ -n "$type" ]];then
        exec_cmd "${CURRENTDIR}/copyTools.sh -H $CDF_HOME -y >/dev/null"
        return $?
    else
        local confirm=
        if [[ "$CLI_SKIP_PRECHECK_WARNING" == "true" ]];then
            confirm="-y"
        fi
        ${CURRENTDIR}/copyTools.sh -H $CDF_HOME $confirm
        return $?
    fi
}

getSuiteName(){
    if [[ "$NODE_TYPE" == "first" ]] && [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ]] && [[ -n "$METADATA" ]];then
        local level=
        local tmp_dir="${TMP_FOLDER}/.cdf_metadata_tmp"
        local metadata_dir="$tmp_dir/suite-metadata"
        exec_cmd "$RM -rf $tmp_dir"
        exec_cmd "mkdir -p $metadata_dir"
        level=$(exec_cmd "$TAR -tf ${METADATA} 2>/dev/null | awk -F/ '/suiteinfo.json/ {print NF}'" -p=true)
        if [ ! -z "$level" ]; then
            exec_cmd "$TAR -zxf ${METADATA} --strip-components $(($level-1)) -C ${metadata_dir}"
            if [ $? -ne 0 ]; then
                write_log "fatal" "The metadata package $METADATA does not have the correct internal structure. $LOG_SUPPORT_MSG" "failed"
            fi
            # get suite name
            if [ -f "${metadata_dir}/suiteinfo.json" ]; then
                if [ $($JQ 'has("suiteInfoList")' ${metadata_dir}/suiteinfo.json) = "false" ]; then
                    exec_cmd "$MV -f ${metadata_dir}/suiteinfo.json ${metadata_dir}/suiteinfo.json.ori"
                    exec_cmd "cat ${metadata_dir}/suiteinfo.json.ori | $JQ '{suiteInfoList: [ .]}' > ${metadata_dir}/suiteinfo.json"
                    exec_cmd "$RM -f ${metadata_dir}/suiteinfo.json.ori"
                fi
                SUITE_NAME=$(exec_cmd "$JQ -r \".suiteInfoList[].suite\" \"${metadata_dir}/suiteinfo.json\" 2>/dev/null" -p=true)
                if [ -z "$SUITE_NAME" -o "$SUITE_NAME" = "null" ]; then
                    write_log "fatal" "Failed to get suite name from ${metadata_dir}/suiteinfo.json. $MF_SUPPORT_MSG"
                fi
            else
                write_log "fatal" "File $${metadata_dir}/suiteinfo.json is not found. $MF_SUPPORT_MSG"
            fi
            exec_cmd "$RM -rf $tmp_dir"
        else
            write_log "fatal" "The metadata package $METADATA does not have the correct internal structure. $LOG_SUPPORT_MSG" "failed"
        fi
    fi
}

getClusterName(){
    if [[ "$NODE_TYPE" == "first" ]];then
        source $PREVIOUS_INSTALL_CONFIG
        if [[ -z "$DEFAULT_CLUSTER_NAME" ]];then
            write_log "fatal" "Failed to get random cluster name. $MF_SUPPORT_MSG"
        fi
        evaluateVariable "CLUSTER_NAME" "CLI_CLUSTER_NAME" "$DEFAULT_CLUSTER_NAME"
    fi
}

setenv(){
    local is_byok_tools="$1"
    if [[ -n "$is_byok_tools" ]];then
        CDF_NAMESPACE="$CLI_CDF_NAMESPACE"
    fi
    write_log "debug" "Export CDF_HOME to $CDF_PROFILE ..."
    if [[ "$INSTALLED_TYPE" == "CLASSIC" ]] && [[ ! -d /etc/profile.d ]];then
        exec_cmd "mkdir -p /etc/profile.d"
    fi

    echo "
# itom cdf env
export CDF_HOME=${CDF_HOME}
export PATH=\$PATH:\${CDF_HOME}/bin
export CDF_NAMESPACE=${CDF_NAMESPACE}
export TMP_FOLDER=$TMP_FOLDER
    ">$CDF_PROFILE
    if [[ $? -ne 0 ]];then
        write_log "fatal" "Please use root user or sudo user to install $PRODUCT_SHORT_NAME."
    fi
    if [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
        echo "export ETCDCTL_API=3" >> $CDF_PROFILE
        echo "export CONTAINERD_NAMESPACE=k8s.io" >> $CDF_PROFILE
        echo "# Note: K8S_HOME is deprecated. Use CDF_HOME instead" >> $CDF_PROFILE
        echo "export K8S_HOME=${CDF_HOME}" >> $CDF_PROFILE
    fi

    if [ "$CAPS_K8S_BACKUP" = "true" ]; then
        echo "export VELERO_NAMESPACE=${CDF_NAMESPACE}"  >> $CDF_PROFILE
    fi

    exec_cmd "chmod 644 $CDF_PROFILE"
    if [[ "${SUDO_UID}" != 0 ]] && [[ "${SUDO_UID}" != "" ]];then
        exec_cmd "chown ${SUDO_UID} $CDF_PROFILE"
    fi

    for var_name in CDF_HOME CDF_NAMESPACE TMP_FOLDER;do
        # When only Tools is installed on the bastion, CDF_NAMESPACE can be empty.
        if [[ -n "$is_byok_tools" ]] && [[ "$var_name" == "CDF_NAMESPACE" ]];then
            continue
        fi
        if ! grep -P "^\s*export\s+${var_name}=\S+" $CDF_PROFILE 1>/dev/null 2>&1;then
            write_log "fatal" "Failed to initialize $CDF_PROFILE, ${var_name} is empty. $MF_SUPPORT_MSG"
        fi
    done

    exec_cmd "cat $CDF_PROFILE"
}

sourceCdfProfile(){
    if [[ -f "$CDF_PROFILE" ]];then
        if ! source $CDF_PROFILE;then
            write_log "fatal" "Failed to source $CDF_PROFILE. $MF_SUPPORT_MSG"
        fi
    fi
}

loadImage() {
    local imageName=$1
    local imageNum=$2
    local needRetry=$3
    local imageDir=$CDF_HOME/images

    write_log "step" " $imageNum Loading ${imageName} ..."
    [ ! -f ${imageDir}/${imageName} ] && write_log "fatal" "File ${imageName} is not found. $MF_SUPPORT_MSG" "failed"
    if [[ "$(stepNotDone $imageName; echo $?)" == "0" ]] || [[ -n "$needRetry" ]]; then
      exec_cmd "${CDF_HOME}/bin/ctr -n k8s.io images import ${SNAPSHOTTER_TYPE} <(gzip --decompress --stdout ${imageDir}/${imageName})"
      if [ $? -ne 0 ];then
        local source_image;source_image=$(exec_cmd "find $CURRENTDIR -name ${imageName}|head -1" -p=true)
        if [[ -n "$source_image" ]];then
            exec_cmd "$CP -f $source_image ${imageDir}/${imageName}"
            exec_cmd "${CDF_HOME}/bin/ctr -n k8s.io images import ${SNAPSHOTTER_TYPE} <(gzip --decompress --stdout ${imageDir}/${imageName})" || write_log "fatal" "Failed to load image ${imageName}. $LOG_SUPPORT_MSG" "failed"
        else
            write_log "fatal" "Failed to load image ${imageName}, tar archive file missing. $LOG_SUPPORT_MSG" "failed"
        fi
      fi
      setStepDone $imageName
      showStatus "ok"
    else
        showStatus "Already done"
    fi
}

loadNodeImages(){
    local needRetry=$1
    local image_arr=()
    local totalImageNum=0
    if [ "$NODE_TYPE" = "first" ];then
        image_arr=${FIRST_MASTER_MAIN_IMAGES_BUNDLE[*]}
        image_arr=($image_arr)
        totalImageNum=${#image_arr[*]}
        local currentImageNum=0
        write_log "info" "Load node images from ${CDF_HOME}/images"
        for image in ${image_arr[*]}
        do
            currentImageNum=$((currentImageNum+1))
            loadImage "${image}-images.tgz" "[$currentImageNum/$totalImageNum]" "$needRetry"
        done
    fi
}

tagImages(){
    local needRetry=$1
    if [[ "$NODE_TYPE" = "first" ]];then
      if [[ "$(stepNotDone $FUNCNAME; echo $?)" == "0" ]] || [[ -n "$needRetry" ]]; then
          pkg_arr=$FIRST_MASTER_MAIN_IMAGES_BUNDLE
          local registryURL="localhost:5000"
          for pkg in ${pkg_arr}; do
                local items=$($JQ -r ".packages[]|select (.name==\"$pkg\").images[]" ${CURRENTDIR}/image_pack_config.json | xargs)
                for item in ${items};do
                    local image=$(eval echo "\$$item")
                    local target
                    if [ -z "${REGISTRY_ORGNAME}" ];then
                        target="${DOCKER_REPOSITORY}/$image"
                    else
                        target="${DOCKER_REPOSITORY}/${REGISTRY_ORGNAME}/$image"
                    fi
                    #if already exist, skip, otherwise, tagImage may return non-zero
                    if [ $(ctr -n k8s.io images ls -q | grep "$target" | wc -l) -ne 0 ];then
                        continue
                    fi
                    tagImage "${registryURL}/$image" "$target"
                done
          done
          setStepDone $FUNCNAME
        fi
    fi
}

tagImage(){
    local sourceImage=$1
    local targetImage=$2
    exec_cmd "ctr -n k8s.io images tag --force $sourceImage $targetImage" || write_log "fatal" "Failed to tag image $sourceImage to $targetImage. $LOG_SUPPORT_MSG"
}

pushImages2LocalRegistry(){
    if [[ "$DOCKER_REPOSITORY" != "localhost:5000" ]];then
        return
    fi
    write_log "step" "Push images to local registry ..."
    if stepNotDone $FUNCNAME; then
        pkg_arr="$INFRA_MAIN_IMAGES_BUNDLE $FIRST_MASTER_MAIN_IMAGES_BUNDLE"
        for pkg in ${pkg_arr};do
            local items=$($JQ -r ".packages[]|select (.name==\"$pkg\").images[]" ${CURRENTDIR}/image_pack_config.json | xargs)
            for item in ${items}; do
                local name=$(eval echo "\$$item")
                local n=0
                while [[ $(exec_cmd "${CDF_HOME}/bin/ctr -n k8s.io images push --hosts-dir ${CDF_HOME}/cfg/certs.d/  --tlscacert ${CDF_HOME}/ssl/ca.crt -u '$(echo "${INTERNAL_KUBE_REGISTRY_USERNAME}:${SUPER_USERPWD}"|sed -e "s/'/'\\\\''/g")' localhost:5000/${REGISTRY_ORGNAME}/$name" -p=false -m=false; echo $?) != 0 ]]; do
                    local check_exist_image=
                    check_exist_image=$(exec_cmd "${CDF_HOME}/bin/ctr -n k8s.io images ls |awk '/^localhost:5000/{print \$1}'|grep '${REGISTRY_ORGNAME}/$name'" -p=true)
                    if [[ -z "$check_exist_image" ]];then
                        showStatus "pause"
                        if ! bash ${CURRENTDIR}/k8s/scripts/install-k8s.sh "NEED_RELOAD_RETAG_IMAGES";then
                            write_log "fatal" "Reload and retag k8s images failed."
                        fi
                        loadNodeImages 'NeedReload'
                        tagImages 'NeedRetag'
                        write_log "step" "Resume push images to local registry ..."
                    fi
                    n=$(( $n + 1 ))
                    if [[ ${n} -eq ${RETRY_TIMES} ]] ; then
                        write_log "fatal" "Failed to push image $name to local registry. $LOG_SUPPORT_MSG"
                    fi
                    write_log "debug" "Pushing $name failed. Retry $n/${RETRY_TIMES}."
                    sleep 1
                done
            done
        done
        setStepDone $FUNCNAME
        showStatus "ok"
    else
        showStatus "Already done"
    fi
}

configureRBAC(){
  if [ "$NODE_TYPE" = "first" ]; then
    # helm/bosun mode (non-suite): no need to create ServiceAccount: cdf-deployer.
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]] || [ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" -a -n "$SILENT_CONFIG_FILE" -a -z "$METADATA" ];then
        return
    fi
    write_log "step" "Configure for RBAC ..."
    if stepNotDone $FUNCNAME; then
        local yaml=$CDF_HOME/objectdefs/rbac-config.yaml
        exec_cmd "$CP -f $CURRENTDIR/cdf/objectdefs/rbac-config.yaml $yaml"
        replacePlaceHolders $yaml
        if [ "$INSTALLED_TYPE" = "CLASSIC" ];then
            deployYamlFile $yaml
        else
            deployYamlFileForBYOK $yaml
        fi
        setStepDone $FUNCNAME
        showStatus "ok"
    else
        showStatus "Already done"
    fi
  fi
}

configureNodeManagerRBAC(){
  if [ "$NODE_TYPE" = "first" ] && [ "$INSTALLED_TYPE" = "CLASSIC" ]; then
    write_log "step" "Configure for itom-node-manager RBAC ..."
    if stepNotDone $FUNCNAME; then
        local yaml=$CDF_HOME/objectdefs/itom-node-manager.yaml
        exec_cmd "$CP -f $CURRENTDIR/cdf/objectdefs/itom-node-manager.yaml $yaml"
        replacePlaceHolders $yaml
        deployYamlFile $yaml
        setStepDone $FUNCNAME
        showStatus "ok"
    else
        showStatus "Already done"
    fi
  fi
}

checkAzureKeepalived(){
    local reTryTimes=0
    while [ $(exec_cmd "${CDF_HOME}/bin/etcdctl ${ETCD3_SSL_CONN_PARAM} --endpoints https://${K8S_MASTER_IP}:4001 get / --prefix --keys-only=true" -o=false; echo $?) -ne 0 ]; do
      reTryTimes=$(( $reTryTimes + 1 ))
      if [ $reTryTimes -eq 120 ]; then
        write_log "fatal" "Failed to start keepalived. $LOG_SUPPORT_MSG"
      else
        write_log "debug" "This keepalived is not running. Wait for $SLEEP_TIME seconds and recheck: $reTryTimes"
      fi
      sleep $SLEEP_TIME
    done
}
dec2bin() {
    local num=$1
    local s=8
    local bin=("")
    while [[ $s -ne 0 ]] ; do
        ((s--))
        if [[ ${num} -ne 0 ]] ; then
            bin[${s}]=$(( ${num} % 2 ))
            num=$(((( ${num} - ${num} % 2 )) / 2 ))
        else
            bin[${s}]=0
        fi
    done
    echo ${bin[@]}|sed s/[[:space:]]//g
}

#FLANNEL_BACKEND_TYPE=host-gw 16.155.197.50 255.255.248.0
getIpInSameSubnet() {
    if [ $# -eq 1 ]; then
        local netAddress[0]=$1
        local netAddress[1]=$(ifconfig|grep ${netAddress[0]}|awk '{print $4}')
    elif [ $# -eq 2 ]; then
        local netAddress[0]=$1
        local netAddress[1]=$2
    fi
    local all=(${netAddress[@]//[!0-9]/ })
    local a=$(( $((2#$(dec2bin ${all[0]}))) & $((2#$(dec2bin ${all[4]}))) ))
    local b=$(( $((2#$(dec2bin ${all[1]}))) & $((2#$(dec2bin ${all[5]}))) ))
    local c=$(( $((2#$(dec2bin ${all[2]}))) & $((2#$(dec2bin ${all[6]}))) ))
    local d=$(( $((2#$(dec2bin ${all[3]}))) & $((2#$(dec2bin ${all[7]}))) ))
    echo "${a}.${b}.${c}.${d}"
}
getKeepAlivedIP(){
    local targetIP
    local nics=$(route -n | grep ^0.0.0.0 | awk '{print $8}')
    for nic in $nics;do
        local ip=$(ifconfig $nic | grep -E 'inet\s+' | sed -E -e 's/inet\s+//g' | awk '{print $1}')
        local ip_netmask=$(ifconfig|grep $ip |awk '{print $4}')
        local ip_network_address=$(getIpInSameSubnet $ip $ip_netmask)
        local vip_network_address=$(getIpInSameSubnet $HA_VIRTUAL_IP $ip_netmask)
        if [ "$ip_network_address" = "$vip_network_address" ]; then
            targetIP="$ip"
            break
        fi
    done
    echo $ip
}
configureKeepAlivedCm(){
    local cmName="itom-cdf-keepalived"
    if [ -n "${HA_VIRTUAL_IP}" ]; then
        local targetIP=$(getKeepAlivedIP)
        local cmAlreadyExist="false"
        local reTryTimes=0
        if [ $(exec_cmd "kubectl get cm $cmName -n kube-system" -p=false; echo $?) -eq 0 ];then
            cmAlreadyExist="true"
        fi
        while true; do
            if [ "$cmAlreadyExist" == "true" ];then
                exec_cmd "kubectl patch cm $cmName -n kube-system -p '{\"data\":{\"$THIS_NODE\":\"$targetIP\"}}'"
            else
                echo "
kind: ConfigMap
apiVersion: v1
metadata:
  name: $cmName
  namespace: kube-system
data:
  $THIS_NODE: $targetIP" | kubectl create --save-config -f - 1>>$LOG_FILE 2>&1
            fi
            if [ $? -eq 0 ];then
                break
            else
                reTryTimes=$(( $reTryTimes + 1 ))
                if [ $reTryTimes -eq $RETRY_TIMES ]; then
                    write_log "fatal" "Failed to update ${cmName}. $LOG_SUPPORT_MSG" "failed"
                else
                    write_log "debug" "Failed to update ${cmName}. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                fi
                sleep $SLEEP_TIME
            fi
        done
    fi
}

configureKeepAlived() {
    if [ -n "${HA_VIRTUAL_IP}" ]; then
        if [ "${NODE_TYPE}" = "first" -o "${NODE_TYPE}" = "master" ]; then
            write_log "step" "Configure for KeepAlived ..."
            if stepNotDone $FUNCNAME; then
                # Since it's Daemonset. Should only be deployed once.
                if [ "${NODE_TYPE}" == "first" ]; then
                    local yaml=$CDF_HOME/objectdefs/keepalived.yaml
                    if [ ! -f "${yaml}" ]; then
                        showStatus "error"
                        write_log "fatal" "Yaml file ${yaml} not exist! $LOG_SUPPORT_MSG"
                    fi
                    if [ "$CLOUD_PROVIDER" = "azure" ]; then
                        # Do not edit indentation
                        sed -i -e 's@{AZURE_CONFIG_VOLUME}@volumeMounts:\
        - name: cloud-azure\
          mountPath: /etc/cdf/keepalived-azure.conf\
          readOnly: true\
      volumes:\
        - name: cloud-azure\
          hostPath:\
            path: '${AZURE_CONFIG_FILE}'\
            type: File@g' $yaml
                    else
                        sed -i -e 's@{AZURE_CONFIG_VOLUME}@@g' $yaml
                    fi
                    sed -i -e "s@{MASTER_API_SSL_PORT}@$MASTER_API_SSL_PORT@g" $yaml
                    sed -i -e "s@{CDF_NAMESPACE}@$CDF_NAMESPACE@g" $yaml
                    sed -i -e "s@{DOCKER_REPOSITORY}@$DOCKER_REPOSITORY@g" $yaml
                    sed -i -e "s@{REGISTRY_ORGNAME}@$REGISTRY_ORGNAME@g" $yaml
                    sed -i -e "s@{IMAGE_KEEPALIVED}@$IMAGE_KEEPALIVED@g" $yaml
                    # replace the nodeSelector to first master node
                    local THIS_NODE_SELECTOR="kubernetes.io/hostname: ${THIS_NODE}"
                    sed -i -e "s@{FIRST_MASTER_NODE_SELECTOR}@$THIS_NODE_SELECTOR@g" $yaml
                    deployYamlFile $yaml
                fi
                if [ "$CLOUD_PROVIDER" = "azure" ]; then
                    checkAzureKeepalived
                fi
                setStepDone $FUNCNAME
                showStatus "ok"
            else
                showStatus "Already done"
            fi
        fi
    fi
}

configureDNSExternalName() {
  write_log "step" "Configure and start the kube-dns external name for ${CDF_NAMESPACE}..."
  if stepNotDone $FUNCNAME; then
    replacePlaceHolders $CDF_HOME/objectdefs/external-name.yaml
    deployYamlFile $CDF_HOME/objectdefs/external-name.yaml
    setStepDone $FUNCNAME
    showStatus "ok"
  else
    showStatus "Already done"
  fi
}

startKubeRgistry(){
if [ "${NODE_TYPE}" = "first" ]; then
    write_log "step" "Configure the internal registry ..."
    if stepNotDone $FUNCNAME; then
      source $PREVIOUS_INSTALL_CONFIG
      local componentName=kube-registry
      local secretName=${componentName}-cert
      local sslDir=$CDF_HOME/ssl
      # start up registry
      local installed=$(${CDF_HOME}/bin/helm list -n $CDF_NAMESPACE -q -o json | $JQ "contains([\"$componentName\"])")
      if [ "$installed" = "false" ]; then
          local b64encPwd=$(echo -n ${SUPER_USERPWD} | base64 )
          local b64encReaderPwd=$(echo -n $INTERNAL_KUBE_REGISTRY_READER_PWD | base64 -w0)
          local signKey=$(date +%s | md5sum | cut -c 1-31 )
          local labelKey="$(echo "$MASTER_NODELABEL_KEY"|sed 's/\./\\./g')"
          local labelVal="$(echo "$MASTER_NODELABEL_VAL"|sed 's/\./\\./g')"
          exec_cmd "${CDF_HOME}/bin/helm install --debug $componentName ${CURRENTDIR}/k8s/charts/${CHART_ITOM_KUBE_REGISTRY} -n $CDF_NAMESPACE \
                    --set credentials.b64encPassword=$b64encPwd \
                    --set credentials.b64encReaderPassword=$b64encReaderPwd \
                    --set credentials.signKey=$signKey \
                    $SET_HELM_CHART_TLS_OPTIONS \
                    --set global.docker.registry=$DOCKER_REPOSITORY \
                    --set global.docker.orgName=$REGISTRY_ORGNAME \
                    --set global.securityContext.user=$SYSTEM_USER_ID \
                    --set global.securityContext.fsGroup=$SYSTEM_GROUP_ID \
                    --set tls.cert=$(cat ${sslDir}/${componentName}.crt | base64 -w0) \
                    --set tls.key=$(cat ${sslDir}/${componentName}.key | base64 -w0) \
                    --set global.cluster.tolerations[0].key=$TAINT_MASTER_KEY \
                    --set global.cluster.tolerations[0].operator=Exists \
                    --set global.cluster.tolerations[0].effect=NoSchedule \
                    --set-string global.nodeSelector.\"$labelKey\"=\"$labelVal\" "
          # helm install command return error
          if [ $? -ne 0 ]; then
              write_log "fatal" "Failed to start up $componentName. $LOG_SUPPORT_MSG" "failed"
          fi
      fi
      # wait for pod ready
      local reTryTimes=0
      while true;
      do
          local registryReady=$(exec_cmd "${CDF_HOME}/bin/kubectl get ep $componentName -n $CDF_NAMESPACE -o json 2>/dev/null | $JQ -r '.\"subsets\"[0].\"addresses\"[0] | has(\"ip\")'" -p=true)
          if [ "$registryReady" = "true" ]
          then
              write_log "debug" "$componentName is ready."
              break
          else
               reTryTimes=$(( $reTryTimes + 1 ))
              if [ $reTryTimes -ge 60 ]; then
                  write_log "fatal" "Failed to start up $componentName. $LOG_SUPPORT_MSG" "failed"
              else
                  write_log "debug" "Failed to start up $componentName. Wait for 5 seconds and retry: $reTryTimes"
              fi
          fi
          sleep 5
      done
      setStepDone $FUNCNAME
      showStatus "ok"
      exec_cmd "$RM -f ${sslDir}/${componentName}.*"
    else
      showStatus "Already done"
    fi
fi
}

startLogrotate(){
if [ "${NODE_TYPE}" = "first" ]; then
    write_log "step" "Configure the logrotate ..."
    if stepNotDone $FUNCNAME; then
      local componentName=itom-logrotate
      # start up logrotate
      local findName=$(${CDF_HOME}/bin/helm list -n $CDF_NAMESPACE -q -o json 2>/dev/null|$JQ -r ".[]|select(.==\"$componentName\")")
      if [[ "$findName" != "$componentName" ]]; then
          exec_cmd "${CDF_HOME}/bin/helm install --debug $componentName ${CURRENTDIR}/cdf/charts/${CHART_ITOM_LOG_ROTATE} -n $CDF_NAMESPACE \
                    --set global.logrotate.deploymentType=daemonset \
                    $SET_HELM_CHART_TLS_OPTIONS \
                    --set global.docker.imagePullSecret=registrypullsecret \
                    --set global.docker.registry=$DOCKER_REPOSITORY \
                    --set global.docker.orgName=$REGISTRY_ORGNAME \
                    --set global.securityContext.user=$SYSTEM_USER_ID \
                    --set global.securityContext.fsGroup=$SYSTEM_GROUP_ID \
                    --set global.cluster.tolerations[0].key=$TAINT_MASTER_KEY \
                    --set global.cluster.tolerations[0].operator=Exists \
                    --set global.cluster.tolerations[0].effect=NoSchedule \
                    --set global.logrotate.hostPath=${CDF_HOME}/log "
          # helm install command return error
          if [ $? -ne 0 ]; then
              write_log "fatal" "Failed to start up $componentName. $LOG_SUPPORT_MSG" "failed"
          fi
      fi
      # wait for pod ready
      local reTryTimes=0
      while true;
      do
          local status=$(exec_cmd "${CDF_HOME}/bin/kubectl get ds $componentName -n $CDF_NAMESPACE -o jsonpath={.status} 2>/dev/null" -p=true)
          local desiredNumberScheduled=$(echo $status|$JQ -r '.desiredNumberScheduled')
          local currentNumberScheduled=$(echo $status|$JQ -r '.currentNumberScheduled')
          local numberReady=$(echo $status|$JQ -r '.numberReady')
          local updatedNumberScheduled=$(echo $status|$JQ -r '.updatedNumberScheduled + 0')
          local numberAvailable=$(echo $status|$JQ -r '.numberAvailable')
          local numberUnavailable=$(echo $status|$JQ -r '.numberUnavailable + 0')
          if [ "$desiredNumberScheduled" = "$currentNumberScheduled" -a "$desiredNumberScheduled" = "$numberReady" -a "$desiredNumberScheduled" = "$updatedNumberScheduled" -a "$desiredNumberScheduled" = "$numberAvailable" -a "$numberUnavailable" -eq 0 ]; then
              write_log "debug" "$componentName is ready."
              break
          else
               reTryTimes=$(( $reTryTimes + 1 ))
              if [ $reTryTimes -ge 60 ]; then
                  write_log "fatal" "Failed to start up $componentName. $LOG_SUPPORT_MSG" "failed"
              else
                  write_log "debug" "Failed to start up $componentName. Wait for 5 seconds and retry: $reTryTimes"
              fi
          fi
          sleep 5
      done

      setStepDone $FUNCNAME
      showStatus "ok"
    else
      showStatus "Already done"
    fi
fi
}

replacePlaceHolders() {
    file=$1
    write_log "debug" "Injecting the configuration values into ${file} ..."
    if [[ "$IPV6" == "true" ]];then
        # enable dual stack
        tplRemoveBeginToEnd "$file" "SINGLESTACK_IPV4"
    else
        # enable single stack ipv4
        tplRemoveBeginToEnd "$file" "DUALSTACK"
        sed -i -e 's/,{IPV6_POD_CIDR}//g' "$file"
        sed -i -e 's/,{IPV6_SERVICE_CIDR}//g' "$file"
    fi
    sed -i -r -e '/# {0,}-{1,}(BEGIN|END) {0,}(SINGLESTACK_IPV4|DUALSTACK)/d' "$file"

    sed -i -e "s/{K8S_MASTER_IP}/$K8S_MASTER_IP/g" $file
    sed -i -e "s/{THIS_NODE}/$THIS_NODE/g" $file
    sed -i -e "s@{SERVICE_CIDR}@$SERVICE_CIDR@g" $file
    sed -i -e "s@{POD_CIDR}@${POD_CIDR}@g" $file
    sed -i -e "s@{POD_CIDR_SUBNETLEN}@${POD_CIDR_SUBNETLEN}@g" $file
    sed -i -e "s@{IPV6_SERVICE_CIDR}@$IPV6_SERVICE_CIDR@g" $file
    sed -i -e "s@{IPV6_POD_CIDR}@${IPV6_POD_CIDR}@g" $file
    sed -i -e "s@{IPV6_POD_CIDR_SUBNETLEN}@${IPV6_POD_CIDR_SUBNETLEN}@g" $file
    sed -i -e "s@{ETCD_ENDPOINT}@$ETCD_ENDPOINT@g" $file
    sed -i -e "s@{ETCD_PREFIX}@$ETCD_PREFIX@g" $file
    sed -i -e "s/{DNS_SVC_IP}/$DNS_SVC_IP/g" $file
    sed -i -e "s/{DNS_DOMAIN}/$DNS_DOMAIN/g" $file
    sed -i -e "s:{CDF_HOME}:$CDF_HOME:g" $file
    sed -i -e "s:{K8S_HOME}:$CDF_HOME:g" $file
    sed -i -e "s/{MASTER_API_PORT}/$MASTER_API_PORT/g" $file
    sed -i -e "s/{MASTER_API_SSL_PORT}/$MASTER_API_SSL_PORT/g" $file
    sed -i -e "s@{NODESELECT}@$NODESELECT@g" $file
    sed -i -e "s@{CLUSTER_NODESELECT}@$NODESELECT@g" $file
    sed -i -e "s@{BASEINFRA_VAULT_NAMESPACE}@$BASEINFRA_VAULT_NAMESPACE@g" $file
    sed -i -e "s@{BASEINFRA_VAULT_APPROLE}@$BASEINFRA_VAULT_APPROLE@g" $file
    sed -i -e "s@{BASEINFRA_VAULT_ROLE_ID}@$BASEINFRA_VAULT_ROLE_ID@g" $file
    sed -i -e "s@{BASEINFRA_VAULT_CERTIFICATE_ROLE}@$BASEINFRA_VAULT_CERTIFICATE_ROLE@g" $file
    sed -i -e "s@{CDF_NAMESPACE}@$CDF_NAMESPACE@g" $file
    sed -i -e "s@{PLATFORM_VERSION}@$PLATFORM_VERSION@g" $file
    sed -i -e "s@{MULTI_SUITE}@$MULTI_SUITE@g" $file
    sed -i -e "s@{DOCKER_REPOSITORY}@$DOCKER_REPOSITORY@g" $file
    sed -i -e "s@{REGISTRY_ORGNAME}@$REGISTRY_ORGNAME@g" $file
    sed -i -e "s@{MASTERNODE_TIME_ZONE}@$TZ@g" $file
    sed -i -e "s@{SYSTEM_USER_ID}@$SYSTEM_USER_ID@g" $file
    sed -i -e "s@{SYSTEM_GROUP_ID}@$SYSTEM_GROUP_ID@g" $file
    sed -i -e "s@{SUITE_NAME}@$SUITE_NAME@g" $file
    sed -i -e "s@{IMAGE_ETCD}@$IMAGE_ETCD@g" $file
    sed -i -e "s@{IMAGE_KUBE_APISERVER}@$IMAGE_KUBE_APISERVER@g" $file
    sed -i -e "s@{IMAGE_KUBE_SCHEDULER}@$IMAGE_KUBE_SCHEDULER@g" $file
    sed -i -e "s@{IMAGE_KUBE_CONTROLLER_MANAGER}@$IMAGE_KUBE_CONTROLLER_MANAGER@g" $file
    sed -i -e "s@{IMAGE_COREDNS}@$IMAGE_COREDNS@g" $file
    sed -i -e "s@{IMAGE_ITOM_BUSYBOX}@$IMAGE_ITOM_BUSYBOX@g" $file
    sed -i -e "s@{IMAGE_ITOM_CDF_SUITEFRONTEND}@$IMAGE_ITOM_CDF_SUITEFRONTEND@g" $file
    sed -i -e "s@{IMAGE_ITOM_CDF_APISERVER}@$IMAGE_ITOM_CDF_APISERVER@g" $file
    sed -i -e "s@{IMAGE_ITOM_NGINX_INGRESS}@$IMAGE_ITOM_NGINX_INGRESS@g" $file
    sed -i -e "s@{IMAGE_KEEPALIVED}@$IMAGE_KEEPALIVED@g" $file
    sed -i -e "s@{IMAGE_ITOM_REGISTRY}@$IMAGE_ITOM_REGISTRY@g" $file
    sed -i -e "s@{IMAGE_ITOM_CDF_ADDNODE}@$IMAGE_ITOM_CDF_ADDNODE@g" $file
    sed -i -e "s@{IMAGE_KUBERNETES_VAULT_INIT}@$IMAGE_KUBERNETES_VAULT_INIT@g" $file
    sed -i -e "s@{IMAGE_KUBERNETES_VAULT_RENEW}@$IMAGE_KUBERNETES_VAULT_RENEW@g" $file
    sed -i -e "s@{IMAGE_OPENSUSE_BASE}@$IMAGE_OPENSUSE_BASE@g" $file
    sed -i -e "s@{IMAGE_ITOM_CDF_ADMIN}@$IMAGE_ITOM_CDF_ADMIN@g" $file
    sed -i -e "s@{IMAGE_METRICS_SERVER}@$IMAGE_METRICS_SERVER@g" $file
    sed -i -e "s@{IMAGE_ITOM_IDM}@$IMAGE_ITOM_IDM@g" $file
    sed -i -e "s@{IMAGE_ITOM_POSTGRESQL}@$IMAGE_ITOM_POSTGRESQL@g" $file
    sed -i -e "s@{IMAGE_ITOM_PG_BACKUP}@$IMAGE_ITOM_PG_BACKUP@g" $file
    sed -i -e "s@{IMAGE_ITOM_LOGROTATE}@$IMAGE_ITOM_LOGROTATE@g" $file
    sed -i -e "s@{IMAGE_ITOM_FLUENTD}@$IMAGE_ITOM_FLUENTD@g" $file
    sed -i -e "s@{IMAGE_VAULT}@$IMAGE_VAULT@g" $file
    sed -i -e "s@{IMAGE_FLANNEL}@$IMAGE_FLANNEL@g" $file
    sed -i -e "s@{DEPLOYMENT_LOG_LOCATION}@${DEPLOYMENT_LOG_LOCATION}@g" $file
    sed -i -e "s@{BOOTSTRAP_DOCKER_PARAM}@${BOOTSTRAP_DOCKER_PARAM}@g" $file
    sed -i -e "s@{RESTART_POLICY}@${RESTART_POLICY}@g" $file
    sed -i -e "s@{FLANNEL_SUBNET_DIR}@${FLANNEL_SUBNET_DIR}@g" $file
    sed -i -e "s@{RUNTIME_CDFDATA_HOME}@${RUNTIME_CDFDATA_HOME}@g" $file
    sed -i -e "s@{KUBELET_HOME}@${KUBELET_HOME}@g" $file
    sed -i -e "s@{FLANNEL_BACKEND_TYPE}@${FLANNEL_BACKEND_TYPE}@g" $file
    #For openshift only
    if [ "$CLOUD_PROVIDER" = "openshift" ]; then
        sed -i -e "s@#{FOR_OPENSHIFT}@@g" $file
    fi
    if [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
        sed -i -e "s@{K8S_USER_ID}@$K8S_USER_ID@g" $file
        sed -i -e "s@{K8S_GROUP_ID}@$K8S_GROUP_ID@g" $file
        sed -i -e "s@{ETCD_USER_ID}@$ETCD_USER_ID@g" $file
        sed -i -e "s@{ETCD_GROUP_ID}@$ETCD_GROUP_ID@g" $file
    fi
}

createNamespace(){
  if [ "$NODE_TYPE" = "first" ]; then
    local ns_operator="Patch"
    if [[ "$CDF_ADMIN_TASKS" =~ (^|,)ns(,|$) ]];then
        ns_operator="Create"
    fi
    write_log "step" "$ns_operator the ${CDF_NAMESPACE} namespace ..."
    if stepNotDone $FUNCNAME; then
        local reTryTimes=0
        if [[ "$ns_operator" == "Create" ]] && [ $(exec_cmd "kubectl get namespace ${CDF_NAMESPACE} 2>/dev/null"; echo $?) -ne 0 ]; then
            local uuid=$(exec_cmd "cat /proc/sys/kernel/random/uuid" -p=true)
            if ! checkDeploymentUuidFormat "$uuid";then
                write_log "fatal" "Failed to get the system uuid."
            fi
            while true; do
                exec_cmd "echo '
apiVersion: v1
kind: Namespace
metadata:
  labels:
    deployments.microfocus.com/deployment-name: cdf
    deployments.microfocus.com/deployment-uuid: \"$uuid\"
  name: $CDF_NAMESPACE
                '|kubectl create --save-config -f -"
                if [ $? -eq 0 ]; then
                    write_log "debug" "Create namespace ${CDF_NAMESPACE} successfully."
                    break
                elif [ $reTryTimes -eq $RETRY_TIMES ]; then
                    if [[ "$ns_operator" == "Patch" ]];then
                        write_log "fatal" "Failed to create namespace $CDF_NAMESPACE. Please create the namespace manually."
                    fi
                    write_log "fatal" "Failed to create ${CDF_NAMESPACE} namespace. $LOG_SUPPORT_MSG" "failed"
                else
                    write_log "debug" "Failed to create ${CDF_NAMESPACE} namespace. Wait for $SLEEP_TIME seconds and retry: $reTryTimes "
                fi
                reTryTimes=$(( $reTryTimes + 1 ))
                sleep $SLEEP_TIME
            done
        fi

        reTryTimes=0
        while true; do
            exec_cmd "kubectl patch serviceaccount default -p '{\"metadata\":{\"annotations\":{\"deployment.microfocus.com/namespace\":\"used\"}}}' -n ${CDF_NAMESPACE}"
            if [ $? -eq 0 ]; then
                write_log "debug" "kubectl patch serviceaccount default annotations successfully."
                break
            elif [ $reTryTimes -eq $RETRY_TIMES ]; then
                write_log "fatal" "Failed to patch annotations to default serviceaccount. $LOG_SUPPORT_MSG" "failed"
            else
                write_log "debug" "Failed to patch annotations to default serviceaccount. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
            fi
            reTryTimes=$(( $reTryTimes + 1 ))
            sleep $SLEEP_TIME
        done

        setStepDone $FUNCNAME
        showStatus "ok"
    else
        showStatus "Already done"
    fi
  fi
}

createNsForDeployment(){
    local ns="$DEPLOYMENT_NAME"
    if [ "$NODE_TYPE" = "first" ]; then
        local ns_operator="Patch"
        if [[ "$CDF_ADMIN_TASKS" =~ (^|,)ns(,|$) ]];then
            ns_operator="Create"
        fi
        write_log "step" "$ns_operator the ${ns} namespace ..."
        if stepNotDone $FUNCNAME; then
            local reTryTimes=0
            if [[ "$ns_operator" == "Create" ]] && [ $(exec_cmd "kubectl get namespace ${ns} 2>/dev/null"; echo $?) -ne 0 ]; then
                while true; do
                    if [ $(exec_cmd "kubectl create --save-config namespace ${ns}"; echo $?) -eq 0 ]; then
                        write_log "debug" "Create namespace ${ns} successfully."
                        break
                    elif [ $reTryTimes -eq $RETRY_TIMES ]; then
                        if [[ "$ns_operator" == "Patch" ]];then
                            write_log "fatal" "Failed to create namespace $ns. Please create the namespace manually."
                        fi
                        write_log "fatal" "Failed to create ${ns} namespace. $LOG_SUPPORT_MSG" "failed"
                    else
                        write_log "debug" "Failed to create ${ns} namespace. Wait for $SLEEP_TIME seconds and retry: $reTryTimes "
                    fi
                    reTryTimes=$(( $reTryTimes + 1 ))
                    sleep $SLEEP_TIME
                done
            fi

            setStepDone $FUNCNAME
            showStatus "ok"
        else
            showStatus "Already done"
        fi
    fi
}

checkStorageSecret(){
    if stepNotDone $FUNCNAME; then
        if [ "$CAPS_K8S_BACKUP" = "true" -a -n "$BACKUP_STORAGE_SECRET" ]; then
            write_log "debug" "Check secret $BACKUP_STORAGE_SECRET"
            exec_cmd "kubectl get secret $BACKUP_STORAGE_SECRET -n $CDF_NAMESPACE"
            if [ "$?" != "0" ]; then
                write_log "fatal" "Secret $BACKUP_STORAGE_SECRET does not exist under $CDF_NAMESPACE namespace." "failed"
            fi
        fi
        setStepDone $FUNCNAME
    fi
}

insertLockRecord() {
    local lock=$1
    if [ -n "${CDF_WRITE_LOCKS}" ]; then
        CDF_WRITE_LOCKS="${CDF_WRITE_LOCKS} ${lock}"
    else
        CDF_WRITE_LOCKS="${lock}"
    fi
    write_log "debug" "Writted lock ${lock} to CDF_WRITE_LOCKS. Now all locks are: ${CDF_WRITE_LOCKS}"
}

removeLockRecord() {
    local lock=$1
    if [ -n "${CDF_WRITE_LOCKS}" ]; then
        CDF_WRITE_LOCKS=$(echo "${CDF_WRITE_LOCKS}" | sed "s@${lock}@@g")
    fi
    write_log "debug" "Removed lock ${lock} from CDF_WRITE_LOCKS. Now all locks are: ${CDF_WRITE_LOCKS}"
}

releaseWriteLock() {
    local lock=${1:-"cdf-write-lock"}
    local retryTimes=0
    while true; do
        if [ $retryTimes -ge 12 ]; then
            write_log "fatal" "Failed to release write-lock for ${lock}. ${LOG_SUPPORT_MSG}" "failed"
            break
        fi
        exec_cmd "${CDF_HOME}/bin/kubectl delete configmap --ignore-not-found -n ${CDF_NAMESPACE} ${lock}"
        if [ $? -eq 0 ]; then
            removeLockRecord "$lock"
            break
        fi
        retryTimes=$(( $retryTimes + 1 ))
        sleep 5
    done
}

getWriteLock() {
    local lock=${1:-"cdf-write-lock"}
    local retryTimes=0
    while true; do
        if [ $retryTimes -ge 60 ]; then
            write_log "debug" "Maybe the previous writter is down. No longer wait for write-lock ${lock}. Continue."
            releaseWriteLock "$lock"
            # Try the last time to insert lock
            exec_cmd "${CDF_HOME}/bin/kubectl create configmap -n ${CDF_NAMESPACE} ${lock}"
            if [ $? -eq 0 ]; then
                insertLockRecord "$lock"
                break
            fi
            break
        fi
        exec_cmd "${CDF_HOME}/bin/kubectl create configmap -n ${CDF_NAMESPACE} ${lock}"
        if [ $? -eq 0 ]; then
            insertLockRecord "$lock"
            break
        fi
        retryTimes=$(( $retryTimes + 1 ))
        write_log "debug" "Failed to get write-lock for ${lock}. Sleep 5 and Retry ${retryTimes}"
        sleep 5
    done
}

createCdfClusterHostOptions(){
    #TODO: should remove K8S_HOME
    CDF_CLUSTER_HOST_OPTIONS="--from-literal=ALLOW_WORKLOAD_ON_MASTER=${ALLOW_WORKLOAD_ON_MASTER} \\
        --from-literal=API_SERVER=${K8S_MASTER_IP} \\
        --from-literal=AUTO_CONFIGURE_FIREWALL=${AUTO_CONFIGURE_FIREWALL} \\
        --from-literal=AWS_EIP=${AWS_EIP} \\
        --from-literal=AWS_REGION=${AWS_REGION} \\
        --from-literal=CDF_ADMIN_TASKS=${CDF_ADMIN_TASKS} \\
        --from-literal=CDF_HOME=${CDF_HOME} \\
        --from-literal=CDF_NAMESPACE=${CDF_NAMESPACE} \\
        --from-literal=CERTIFICATE_PERIOD=${CERTIFICATE_PERIOD} \\
        --from-literal=CLUSTER_MGMT_ADDR=${K8S_MASTER_IP} \\
        --from-literal=CLUSTER_NAME=${CLUSTER_NAME} \\
        --from-literal=CRT_HTTP_PROXY=${CRT_HTTP_PROXY} \\
        --from-literal=CRT_HTTPS_PROXY=${CRT_HTTPS_PROXY} \\
        --from-literal=CRT_NO_PROXY=${CRT_NO_PROXY} \\
        --from-literal=ENABLE_FIPS=${ENABLE_FIPS} \\
        --from-literal=ENABLE_K8S_AUDIT_LOG=${ENABLE_K8S_AUDIT_LOG} \\
        --from-literal=ETCD_ENDPOINT=${ETCD_ENDPOINT} \\
        --from-literal=ETCD_GROUP_ID=${ETCD_GROUP_ID} \\
        --from-literal=ETCD_USER_ID=${ETCD_USER_ID} \\
        --from-literal=FAIL_SWAP_ON=${FAIL_SWAP_ON} \\
        --from-literal=FIPS_ENTROPY_THRESHOLD=${FIPS_ENTROPY_THRESHOLD} \\
        --from-literal=FIRST_MASTER_NODE=${THIS_NODE} \\
        --from-literal=FLANNEL_BACKEND_TYPE=${FLANNEL_BACKEND_TYPE} \\
        --from-literal=FLANNEL_PORT=${FLANNEL_PORT} \\
        --from-literal=FLANNEL_DIRECTROUTING=${FLANNEL_DIRECTROUTING} \\
        --from-literal=HA_VIRTUAL_IP=${HA_VIRTUAL_IP} \\
        --from-literal=INFRA_VERSION=${PLATFORM_VERSION} \\
        --from-literal=INTERNAL_VERSION=${INTERNAL_VERSION} \\
        --from-literal=K8S_DEFAULT_SVC_IP=${K8S_DEFAULT_SVC_IP} \\
        --from-literal=K8S_GROUP_ID=${K8S_GROUP_ID} \\
        --from-literal=K8S_HOME=${CDF_HOME} \\
        --from-literal=K8S_PROVIDER=${K8S_PROVIDER} \\
        --from-literal=K8S_USER_ID=${K8S_USER_ID} \\
        --from-literal=KEEPALIVED_ADVERT_INT=${KEEPALIVED_ADVERT_INT} \\
        --from-literal=KEEPALIVED_NOPREEMPT=${KEEPALIVED_NOPREEMPT} \\
        --from-literal=KEEPALIVED_VIRTUAL_ROUTER_ID=${KEEPALIVED_VIRTUAL_ROUTER_ID} \\
        --from-literal=KUBELET_HOME=${KUBELET_HOME} \\
        --from-literal=KUBELET_PROTECT_KERNEL_DEFAULTS=${KUBELET_PROTECT_KERNEL_DEFAULTS} \\
        --from-literal=LOAD_BALANCER_HOST=${LOAD_BALANCER_HOST} \\
        --from-literal=MASTER_API_SSL_PORT=${MASTER_API_SSL_PORT} \\
        --from-literal=NETWORK_ADDRESS=${NETWORK_ADDRESS} \\
        --from-literal=IPV6=${IPV6} \\
        --from-literal=POD_CIDR_SUBNETLEN=${POD_CIDR_SUBNETLEN} \\
        --from-literal=IPV6_POD_CIDR_SUBNETLEN=${IPV6_POD_CIDR_SUBNETLEN} \\
        --from-literal=POD_CIDR=${POD_CIDR} \\
        --from-literal=IPV6_POD_CIDR=${IPV6_POD_CIDR} \\
        --from-literal=SERVICE_CIDR=${SERVICE_CIDR} \\
        --from-literal=IPV6_SERVICE_CIDR=${IPV6_SERVICE_CIDR} \\
        --from-literal=DNS_SVC_IP=${DNS_SVC_IP} \\
        --from-literal=REGISTRY_ORGNAME=${REGISTRY_ORGNAME} \\
        --from-literal=RUNTIME_CDFDATA_HOME=${RUNTIME_CDFDATA_HOME} \\
        --from-literal=SUITE_REGISTRY=${DOCKER_REPOSITORY} \\
        --from-literal=SYSTEM_GROUP_ID=${SYSTEM_GROUP_ID} \\
        --from-literal=SYSTEM_USER_ID=${SYSTEM_USER_ID} \\
        --from-literal=TLS_CIPHERS=${TLS_CIPHERS} \\
        --from-literal=TLS_MIN_VERSION=${TLS_MIN_VERSION} \\
        --from-literal=TMP_FOLDER=${TMP_FOLDER} "
}

createCdfClusterHostConfigMap(){
    if [ "$NODE_TYPE" = "first" ]; then
      local cm="cdf-cluster-host"
      write_log "step" "Create the $cm configmap ..."
      if stepNotDone $FUNCNAME; then
        local reTryTimes=0
        createCdfClusterHostOptions
        while true; do
            exec_cmd "kubectl create --save-config configmap $cm -n ${CDF_NAMESPACE} \\
                $CDF_CLUSTER_HOST_OPTIONS "

            if [ $? -eq 0 ] || [ $(exec_cmd "kubectl get configmap $cm -n ${CDF_NAMESPACE}"; echo $?) -eq 0 ] ; then
                write_log "debug" "Set $cm configmap successfully."
                break
            elif [ $reTryTimes -eq $RETRY_TIMES ]; then
                write_log "fatal" "Failed to create $cm configmap. $LOG_SUPPORT_MSG" "failed"
            else
                write_log "debug" "Failed to set $cm configmap. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
            fi
            reTryTimes=$(( $reTryTimes + 1 ))
            sleep $SLEEP_TIME
        done
        # exec_cmd "kubectl get cm -n ${CDF_NAMESPACE} $cm -o yaml >$CDF_HOME/objectdefs/cdf-cluster-host.yaml"
        setStepDone $FUNCNAME
        showStatus "ok"
      else
        showStatus "Already done"
      fi
    fi
}

checkCustomRegistryCa(){
    if [ "$DOCKER_REPOSITORY" == "localhost:5000" ];then
        return
    fi
    local customCaOutput="$TMP_FOLDER/rootCA.crt"
    exec_cmd "$RM -f $customCaOutput"
    if [[ -n "${REGISTRY_CA}" ]];then
        exec_cmd "${CURRENTDIR}/bin/cdfctl cert connect --address $DOCKER_REPOSITORY --customCA ${REGISTRY_CA} --output $TMP_FOLDER"
        if [ $? -ne 0 ];then
            exec_cmd "${CURRENTDIR}/bin/cdfctl cert connect --address $DOCKER_REPOSITORY --customCA ${REGISTRY_CA} --output $TMP_FOLDER" -p=true
            write_log "fatal" "The CA root certificate and url of the registry do not match \
or the current registry url cannot be connected \
or the current system time exceeds the validity period of the registry certificate"
        fi
    else
        exec_cmd "${CURRENTDIR}/bin/cdfctl cert connect --address $DOCKER_REPOSITORY --output $TMP_FOLDER"
        if [ "$?" -ne 0 ];then
             exec_cmd "${CURRENTDIR}/bin/cdfctl cert connect --address $DOCKER_REPOSITORY --output $TMP_FOLDER" -p=true
             write_log "fatal" "The current registry url cannot be connected \
or the current system time exceeds the validity period of the registry certificate, \
you try to use '--registry-ca' to provide the registry CA root certificate \
or check whether the network is connected \
or check whether the system time is correct"
        fi
    fi
    exec_cmd "$MV -f $customCaOutput $TMP_FOLDER/registry_ca.crt"
    if [ $? -ne 0 ];then
        write_log "fatal" "Failed to obtain the registry CA root certificate."
    fi
}

createRegistryCasConfigMap(){
    if [ "$NODE_TYPE" = "first" ]; then
      local cm="registry-ca-certificates"
      write_log "step" "Create the $cm configmap ..."
      if stepNotDone $FUNCNAME; then
        local appendCa=
        if [[ -f "$TMP_FOLDER/registry_ca.crt" ]];then
            appendCa="--from-file=registry_ca.crt=$TMP_FOLDER/registry_ca.crt"
        fi
        local reTryTimes=0
        while true; do
            exec_cmd "kubectl create --save-config configmap $cm -n ${CDF_NAMESPACE} $appendCa "
            if [ $? -eq 0 ] || [ $(exec_cmd "kubectl get configmap $cm -n ${CDF_NAMESPACE}"; echo $?) -eq 0 ] ; then
                write_log "debug" "Set $cm configmap successfully."
                break
            elif [ $reTryTimes -eq $RETRY_TIMES ]; then
                write_log "fatal" "Failed to create $cm configmap. $LOG_SUPPORT_MSG" "failed"
            else
                write_log "debug" "Failed to set $cm configmap. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
            fi
            reTryTimes=$(( $reTryTimes + 1 ))
            sleep $SLEEP_TIME
        done

        reTryTimes=0
        while true; do
            exec_cmd "kubectl label configmap $cm -n ${CDF_NAMESPACE} configurations.microfocus.com/tlstrustore=true --overwrite"
            if [ $? -eq 0 ]; then
                write_log "debug" "Label $cm configmap successfully."
                break
            elif [ $reTryTimes -eq $RETRY_TIMES ]; then
                write_log "fatal" "Failed to label $cm configmap. $LOG_SUPPORT_MSG" "failed"
            else
                write_log "debug" "Failed to label $cm configmap. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
            fi
            reTryTimes=$(( $reTryTimes + 1 ))
            sleep $SLEEP_TIME
        done

        setStepDone $FUNCNAME
        showStatus "ok"
      else
        showStatus "Already done"
      fi
    fi
}

getMasterNodeTimeZone() {
    TZ=$(timedatectl 2>/dev/null | grep "Time zone") #; echo $TZ
    TZ=${TZ#*: } #; echo $TZ
    TZ=${TZ%% (*} #; echo $TZ
    if [ -z "$TZ" -o "$TZ" = 'n/a' -o "$TZ" = 'N/A' ]; then
        TZ="UTC"
    fi
}

deployYamlFile(){
    yamlFile=$1
    local reTryTimes=0
    local K8S_APISERVER_IP="$K8S_MASTER_IP"
    if [ "$NODE_TYPE" = "first" ]; then
        K8S_APISERVER_IP=${THIS_NODE}
    fi
    while true; do
        if [ $(exec_cmd "${CDF_HOME}/bin/kubectl --server=https://${K8S_APISERVER_IP}:${MASTER_API_SSL_PORT} describe -f $yamlFile" -o=false; echo $?) -eq 0 ]
        then
            write_log "debug" "Successfully deployed YAML: $yamlFile"
            break
        else
            exec_cmd "${CDF_HOME}/bin/kubectl --server=https://${K8S_APISERVER_IP}:${MASTER_API_SSL_PORT} create --save-config -f $yamlFile" && break
            reTryTimes=$(( $reTryTimes + 1 ))
            if [ $reTryTimes -ge 5 ]; then
                write_log "fatal" "Failed to deploy yaml file $yamlFile. $LOG_SUPPORT_MSG" "failed"
            else
                write_log "debug" "Failed to deploy yaml file $yamlFile. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
            fi
        fi
        sleep $SLEEP_TIME
    done
}

packInstallerZip(){
    if [ "$NODE_TYPE" = "first" ]; then
        write_log "step" "Pack the installer bundle used for adding nodes ..."
        if stepNotDone $FUNCNAME; then
            cd ${CURRENTDIR}
            [ -d ${CDF_HOME}/zip ] && exec_cmd "$RM -rf ${CDF_HOME}/zip"
            exec_cmd "mkdir -p ${CDF_HOME}/zip"
            exec_cmd "chmod 700 ${CDF_HOME}/zip"
            exec_cmd "chown ${SYSTEM_USER_ID}:${SYSTEM_GROUP_ID} ${CDF_HOME}/zip"

            for type_name in cri k8s cdf comm;do
                # go to $CURRENTDIR again
                cd ${CURRENTDIR}
                exec_cmd "mkdir -p ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node"
                if [[ -d "${CURRENTDIR}/${type_name}" ]];then
                    exec_cmd "mkdir -p ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}"
                    for sub in $(ls $type_name|xargs -n1|awk '$1!="images"');do
                        exec_cmd "$CP -rf ${CURRENTDIR}/${type_name}/$sub ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}"
                    done
                fi
                if [ "$type_name" == "cri" ];then
                    exec_cmd "$CP -rf ${CDF_HOME}/cfg/selinux-module ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/cfg/"
                    exec_cmd "$CP -rf ${CDF_HOME}/cfg/systemd-template ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/cfg/"
                elif [ "$type_name" == "k8s" ];then
                    exec_cmd "$CP -rf ${CDF_HOME}/cfg/controller-manager ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/cfg/"
                    exec_cmd "$CP -rf ${CDF_HOME}/cfg/kube-dns-hosts ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/cfg/"
                    exec_cmd "$CP -rf ${CDF_HOME}/cfg/cdf-addnode.json ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/cfg/"
                    exec_cmd "$CP -rf ${CDF_HOME}/cfg/apiserver-encryption.yaml ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/cfg/"
                    exec_cmd "$CP -rf ${CDF_HOME}/cfg/admission-cfg.yaml ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/cfg/"
                    exec_cmd "$CP -rf ${CDF_HOME}/cfg/apiserver-audit-policy.yaml ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/cfg/"
                    exec_cmd "$CP -rf ${CDF_HOME}/objectdefs/coredns.yaml ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/objectdefs/"
                    exec_cmd "$CP -rf ${CDF_HOME}/objectdefs/flannel.yaml ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/objectdefs/"
                    exec_cmd "$CP -rf ${CDF_HOME}/objectdefs/flannel-config.yaml ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/objectdefs/"
                    exec_cmd "$CP -rf ${CDF_HOME}/objectdefs/k8s-rbac-config.yaml ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/objectdefs/"
                    exec_cmd "$CP -rf ${CDF_HOME}/objectdefs/kube-proxy.yaml ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/objectdefs/"
                    exec_cmd "$CP -rf ${CDF_HOME}/objectdefs/kube-proxy-config.yaml ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/objectdefs/"
                elif [ "$type_name" == "cdf" ];then
                    if [ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ] && [ -n "$METADATA" ];then
                        local metadataDir="${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/cfg/suite-metadata"
                        exec_cmd "mkdir -p ${metadataDir}/package && chmod 755 $metadataDir"
                        exec_cmd "chmod 700 ${CDF_HOME}/zip"
                        local level=$($TAR -tf ${METADATA} 2>/dev/null | awk -F/ '/suiteinfo.json/ {print NF}')
                        exec_cmd "$TAR -zxf ${METADATA} --strip-components $(($level-1)) -C $metadataDir"
                        if [ $? -ne 0 ]; then
                            write_log "fatal" "Failed to untar suite-metadata for packing installer. $LOG_SUPPORT_MSG" "failed"
                        else
                            exec_cmd "$CP -f ${CDF_HOME}/cfg/suite-metadata/suiteinfo.json $metadataDir"
                            exec_cmd "$CP -f ${METADATA} $metadataDir/package/metadata.tar.gz"
                            exec_cmd "chmod 755 \$(find ${metadataDir} -type d) && chmod 644 \$(find ${metadataDir} -type f)"
                        fi
                        exec_cmd "$CP -rf ${CDF_HOME}/cfg/suite-metadata ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/cfg/"
                        exec_cmd "$RM -rf ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/cfg"
                    fi

                    exec_cmd "$CP -rf ${CDF_HOME}/cfg/cdf-phase1.json ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/cfg/"
                    exec_cmd "$CP -rf ${CDF_HOME}/cfg/cdf-phase2.json ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/cfg/"
                    exec_cmd "$CP -rf ${CDF_HOME}/objectdefs/rbac-config.yaml ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/${type_name}/objectdefs/"
                    exec_cmd "$RM -f ${CDF_HOME}/tools/silent-install/ping-node"
                elif [ "$type_name" == "comm" ];then
                    exec_cmd "$CP -rf ${CURRENTDIR}/bin ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                    exec_cmd "$CP -rf ${CURRENTDIR}/cfg ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                    exec_cmd "$CP -rf ${CURRENTDIR}/properties ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                    exec_cmd "$CP -rf ${CURRENTDIR}/image_pack_config.json ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                    exec_cmd "$CP -rf ${CURRENTDIR}/scripts ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                    exec_cmd "$CP -rf ${CURRENTDIR}/tools ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                    exec_cmd "$CP -rf ${CURRENTDIR}/install ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                    exec_cmd "$CP -rf ${CURRENTDIR}/version.txt ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                    exec_cmd "$CP -rf ${CURRENTDIR}/version_internal.txt ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                    exec_cmd "$CP -rf ${CURRENTDIR}/uninstall.sh ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                    exec_cmd "$CP -rf ${CURRENTDIR}/node_prereq ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                    exec_cmd "$CP -rf ${CURRENTDIR}/moduleVersion.json ${CDF_HOME}/zip/ITOM_Suite_Foundation_Node/"
                fi
                cd ${CDF_HOME}/zip
                exec_cmd "$TAR -zcvf ITOM_Suite_Foundation_Node_${type_name}.tar.gz ITOM_Suite_Foundation_Node/"
                if [ $? -eq 0 ]; then
                    exec_cmd "chown ${SYSTEM_USER_ID}:${SYSTEM_GROUP_ID} ITOM_Suite_Foundation_Node_${type_name}.tar.gz"
                    exec_cmd "$RM -rf ./ITOM_Suite_Foundation_Node"
                    write_log "debug" "Successfully pack ${type_name} installer."
                else
                    write_log "fatal" "Failed to pack the ${type_name} installer. $LOG_SUPPORT_MSG" "failed"
                fi
            done
            cd ${CURRENTDIR}
            setStepDone $FUNCNAME
            showStatus "ok"
        else
            showStatus "Already done"
        fi
    fi
}

movePackageToVolume(){
    if [ "$NODE_TYPE" = "first" ]; then
        write_log "step" "Move the installer bundle used for adding nodes ..."
        if stepNotDone $FUNCNAME; then
            exec_cmd "chown -R ${SYSTEM_USER_ID}:${SYSTEM_GROUP_ID} ${CDF_HOME}/images"
            exec_cmd "chmod 644 ${CDF_HOME}/images/*"
            local image_name="${DOCKER_REPOSITORY}/${REGISTRY_ORGNAME}/${IMAGE_ITOM_TOOLS_BASE}"
            local job_name="itom-cdf-move-pack"
            local create_log="$TMP_FOLDER/.cdf_create_$job_name.log"
            local n=0
            while true;do
                n=$((n+1))
                echo "" > $create_log
                exec_cmd "${CDF_HOME}/bin/kubectl delete job $job_name -n ${CDF_NAMESPACE}"
                local pod_status="Error"
                echo "
apiVersion: batch/v1
kind: Job
metadata:
  name: ${job_name}
  namespace: ${CDF_NAMESPACE}
  labels:
    app: ${job_name}-app
spec:
  backoffLimit: 0
  completions: 1
  parallelism: 1
  ttlSecondsAfterFinished: 172800
  template:
    metadata:
      labels:
        app: ${job_name}-app
    spec:
      containers:
      - image: ${image_name}
        imagePullPolicy: IfNotPresent
        name: ${job_name}
        securityContext:
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
        env:
        - name: IMAGE_TGZS
          value: \"$MOVE_PACK_IMAGES_BUNDLE\"
        command: ['sh', '-e', '-c', 'mkdir -p /to/pack/images;/bin/cp -rf /from/* /to/pack/;for img in \$IMAGE_TGZS;do /bin/cp -f /images/\${img}-images.tgz /to/pack/images/;done;echo \"move package success.\";']
        resources:
          limits:
            cpu: \"1\"
            memory: 2Gi
          requests:
            cpu: 100m
            memory: 200Mi
        volumeMounts:
        - name: from-local
          mountPath: /from
        - name: from-local-images
          mountPath: /images
        - name: to-volume
          mountPath: /to
      restartPolicy: Never
      dnsPolicy: ClusterFirst
      priority: 0
      imagePullSecrets:
        - name: registrypullsecret
      securityContext:
        runAsUser: ${SYSTEM_USER_ID}
        runAsGroup: ${SYSTEM_GROUP_ID}
        fsGroup: ${SYSTEM_GROUP_ID}
        supplementalGroups: [${SYSTEM_GROUP_ID}]
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault
      volumes:
      - name: from-local
        hostPath:
          path: ${CDF_HOME}/zip
      - name: from-local-images
        hostPath:
          path: ${CDF_HOME}/images
      - name: to-volume
        persistentVolumeClaim:
          claimName: itom-vol-claim
                "|${CDF_HOME}/bin/kubectl create --save-config -f - >>$create_log 2>>$create_log
                if [[ $? -eq 0 ]];then
                    break
                fi
                write_log "debug" "Failed to create job: $job_name, error message: $(cat $create_log)."
                if [[ "$n" -ge 50 ]];then
                    write_log "fatal" "Failed to move packs to volume. $LOG_SUPPORT_MSG" "failed"
                fi
                sleep 2
            done
            local retry_count=2500
            while (( $retry_count > 0 )); do
                retry_count=$(( $retry_count - 1 ))
                sleep 1
                job_success=$(exec_cmd "kubectl get jobs $job_name -n $CDF_NAMESPACE -o json 2>/dev/null|$JQ -r '.status.succeeded'" -p=true)
                job_failed=$(exec_cmd "kubectl get jobs $job_name -n $CDF_NAMESPACE -o json 2>/dev/null|$JQ -r '.status.failed'" -p=true)
                if [[ $job_success -gt 0 ]];then
                    job_status="Completed"
                    break
                elif [[ $job_failed -gt 0 ]];then
                    job_status="Error"
                    write_log "fatal" "Failed to move packs to volume. $LOG_SUPPORT_MSG" "failed"
                fi
            done
            if [[ $job_status != "Completed" ]];then
                write_log "fatal" "Failed to move packs to volume. $LOG_SUPPORT_MSG" "failed"
            fi
            exec_cmd "$RM -f $create_log"
            setStepDone $FUNCNAME
            showStatus "ok"
        else
            showStatus "Already done"
        fi
    fi
}

finalize(){
    removeACL
    # remove passwds
    local cdf_chart_yaml="$CDF_HOME/objectdefs/cdf-chart.values.yaml"
    if [[ -f "$cdf_chart_yaml" ]];then
        exec_cmd "sed -i -r -e 's/userPassword: [^ ].+/userPassword: {Password}/' $cdf_chart_yaml"
        exec_cmd "sed -i -r -e 's/password: [^ ].+/password: {Password}/' $cdf_chart_yaml"
        exec_cmd "sed -i -r -e 's/adminPassword: [^ ].+/adminPassword: {Password}/' $cdf_chart_yaml"
    fi

    local cdf_chart_upgrade_yaml="$CDF_HOME/objectdefs/cdf-chart-upgrade.values.yaml"
    if [[ -f "$cdf_chart_upgrade_yaml" ]];then
        exec_cmd "sed -i -r -e 's/userPassword: [^ ].+/userPassword: {Password}/' $cdf_chart_upgrade_yaml"
        exec_cmd "sed -i -r -e 's/password: [^ ].+/password: {Password}/' $cdf_chart_upgrade_yaml"
    fi

    # remove tmp log symbolic links for install
    for tmp_log in $(find $TMP_FOLDER -maxdepth 1 -name install.*.log|xargs);do
        if exec_cmd "grep -P '##FLAG_CDF_LOG_OWER:' '$tmp_log' -q";then
            exec_cmd "$RM -f $tmp_log"
        fi
    done

    if [ ! -f "${CDF_HOME}/log/scripts/$COMPONENTNAME/$(basename $STEPS_FILE)" ];then
        exec_cmd "/bin/mkdir -p ${CDF_HOME}/log/scripts/$COMPONENTNAME && $CP -f $STEPS_FILE ${CDF_HOME}/log/scripts/$COMPONENTNAME/"
    fi

    if [ -f "$STEPS_FILE" -a -z "$SILENT_CONFIG_FILE" ]; then exec_cmd "$RM -f $STEPS_FILE"; fi
    if [ -f "$PREVIOUS_INSTALL_CONFIG" -a -z "$SILENT_CONFIG_FILE" ]; then exec_cmd "$RM -f $PREVIOUS_INSTALL_CONFIG"; fi
    [[ "$INSTALLED_TYPE" == "BYOK" ]] && return

    #remove the certificate files in temp folder
    if [ -d "$CDF_HOME/zip" ];then exec_cmd "$RM -rf $CDF_HOME/zip"; fi
    if [ -f "${CDF_HOME}/tools/silent-install/ping-node" ]; then exec_cmd "$RM -f ${CDF_HOME}/tools/silent-install/ping-node"; fi
    if [ -f "${CDF_HOME}/scripts/upgradePreCheck" ]; then exec_cmd "$RM -f ${CDF_HOME}/scripts/upgradePreCheck"; fi
    # remove the useless K8S resources yaml definition on master nodes
    if [ "$NODE_TYPE" = "master" -o "$NODE_TYPE" = "first" ]; then
        exec_cmd "$RM -f $CDF_HOME/objectdefs/itom-vol.yaml \\
                                 $CDF_HOME/objectdefs/itom-vol-claim.yaml"
        cleanUserConfirmFlag
    fi
    # remove the unnecessary scripts, files on worker nodes
    if [ "$NODE_TYPE" = "worker" ]; then
        exec_cmd "$RM -rf $CDF_HOME/install \\
                                  $CDF_HOME/bin/updateExternalDbInfo \\
                                  $CDF_HOME/bin/changeRegistry \\
                                  $CDF_HOME/bin/aws-ecr-create-repository \\
                                  $CDF_HOME/bin/deployment-status.sh \\
                                  $CDF_HOME/bin/etcdctl \\
                                  $CDF_HOME/bin/helm \\
                                  $CDF_HOME/bin/notary \\
                                  $CDF_HOME/bin/vault \\
                                  $CDF_HOME/bin/velero \\
                                  $CDF_HOME/bin/cdfcert \\
                                  $CDF_HOME/manifests \\
                                  $CDF_HOME/objectdefs \\
                                  $CDF_HOME/runconf \\
                                  $CDF_HOME/tools/encryptK8SSecret \\
                                  $CDF_HOME/tools/generate-download \\
                                  $CDF_HOME/tools/postgres-backup \\
                                  $CDF_HOME/tools/silent-install \\
                                  $CDF_HOME/scripts/* "
        exec_cmd "$CP -rf $CURRENTDIR/cdf/scripts/renewCert $CDF_HOME/scripts"
    fi

    # remove tmp file for checkNFS.sh
    exec_cmd "$RM -rf $TMP_FOLDER/cdf_nfs_readwrite_check_*"

    if [ "$NODE_TYPE" = "master" ]; then
        local velero_deployed=$(exec_cmd "${CDF_HOME}/bin/helm list -n $CDF_NAMESPACE -q -o json 2>/dev/null | $JQ -r 'contains([\"itom-velero\"])'" -p=true)
        if [[ "$velero_deployed" == "true" ]]; then
            echo "export VELERO_NAMESPACE=${CDF_NAMESPACE}"  >> $CDF_PROFILE
        fi
    fi
}

getLocalIP(){
    local local_ip=
    if [ ! -z "$FLANNEL_IFACE" ]; then
        if [[ $FLANNEL_IFACE =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            local_ip=$FLANNEL_IFACE
        else
            local_ip=$(ifconfig $FLANNEL_IFACE 2>/dev/null | awk '/netmask/ {print $2}')
        fi
    else
        if [[ $THIS_NODE =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            local_ip=$THIS_NODE
        else
            local_ip=$(ip route get 8.8.8.8|sed 's/^.*src \([^ ]*\).*$/\1/;q')
        fi
    fi
    if [ -z $local_ip ]; then
        write_log "fatal" "Failed to get local ip of current node. $LOG_SUPPORT_MSG"
    else
        echo $local_ip
    fi
}

configFirewallSettings(){
    if [ $(systemctl status firewalld >/dev/null 2>&1; echo $?) -eq 0 -a "$AUTO_CONFIGURE_FIREWALL" = "true" ]; then
        write_log "step" "Configure the $PRODUCT_SHORT_NAME required firewall settings ..."
        local masterPorts="2380/tcp
                           4001/tcp
                           5444/tcp
                           8472/udp
                           10248/tcp
                           10249/tcp
                           10250/tcp
                           10256/tcp
                           10257/tcp
                           10259/tcp
                           ${MASTER_API_SSL_PORT}/tcp"
        local workerPorts="5444/tcp
                           8472/udp
                           10248/tcp
                           10249/tcp
                           10250/tcp
                           10256/tcp"
        [ "$NODE_TYPE" != "worker" ] && local failedPorts=$(firewalldAddPorts "$masterPorts") || local failedPorts=$(firewalldAddPorts "$workerPorts")
        local failedRules=$(firewallAddRules)
        local forwardStatus=$(firewalldEnableForward)
        [ -n "$failedPorts" -o -n "$failedRules" -o "$forwardStatus" = 'no' ] && write_log "fatal" "Failed to configure the firewall settings automatically. Please refer to the ITOM CDF Administration guide for firewall setup guidance. $LOG_SUPPORT_MSG" "failed"
        showStatus "ok"
    fi
}

firewalldAddPorts(){
    local fullPorts=$1
    local failedPorts=""
    for port in $fullPorts
    do
        exec_cmd "firewall-cmd --permanent --add-port=$port" || failedPorts="$port $failedPorts"
        exec_cmd "firewall-cmd --add-port=$port" || failedPorts="$port $failedPorts"
    done
    echo $failedPorts
}

firewallAddRules(){
    local failedRules=""
    # exec_cmd "firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 1 -o docker0 -j ACCEPT -m comment --comment 'docker subnet'" || failedRules="docker-subnet"
    # exec_cmd "firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 1 -i docker0 -j ACCEPT -m comment --comment 'kube-proxy redirects'" || failedRules="kube-proxy $failedRules"
    exec_cmd "firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 1 -o cni0 -j ACCEPT -m comment --comment 'flannel subnet'" || failedRules="flannel-subnet-1 $failedRules"
    exec_cmd "firewall-cmd --direct --add-rule ipv4 filter FORWARD 1 -o cni0 -j ACCEPT -m comment --comment 'flannel subnet'" || failedRules="flannel-subnet-1 $failedRules"
    exec_cmd "firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 1 -i cni0 -j ACCEPT -m comment --comment 'flannel subnet'" || failedRules="flannel-subnet-2 $failedRules"
    exec_cmd "firewall-cmd --direct --add-rule ipv4 filter FORWARD 1 -i cni0 -j ACCEPT -m comment --comment 'flannel subnet'" || failedRules="flannel-subnet-2 $failedRules"
    exec_cmd "firewall-cmd --permanent --direct --add-rule ipv4 nat POSTROUTING 1 -s $POD_CIDR ! -d $POD_CIDR -j MASQUERADE" || failedRules="flannel-subnet-3 $failedRules"
    exec_cmd "firewall-cmd --direct --add-rule ipv4 nat POSTROUTING 1 -s $POD_CIDR ! -d $POD_CIDR -j MASQUERADE" || failedRules="flannel-subnet-3 $failedRules"
    if [ "$NODE_TYPE" != "worker" -a -n "$HA_VIRTUAL_IP" ]; then
        exec_cmd "firewall-cmd --permanent --add-protocol vrrp" || failedRules="keepalived-vrrp $failedRules"
        exec_cmd "firewall-cmd --add-protocol vrrp" || failedRules="keepalived-vrrp $failedRules"
    fi
    echo $failedRules
}

firewalldEnableForward(){
    #enable intra-zone forward on firewalld 0.9.0 or higher version
    local interface="cni0"
    local minVersion="0.9.0"
    local firewallVersion=$(firewall-cmd --version)
    if $(echo -e "$minVersion\n$firewallVersion" | sort -V -C); then
        local forward="no"
        # enable intra-zone forward and add cni0 into default zone
        exec_cmd "firewall-cmd --permanent --add-forward" && \
        exec_cmd "firewall-cmd --add-forward" && \
        exec_cmd "firewall-cmd --permanent --add-interface=$interface" && \
        exec_cmd "firewall-cmd --add-interface=$interface" && \
        forward="yes"
    fi
    echo $forward
}

fatalOnInvalidParm(){
    write_log "fatal" "$1 parameter requires a value. "
}

setOptionVal(){
    local cli=$1
    local val=$2
    local var=$3
    local str=""

    case "$val" in
        -*) fatalOnInvalidParm "$cli" ;;
        * ) if [ -z "$val" ];then fatalOnInvalidParm "$cli" ; fi; str="${var}=\"${val}\"";  eval $str; export $var; ;;
    esac
}
checkOptionVal(){
    local cli=$1
    local val=$2

    case "$val" in
        -*) fatalOnInvalidParm "$cli" ;;
        * ) if [ -z "$val" ];then fatalOnInvalidParm "$cli" ; fi;;
    esac
}

elementExistInArray(){
    local ele=$1
    local arr=($2)
    local i=0
    for ((i=0;i<${#arr[@]};i++))
    do
        if [[ ${ele} == ${arr[$i]} ]];then
            return 0
        fi
    done
    return 1
}

getConfigDiskSpace(){
    local volume_name=$1
    local suite_volumes_list=$2
    CONFIG_VOLUME_DISK_SPACE=0
    local install_size=$(cat $SILENT_CONFIG_FILE | $JQ -r ".capabilities.installSize")
    if [[ -z "$install_size" ]] || [[ "$install_size" == "null" ]];then
        return
    fi
    # volumes size
    local volumes_num=$(echo ${suite_volumes_list} | $JQ '. | length')
    local vol_name
    local vol_size
    local n=0
    while [[ $n -lt $volumes_num ]];
    do
        vol_name=$(echo ${suite_volumes_list} | $JQ -r ".[$n].name")
        if [[ ${volume_name} == ${vol_name} ]];then
            vol_size=$(echo ${suite_volumes_list} | $JQ -r ".[$n].size.$install_size" | tr [:upper:] [:lower:])
            if [[ -n "$vol_size" ]] && [[ "$vol_size" != "null" ]];then
                echo "$vol_size" | grep "gi" 1>/dev/null 2>&1
                if [[ $? -eq 0 ]];then
                    CONFIG_VOLUME_DISK_SPACE=$(echo ${vol_size} | sed -e 's/gi//g')
                else
                    local msize=$(echo ${vol_size} | sed -e 's/mi//g')
                    CONFIG_VOLUME_DISK_SPACE=$(echo $(($msize/1024)))
                fi
            fi
            break
        fi
        n=$((n+1))
    done
}

getConfigEmptyCheck(){
    local volume_name=$1
    local suite_volumes_list=$2
    CONFIG_VOLUME_EMPTY_CHECK=false
    # volumes size
    local volumes_num=$(echo ${suite_volumes_list} | $JQ '. | length')
    local vol_name
    local empty_check
    local n=0
    while [[ $n -lt $volumes_num ]];
    do
        vol_name=$(echo ${suite_volumes_list} | $JQ -r ".[$n].name")
        if [[ ${volume_name} == ${vol_name} ]];then
            empty_check=$(echo ${suite_volumes_list} | $JQ -r ".[$n].emptyCheck" | tr [:upper:] [:lower:])
            if [[ -n "$empty_check" ]] && [[ "$empty_check" =~ true|false ]];then
                CONFIG_VOLUME_EMPTY_CHECK=$empty_check
            fi
            break
        fi
        n=$((n+1))
    done
}

checkNfsVolumes(){
    if [ -z "$NFS_SERVER" ];then
        return
    fi
    write_log "debug" "Check NFS status in $SILENT_CONFIG_FILE"
    local suite_volumes_config_list=$1
    local core_volumes_config_list="$( (cat $CURRENTDIR/cdf/cfg/cdf-phase2.json 2>/dev/null || cat $CURRENTDIR/cfg/cdf-phase2.json) | $JQ '.cdfVolume')"
    local core_volumes="$(echo ${core_volumes_config_list}|$JQ -r '.[].name'|xargs)"
    local json=$(cat $SILENT_CONFIG_FILE)
    local volumes_num=$(echo ${json} | $JQ -r '.volumes | length')
    local total_count=5
    local count=0
    local return_code
    local tmp_error_msg_log="${TMP_FOLDER}/.check_nfs_error_msg"
    local name
    local type
    local host
    local path
    local n=0
    while [[ $n -lt $volumes_num ]];
    do
        local volume_info=$(echo ${json} | $JQ -r ".volumes[$n]")
        name=$(echo ${volume_info} | $JQ -r ".name")
        type=$(echo ${volume_info} | $JQ -r ".type" | tr '[:upper:]' '[:lower:]')
        host=$(echo ${volume_info} | $JQ -r ".host")
        path=$(echo ${volume_info} | $JQ -r ".path")
        if [[ $name == "null" ]];then
            write_log "fatal" "There is an invalid volume in the configuration file \"${SILENT_CONFIG_FILE}\": \n${volume_info} \n$(tipsForFixVols)."
        fi

        local check_empty_param=""
        elementExistInArray "${name}" "${core_volumes}"
        if [[ $? -eq 0 ]];then
            # core
            getConfigDiskSpace "${name}" "${core_volumes_config_list}"
            check_empty_param=" -e "
            if [[ "$name" == "itom-vol-claim" ]];then
                # for re-run
                check_empty_param=""
            fi
        else
            # suite
            CONFIG_VOLUME_EMPTY_CHECK=false
            getConfigDiskSpace "${name}" "${suite_volumes_config_list}"
            getConfigEmptyCheck "${name}" "${suite_volumes_config_list}"
            if [[ "$CONFIG_VOLUME_EMPTY_CHECK" == "true" ]];then
                check_empty_param=" -e "
            fi
        fi

        # check
        count=0
        while true;
        do
            timeout 30 $CURRENTDIR/scripts/checkNFS.sh --persistence-threshold ${PERSISTENCE_THREHOLD} -s ${host} -f ${path} -d ${CONFIG_VOLUME_DISK_SPACE} -u ${SYSTEM_USER_ID} -g ${SYSTEM_GROUP_ID} ${check_empty_param} -t ${type} 1>${tmp_error_msg_log} 2>&1
            return_code=$?
            if [[ $return_code -ne 0 ]]; then
                if [[ $count -ge $total_count ]];then
                    if [[ $return_code == 124 ]];then
                        write_log "fatal" "Check volume timeout in the configuration file \"${SILENT_CONFIG_FILE}\": \n${volume_info}. $MSG_NFS_ISSUE_TIPS"
                    else
                        local checkNfsTips=""
                        if grep -q 'cannot mount' $tmp_error_msg_log 2>/dev/null;then
                            checkNfsTips="$MSG_NFS_ISSUE_TIPS"
                        fi
                        write_log "fatal" "There is an invalid volume in the configuration file \"${SILENT_CONFIG_FILE}\": \n${volume_info}.\n$(cat $tmp_error_msg_log)\n$checkNfsTips \n$(tipsForFixVols)"
                    fi
                fi
            else
                if grep 'Warning:' $tmp_error_msg_log 1>/dev/null 2>&1;then
                    write_log "warn" "$(grep 'Warning:' $tmp_error_msg_log)"
                fi
                break
            fi
            sleep 5
            count=$((count+1))
        done

        n=$((n+1))
    done

    rm -f ${tmp_error_msg_log}
}

checkVolumesExistByName(){
    local name=$1
    local list=$2
    local type=$3
    elementExistInArray "${name}" "${list}"
    if [[ $? -ne 0 ]];then
        echo ""
        if [[ $type == "${CDF_NAMESPACE}" ]];then
            echo "Volume \"${name}\" needs to be configured in the ${CDF_NAMESPACE} namespace."
        else
            echo "According to the metadata, you need to configure volume \"${name}\""
            echo "\"$TIPS_SUITE_FS_PATH\":"
            echo "..."
            echo "$TIPS_SUITE_FS_VOLUME"|$JQ
            echo "..."
        fi
        write_log "fatal" "A volume named '${name}' is mandatory for $type in the 'volumes' field, we did not find this volume in the configuration file \"${SILENT_CONFIG_FILE}\""
    fi
}

checkSuiteVolumesExist(){
    local fs=$1
    local feature_sets=$2
    local feature_sets_num=$(echo ${feature_sets} | $JQ '. | length')
    local fs_id
    local fs_volume_refs
    local n=0
    while [[ $n -lt $feature_sets_num ]];
    do
        fs_id=$(echo ${feature_sets} | $JQ -r ".[$n].id")
        if [[ ${fs_id} == ${fs} ]];then
            fs_volume_refs=$(echo ${feature_sets} | $JQ -r ".[$n].volumeRef")
            TIPS_SUITE_FS_VOLUME=$(echo ${feature_sets} | $JQ -r ".[$n]")
            break
        fi
        n=$((n+1))
    done

    if [[ -z "$fs_volume_refs" ]]; then
        write_log "fatal" "There is an invalid feature id in the configuration file \"${SILENT_CONFIG_FILE}\": ${fs}."
    fi

    local fs_volume_num=$(echo ${fs_volume_refs} | $JQ '. | length')
    local fs_volume
    n=0
    while [[ $n -lt $fs_volume_num ]];
    do
        fs_volume=$(echo ${fs_volume_refs} | $JQ -r ".[$n]")
        checkVolumesExistByName "${fs_volume}" "${SILENT_CONFIG_VOLUME_REFS}" "suite"
        n=$((n+1))
    done
}

checkWorkerNodeType(){
    local labels=$1
    local config_json=$2
    # check type
    local type
    local worker_nodes_num=$(echo ${config_json} | $JQ '.workerNodes | length')
    local n=0
    while [[ $n -lt $worker_nodes_num ]];
    do
        type=$(echo ${config_json} | $JQ -r ".workerNodes[$n].type")
        if [[ $type != "null" ]];then
            elementExistInArray "${type}" "${labels}"
            if [[ $? -ne 0 ]];then
                local error_tips=$(echo ${config_json} | $JQ -r ".workerNodes[$n]")
                write_log "fatal" "There is an invalid workernode type in the configuration file \"${SILENT_CONFIG_FILE}\": \n$error_tips"
            fi
        fi
        n=$((n+1))
    done
}

checkConfigJsonByMetadata(){
    local config_json=$(cat $SILENT_CONFIG_FILE)
    local suite=$(echo ${config_json} | $JQ -r ".capabilities.suite")
    local version=$(echo ${config_json} | $JQ -r ".capabilities.version")
    local edition=$(echo ${config_json} | $JQ -r ".capabilities.edition")
    local capability_selection=$(echo ${config_json} | $JQ -r ".capabilities.capabilitySelection")
    # find_suiteinfo
    local find_suiteinfo
    local suitesinfo=$(cat ${TMP_FOLDER}/.metadata-tmp/suite-metadata/suiteinfo.json)

    # compatible: {k:v}->{"suiteInfoList":[{k:v}]}
    if [ $(echo $suitesinfo|$JQ 'has("suiteInfoList")') = "false" ]; then
        exec_cmd "$MV -f ${TMP_FOLDER}/.metadata-tmp/suite-metadata/suiteinfo.json ${TMP_FOLDER}/.metadata-tmp/suite-metadata/suiteinfo.json.ori"
        exec_cmd "cat ${TMP_FOLDER}/.metadata-tmp/suite-metadata/suiteinfo.json.ori | $JQ '{suiteInfoList: [ .]}' > ${TMP_FOLDER}/.metadata-tmp/suite-metadata/suiteinfo.json"
        exec_cmd "$RM -f ${TMP_FOLDER}/.metadata-tmp/suite-metadata/suiteinfo.json.ori"
        suitesinfo=$(cat ${TMP_FOLDER}/.metadata-tmp/suite-metadata/suiteinfo.json)
    fi

    local suites_num=$(echo ${suitesinfo} | $JQ '.suiteInfoList | length')
    local suite_name
    local n=0
    while [[ $n -lt $suites_num ]];
    do
        suite_name=$(echo ${suitesinfo} | $JQ -r ".suiteInfoList[$n].suite")
        if [[ "$suite_name" == "$suite" ]];then
            find_suiteinfo=$(echo ${suitesinfo} | $JQ -r ".suiteInfoList[$n]")
            break
        fi
        n=$((n+1))
    done

    if [[ -z "$find_suiteinfo" ]];then
        write_log "debug" "Config error: .capabilities.suite($suite) not found in metadata"
        write_log "fatal" "Please provide the .capabilities information in the configuration file when installing the suite. $LOG_SUPPORT_MSG" "failed"
    fi

    # find_suitefeatures
    local find_suitefeatures
    local suite_version_num=$(echo ${find_suiteinfo} | $JQ '.versions | length')
    local suite_version
    n=0
    while [[ $n -lt $suite_version_num ]];
    do
        suite_version=$(echo ${find_suiteinfo} | $JQ -r ".versions[$n].version")
        if [[ "$suite_version" == "$version" ]];then
            find_suitefeatures=$(echo ${find_suiteinfo} | $JQ -r ".versions[$n].features")
            break
        fi
        n=$((n+1))
    done

    if [[ -z "$find_suitefeatures" ]];then
        write_log "fatal" "Configuration error: .capabilities.version($version) not found in $METADATA. $LOG_SUPPORT_MSG" "failed"
    fi

    # labels
    local labels
    local demo_suitefeatures=$(cat ${TMP_FOLDER}/.metadata-tmp/suite-metadata/suite_feature/${suite}/${version}${find_suitefeatures})
    TIPS_SUITE_FS_PATH="suite-metadata/suite_feature/${suite}/${version}${find_suitefeatures}"

    if [[ -z "$demo_suitefeatures" ]];then
        write_log "debug" "Metadata missing file: $TIPS_SUITE_FS_PATH"
        write_log "fatal" "The metadata package $METADATA does not have the correct internal structure. $LOG_SUPPORT_MSG" "failed"
    fi

    local required_nodes_num=$(echo ${demo_suitefeatures} | $JQ '.required_nodes | length')
    n=0
    while [[ $n -lt $required_nodes_num ]];
    do
        labels="$(echo ${demo_suitefeatures} | $JQ -r ".required_nodes[$n].label") $labels"
        n=$((n+1))
    done

    checkWorkerNodeType "${labels}" "${config_json}"

    # demo_suitefeatures global volumes
    local refstr=$(echo ${demo_suitefeatures} | $JQ '.volumeRef')
    TIPS_SUITE_FS_VOLUME="{\"volumeRef\":$refstr}"
    local global_volume_num=$(echo ${demo_suitefeatures} | $JQ '.volumeRef | length')
    local global_volume
    n=0
    while [[ $n -lt $global_volume_num ]];
    do
        global_volume=$(echo ${demo_suitefeatures} | $JQ -r ".volumeRef[$n]")
        checkVolumesExistByName "${global_volume}" "${SILENT_CONFIG_VOLUME_REFS}" "suite"
        n=$((n+1))
    done

    # demo_suitefeatures features volumes
    local feature_sets=$(echo ${demo_suitefeatures} | $JQ '.feature_sets')
    local features_num=$(echo ${capability_selection} | $JQ '. | length')
    local feature_id
    n=0
    while [[ $n -lt $features_num ]];
    do
        feature_id=$(echo ${capability_selection} | $JQ -r ".[$n].name")
        if [[ "$feature_id" == "null" ]];then
            local error_tips=$(echo ${capability_selection} | $JQ -r ".[$n]")
            write_log "fatal" "There is an invalid feature id in the configuration file \"${SILENT_CONFIG_FILE}\": \n.capabilities.capabilitySelection\n$error_tips"
        fi
        checkSuiteVolumesExist "${feature_id}" "${feature_sets}"
        n=$((n+1))
    done

    # volumes size
    local suite_volumes_config_list=$(echo ${demo_suitefeatures} | $JQ '.volumes')
    checkNfsVolumes "${suite_volumes_config_list}"
}

checkCoreVolumesExist(){
    # bosun mode (non-suite)
    local nonSuite=false
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]] || [ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" -a -n "$SILENT_CONFIG_FILE" -a -z "$METADATA" ];then
        nonSuite=true
    fi
    if [[ "$nonSuite" == "true" ]] && [[ "$(isEnabledByTaskName "pv")" == "false" ]];then
        # bosun: PV-ADMIN skip
        return
    fi
    local config_json=$(cat $SILENT_CONFIG_FILE)
    local volumes_num=$(echo ${config_json} | $JQ '.volumes | length')
    local names
    local vol_name
    local n=0
    while [[ $n -lt $volumes_num ]];
    do
        vol_name="$(echo ${config_json} | $JQ -r ".volumes[$n].name")"
        if [[ $vol_name == "null" ]];then
            write_log "fatal" "There is an invalid volume in the configuration file \"${SILENT_CONFIG_FILE}\": \n${volume_info} \n$(tipsForFixVols)."
        fi
        names="$vol_name $names"
        n=$((n+1))
    done

    local type=$(echo ${config_json} | $JQ -r ".database.type")
    if [[ $type == "intpostgres" ]];then
        checkVolumesExistByName "db-single-vol" "${names}" "${CDF_NAMESPACE}"
    fi

    if [ -z "${FLUENTD_LOG_RECEIVER_TYPE}" -o "${FLUENTD_LOG_RECEIVER_TYPE}" == "file" ];then
        checkVolumesExistByName "itom-logging-vol" "${names}" "${CDF_NAMESPACE}"
    fi

    SILENT_CONFIG_VOLUME_REFS=$names
}

checkMetadataForSuite(){
    if [ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ] && [ -n "$METADATA" ];then
        exec_cmd "$RM -rf ${TMP_FOLDER}/.metadata-tmp"
        local level=
        exec_cmd "mkdir -p ${TMP_FOLDER}/.metadata-tmp/suite-metadata && chmod 755 ${TMP_FOLDER}/.metadata-tmp/suite-metadata"
        level=$(exec_cmd "$TAR -tf ${METADATA} 2>/dev/null | awk -F/ '/suiteinfo.json/ {print NF}'" -p=true)
        if [ ! -z "$level" ]; then
            local metadata_dir="${TMP_FOLDER}/.metadata-tmp/suite-metadata"
            exec_cmd "$TAR -zxf ${METADATA} --strip-components $(($level-1)) -C ${metadata_dir}"
            if [ $? -ne 0 ]; then
                write_log "fatal" "The metadata package $METADATA does not have the correct internal structure. $LOG_SUPPORT_MSG" "failed"
            fi
        else
            write_log "fatal" "The metadata package $METADATA does not have the correct internal structure. $LOG_SUPPORT_MSG" "failed"
        fi
        exec_cmd "$RM -rf ${TMP_FOLDER}/.metadata-tmp"
    fi
}

showNonprintingError(){
    local nodes_info=$1
    local tips=$2
    local nonprints;nonprints=$(echo "$nodes_info"|awk '/\xe2\x80\x8b/ || /\xe2\x80\x8c/ || /\xe2\x80\x8d/')
    if [[ -n "$nonprints" ]];then
        echo "(Display control characters except for LFD and TAB using '^' notation and precede characters that have the high bit set with 'M-')"
        echo "$nodes_info"|cat -v
    else
        echo "$nodes_info"
    fi
    write_log "fatal" "There is an invalid node in the configuration file \"${SILENT_CONFIG_FILE}\": $tips."
}

checkNodeConnect(){
    if [[ "$INSTALLED_TYPE" == "BYOK" ]] || [[ -z "$SILENT_CONFIG_FILE" ]];then
        return
    fi
    readonly local ping_node="$CURRENTDIR/cdf/tools/silent-install/ping-node"
    if [[ ! -f "$ping_node" ]] || [[ ! -x "$ping_node" ]];then
        write_log "warn" "Missing executable '$ping_node', skipping connection detection for node."
        return
    fi
    write_log "debug" "Check hosts status"
    for node_type in 'masterNodes' 'workerNodes';do
        local nodeNum;nodeNum=$($JQ -r ".${node_type} | length" $SILENT_CONFIG_FILE)
        local n=0
        while [ $n -lt $nodeNum ]; do
            local nodes_info;nodes_info="$($JQ -r .${node_type}[$n] $SILENT_CONFIG_FILE)"
            local crt;crt=$(exec_cmd "$JQ -r .${node_type}[$n].privateKey? $SILENT_CONFIG_FILE" -p=true)
            local hostname;hostname=$(exec_cmd "$JQ -r .${node_type}[$n].hostname? $SILENT_CONFIG_FILE" -p=true)
            local user;user=$(exec_cmd "$JQ -r .${node_type}[$n].user? $SILENT_CONFIG_FILE" -p=true)
            local password_type;password_type=$(exec_cmd "$JQ -r '[.${node_type}[$n].password?]|map(type)|.[0]' $SILENT_CONFIG_FILE" -p=true)
            local passwd;passwd=$(exec_cmd "$JQ -r .${node_type}[$n].password? $SILENT_CONFIG_FILE" -p=true -o=false -m=false)
            if [[ "$password_type" == "string" ]] && [[ -n "$passwd" ]];then
                exec_cmd "timeout 3 $ping_node -n '$hostname' -u '$user' -P '$(echo "${passwd}"|base64 -w0)' -base64" -m=false
                if [[ $? -ne 0 ]];then
                    write_log "info" "Check $user@$hostname ..."
                    exec_cmd "$ping_node -n '$hostname' -u '$user' -P '$(echo "${passwd}"|base64 -w0)' -base64" -m=false
                fi
            elif [[ -f "$crt" ]]; then
                exec_cmd "timeout 3 $ping_node -n '$hostname' -u '$user' -k '$crt'"
                if [[ $? -ne 0 ]];then
                    write_log "info" "Check $user@$hostname ..."
                    exec_cmd "$ping_node -n '$hostname' -u '$user' -k '$crt'"
                fi
            else
                showNonprintingError "$nodes_info" "$user@$hostname missing password or privateKey"
            fi
            if [[ $? -ne 0 ]];then
                showNonprintingError "$nodes_info" "$user@$hostname cannot be accessed"
            fi

            n=$((n+1))
        done
    done
}

checkNodeHostnames(){
    if [[ -z "$SILENT_CONFIG_FILE" ]];then
        return
    fi
    local allowWorkerOnMaster=$(cat $SILENT_CONFIG_FILE|$JQ -r '.allowWorkerOnMaster')
    local masterNum=0
    local workerNum=0
    local masters=""
    local workers=""
    local hasMaster=$(cat $SILENT_CONFIG_FILE|$JQ -r 'has("masterNodes")')
    local hasWorker=$(cat $SILENT_CONFIG_FILE|$JQ -r 'has("workerNodes")')
    if [[ "$hasMaster" == "true" ]];then
        masterNum=$(cat $SILENT_CONFIG_FILE|$JQ -r '.masterNodes|length')
        masters=$(cat $SILENT_CONFIG_FILE|$JQ -r '.masterNodes[].hostname')
        if [ -n "$masters" ]; then
            for m in $masters
            do
                validateFqdnIPFormat $m
            done
        fi
    fi
    if [[ "$hasWorker" == "true" ]];then
        workerNum=$(cat $SILENT_CONFIG_FILE|$JQ -r '.workerNodes|length')
        workers=$(cat $SILENT_CONFIG_FILE|$JQ -r '.workerNodes[].hostname')
        if [ -n "$workers" ]; then
            for w in $workers
            do
                validateFqdnIPFormat $w
            done
        fi

    fi
    if [[ "$masterNum" -ne 0 ]] && [[ "$masterNum" -ne 2 ]];then
        write_log "fatal" "If masterNodes is configured, the number of control plane nodes must be 0 or 2 in $SILENT_CONFIG_FILE."
    fi
    if [[ "$allowWorkerOnMaster" != "true" ]] && [[ "$workerNum" -eq 0 ]];then
        write_log "fatal" "No workload allowed on control plane nodes and no worker nodes specified. Must allow workload on control planes nodes or specify at least 1 worker node."
    fi

    local overlaps=$(echo "$THIS_NODE $masters $workers"|tr '[:upper:]' '[:lower:]'|xargs -n1|awk '{m[$0]++}END{for(k in m){if(m[k]>1)printf("%s ",k)}}')
    if [[ -n "$overlaps" ]];then
        write_log "fatal" "There should not be any overlap between the control plane nodes and worker nodes in $SILENT_CONFIG_FILE: $overlaps"
    fi

    if [[ -n "$HA_VIRTUAL_IP" ]] || [[ -n "$LOAD_BALANCER_HOST" ]];then
        if [[ "$masterNum" -eq 0 ]];then
            write_log "fatal" "If HA_VIRTUAL_IP/LOAD_BALANCER_HOST is configured, the number of control plane nodes must be 2 in $SILENT_CONFIG_FILE."
        fi
    else
        if [[ "$masterNum" -eq 2 ]];then
            write_log "fatal" "If HA_VIRTUAL_IP/LOAD_BALANCER_HOST is not configured, the number of control plane nodes must be 0 in $SILENT_CONFIG_FILE."
        fi
    fi
}

checkConfigJson(){
    checkCoreVolumesExist
    local level=
    # if first node, uncompress metadata package to destination.
    if [ -n "$METADATA" ]; then
        exec_cmd "mkdir -p ${TMP_FOLDER}/.metadata-tmp/suite-metadata && chmod 755 ${TMP_FOLDER}/.metadata-tmp/suite-metadata"
        level=$(exec_cmd "$TAR -tf ${METADATA} 2>/dev/null | awk -F/ '/suiteinfo.json/ {print NF}'" -p=true)
        if [ ! -z "$level" ]; then
            local metadata_dir="${TMP_FOLDER}/.metadata-tmp/suite-metadata"
            exec_cmd "$TAR -zxf ${METADATA} --strip-components $(($level-1)) -C ${metadata_dir}"
            if [ $? -ne 0 ]; then
                write_log "fatal" "The metadata package $METADATA does not have the correct internal structure. $LOG_SUPPORT_MSG" "failed"
            else
                checkConfigJsonByMetadata
            fi
            exec_cmd "$RM -rf ${TMP_FOLDER}/.metadata-tmp"
        else
            write_log "fatal" "The metadata package $METADATA does not have the correct internal structure. $LOG_SUPPORT_MSG" "failed"
        fi
    else
        checkConfigJsonForComm
    fi
}

checkVolsType(){
    local masterNum;masterNum=$(cat $SILENT_CONFIG_FILE|$JQ -r '.volumes|length')
    local n=0
    for (( n=0; n<num; n++ ));do
        local type=$(cat $SILENT_CONFIG_FILE|$JQ -r ".volumes[$n].type")
        if [[ "$type" != "NFS" ]] && [[ "$type" != "EFS" ]];then
            local name=$(cat $SILENT_CONFIG_FILE|$JQ -r ".volumes[$n].name")
            write_log "fatal" "The $name volume type is invalid. The volume type can only be NFS or EFS."
        fi
    done
}

checkAppHubHelmValues(){
    if [[ -n "$APPHUB_HELM_VALUES" ]];then
        if [[ -f "$APPHUB_HELM_VALUES" ]] && [[ "$APPHUB_HELM_VALUES" =~ ^/ ]];then
            ${CURRENTDIR}/bin/yq eval "$APPHUB_HELM_VALUES" 1>/dev/null 2>&1
            if [[ "$?" -ne 0 ]];then
                write_log "fatal" "Abort installation because '$APPHUB_HELM_VALUES' is not a valid yaml file. $(${CURRENTDIR}/bin/yq eval "$APPHUB_HELM_VALUES")"
            fi
            checkPvcAccessModes
            checkVolumeSizes
        else
            write_log "fatal" "Abort installation because the file set by'--apphub-helm-values' is not an absolute path."
        fi
    fi
    if [[ -z "$SILENT_CONFIG_FILE" ]] || [[ -n "$METADATA" ]];then
        # classic suite install
        if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]];then
            write_log "fatal" "If you want to install $PRODUCT_SHORT_NAME for classic suite, please don't set DeploymentManagement=false. If you want to install $PRODUCT_SHORT_NAME for helmified product, please add -c option."
        fi
    fi
}

checkDBConfig(){
    if [ -n "$SILENT_CONFIG_FILE" ]; then
        local hasDB=
        hasDB="$(exec_cmd "$JQ -r 'has(\"database\")' $SILENT_CONFIG_FILE" -p=true)"
        if [[ "$hasDB" == "false" ]];then
            return
        fi
        # external suitedb
        if [[ -n "$SUITEDB_URL" ]];then
            local type="$(getValueFromConfig '.database.type')"
            if [[ "$type" == "intpostgres" ]];then
                write_log "fatal" "Abort installation because silent installation does not support this case: idm uses an internal database, suiteDB uses an external database."
            fi
        fi
        local dbConnectionString=
        dbConnectionString="$(getValueFromConfig '.database.param.dbConnectionString')"
        if [[ -n "$dbConnectionString" ]] && [[ "$dbConnectionString" =~ " " ]];then
            write_log "fatal" "Abort installation because the '.database.param.dbConnectionString' in the configuration file '$SILENT_CONFIG_FILE' contains spaces."
        fi
        local dbType=
        dbType="$(getValueFromConfig '.database.type')"
        if [[ ! "$dbType" =~ ^(intpostgres|extpostgres|extoracle)$ ]];then
            write_log "fatal" "Invalid value for the '.database.type' in the configuration file '$SILENT_CONFIG_FILE': ${dbType:-'<empty>'}, allowed values: intpostgres,extpostgres,extoracle."
        fi

        local non_space_attrs="
        .database.param.dbHost
        .database.param.dbPort
        .database.param.dbSid
        .database.param.dbName
        .database.param.dbSchema
        .database.param.dbOrcway
        .database.param.dbUser
        .database.param.dbCert
        "
        local val=
        for attr in $non_space_attrs;do
            val="$(getValueFromConfig "${attr} // empty")"
            if [[ -n "$val" ]] && [[ "$val" =~ " " ]];then
                write_log "fatal" "Abort installation because the '${attr}' in the configuration file '$SILENT_CONFIG_FILE' contains spaces."
            fi
        done
    fi
}

checkConfigJsonSchema(){
    if [[ -z "$SILENT_CONFIG_FILE" ]];then
        return
    fi

    if [[ "$(isEnabledByTaskName "pv")" == "true" ]];then
        # PV-CDF
        checkMandatoryVols
        checkVolsType
    fi

    write_log "debug" "Check nonprinting: $(awk '/\xe2\x80\x8b/ || /\xe2\x80\x8c/ || /\xe2\x80\x8d/{print "Line:"NR}' $SILENT_CONFIG_FILE)"

    local masterNum;masterNum=$(cat $SILENT_CONFIG_FILE|$JQ -r '.masterNodes|length')
    local workerNum;workerNum=$(cat $SILENT_CONFIG_FILE|$JQ -r '.workerNodes|length')
    local attr_configs="
    .skipImageCheck
    .masterNodes[__index__].skipResourceCheck/$masterNum
    .masterNodes[__index__].skipWarning/$masterNum
    .workerNodes[__index__].skipResourceCheck/$workerNum
    .workerNodes[__index__].skipWarning/$workerNum
    .allowWorkerOnMaster
    .licenseAgreement.eula
    .licenseAgreement.callHome
    "
    local val_type
    local last
    local num
    local attr
    for data_attr in $(echo $attr_configs|xargs -n1);do
        num=$(echo $data_attr|awk -F/ '{print $2}')
        num=${num:-1}
        if [[ "$num" -eq 0 ]];then
            continue
        fi
        last=$((num-1))
        for index in $(seq 0 $last);do
            attr=$(echo $data_attr|awk -F/ '{print $1}'|sed -e "s/__index__/${index}/")
            val_type=$(cat $SILENT_CONFIG_FILE|$JQ -r "[${attr}]|map(type)|.[0]")
            if [[ $val_type != "null" ]] && [[ $val_type != "boolean" ]];then
                write_log "fatal" "$SILENT_CONFIG_FILE: \"$attr\" is invalid data type, it should be a boolean type."
            fi
        done
    done

    local result;result=$(cat $SILENT_CONFIG_FILE|$JQ -r '.connection.externalHostname')
    if [[ -z "$result" ]] || [[ "$result" == "null" ]];then
        return
    fi
    echo "$result"|grep -Pq '^[a-zA-Z0-9-.]+$'
    if [[ $? -ne 0 ]];then
        write_log "fatal" "$SILENT_CONFIG_FILE: .\"connection\".\"externalHostname\" is invalid."
    fi

    checkDBConfig
}

# This Function checks volumes required by some features based on feature-gates
checkVolsForFeature(){
    # feature-gate key
    local feature_to_check=$1; shift 1
    # mandatory volume's names string splitted by space
    local mandatory_vols=""
    while [ $# -gt 0 ]; do
        local tmp=$1; shift 1
        mandatory_vols="$mandatory_vols $tmp"
    done

    if checkFeatureEnabled "$feature_to_check"; then
        local config_json;config_json=$(cat $SILENT_CONFIG_FILE)

        write_log "step" "Verifying silent config for feature ${feature_to_check}"
        # mandatory vols must exist in silent config json
        for mandatory_vol in $mandatory_vols;do
            local find_vol;find_vol=$(echo $config_json|$JQ -r '.volumes[]|select(.name=="'$mandatory_vol'")|.name' 2>/dev/null)
            if [[ "$find_vol" != "$mandatory_vol" ]];then
                showStatus "error"
                write_log "fatal" "A volume named '${mandatory_vol}' is mandatory for ${feature_to_check} in the 'volumes' field, we did not find this volume in the configuration file \"${SILENT_CONFIG_FILE}\""
            fi
        done

        # No need to check NFS connection because pre-check will handle all volume connection check
        # local volume_info=
        # local volume_name=
        # local ext_opts='-e'
        # local count;count=$(echo ${config_json} | $JQ '.volumes|length')
        # local n=0
        # while [[ $n -lt $count ]];
        # do
        #     volume_info=$(echo $config_json|$JQ -r ".volumes[$n]")
        #     volume_name=$(echo ${volume_info} | $JQ -r ".name")
        #     elementExistInArray "${volume_name}" "${mandatory_vols}"
        #     # only check feature-gates vols
        #     if [[ $? -eq 0 ]];then
        #         checkVolumesFromJson "$volume_info" "$ext_opts"
        #     fi
        #     n=$((n+1))
        # done
        showStatus "ok"
    fi
}

checkFeatureGatesSilentVols(){
    if [[ -z "$SILENT_CONFIG_FILE" ]];then
        return
    fi

    # multiple mandatory volume names can be splitted by space in a single string
    # For example "vols": "vol1 vol2 vol3"
    local vols_json='[
    {
        "feature": "Prometheus",
        "vols": "itom-monitor-vol"
    }
]'

    local fg_set=
    local fg_name=
    local fg_vols=
    local n=0
    local count;count=$(echo ${vols_json} | $JQ '.|length')
    while [[ $n -lt $count ]];
    do
        fg_set=$(echo ${vols_json}|$JQ -r ".[$n]")
        fg_name=$(echo ${fg_set} | $JQ -r ".feature")
        fg_vols=$(echo ${fg_set} | $JQ -r ".vols")
        n=$((n+1))
        checkVolsForFeature "${fg_name}" "${fg_vols}"
    done
}

createEtcdClientCertSecret(){
    local secretName="etcd-client-cert"
    write_log "step" "Create $secretName secret ..."
    if stepNotDone $FUNCNAME; then
        local reTryTimes=0
        while true;do
            if [ $(exec_cmd "kubectl get secret ${secretName} -n ${CDF_NAMESPACE}"; echo $?) -eq 0 ]; then
                write_log "debug" "$secretName secret already exists"
            else
                exec_cmd "kubectl create secret generic ${secretName} -n ${CDF_NAMESPACE} \\
                    --from-file=common-etcd-client.crt=$CDF_HOME/ssl/common-etcd-client.crt \\
                    --from-file=common-etcd-client.key=$CDF_HOME/ssl/common-etcd-client.key "
                if [ $? -eq 0 ]; then
                    write_log "debug" "Create ${secretName} secret successfully."
                    break
                elif [ $reTryTimes -eq $RETRY_TIMES ]; then
                    write_log "fatal" "Failed to create secret:${secretName}. $LOG_SUPPORT_MSG" "failed"
                else
                    write_log "debug" "Failed to create secret:${secretName}. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                fi
                reTryTimes=$(( $reTryTimes + 1 ))
                sleep $SLEEP_TIME
            fi
        done
        setStepDone $FUNCNAME
        showStatus "ok"
    else
        showStatus "Already done"
    fi
}

#create pki secret not checking ns, so we must put it after ns create
createCdfPkiSecret(){
    CA_FOLDER=$HOME/cdf-pki
    if [ -d "$CA_FOLDER" ] && [ -r "$CA_FOLDER/cdf_ca.key" ] && [ -r "$CA_FOLDER/cdf_ca.crt" ];then
        local secretName="cdf-pki"
        write_log "step" "Create PKI secret ..."
        if stepNotDone $FUNCNAME; then
            local reTryTimes=0
            while true;do
                if [ $(exec_cmd "kubectl get secret ${secretName} -n ${CDF_NAMESPACE}"; echo $?) -eq 0 ]; then
                    write_log "debug" "$secretName secret already exists"
                    local secretJson ca_key ca_cert
                    secretJson=$(exec_cmd "kubectl get secret ${secretName} -n ${CDF_NAMESPACE} -o json" -p true)
                    ca_key=$(echo "$secretJson" | jq -r '.data.cdf_ca.key?')
                    ca_cert=$(echo "$secretJson" | jq -r '.data.cdf_ca.crt?')
                    if ([ -n "$ca_key" ] && [ "$ca_key" != "null" ]) || ([ -n "$ca_cert" ] && [ "$ca_cert" != "null" ]); then
                        write_log "debug" "cdf_ca.crt/cdf_ca.key already exists"
                        setStepDone $FUNCNAME
                        showStatus "Already done"
                    else
                        exec_cmd "kubectl patch secret ${secretName} -n ${CDF_NAMESPACE} --patch='{\"data\": { \"cdf_ca.key\": \"$(base64 -w0 $CA_FOLDER/cdf_ca.key)\",\"cdf_ca.crt\": \"$(base64 -w0 $CA_FOLDER/cdf_ca.crt)\"  }}'"
                        if [ $? -eq 0 ]; then
                            write_log "debug" "Update ${secretName} secret successfully."
                            break
                        elif [ $reTryTimes -eq $RETRY_TIMES ]; then
                            write_log "fatal" "Failed to update secret:${secretName}. $LOG_SUPPORT_MSG" "failed"
                        else
                            write_log "debug" "Failed to update secret:${secretName}. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                        fi
                        reTryTimes=$(( $reTryTimes + 1 ))
                        sleep $SLEEP_TIME
                    fi
                else
                    exec_cmd "kubectl create secret generic ${secretName} -n ${CDF_NAMESPACE} \\
                        --from-file=cdf_ca.crt=$CA_FOLDER/cdf_ca.crt \\
                        --from-file=cdf_ca.key=$CA_FOLDER/cdf_ca.key "
                    if [ $? -eq 0 ]; then
                        write_log "debug" "Create ${secretName} secret successfully."
                        break
                    elif [ $reTryTimes -eq $RETRY_TIMES ]; then
                        write_log "fatal" "Failed to create secret:${secretName}. $LOG_SUPPORT_MSG" "failed"
                    else
                        write_log "debug" "Failed to create secret:${secretName}. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                    fi
                    reTryTimes=$(( $reTryTimes + 1 ))
                    sleep $SLEEP_TIME
                fi
            done
            setStepDone $FUNCNAME
            showStatus "ok"
        else
            showStatus "Already done"
        fi
    fi
}

createRegistrypullSecret(){
    write_log "step" "Create image pull secret ..."
    if stepNotDone $FUNCNAME; then
        local local_auth;local_auth=$(echo -n "${INTERNAL_KUBE_REGISTRY_READER_USERNAME}:${INTERNAL_KUBE_REGISTRY_READER_PWD}"|base64 -w0)
        if [[ -z "$REGISTRY_USERNAME" ]];then
            REGISTRY_PASSWORD=
        fi
        if [[ -z "$REGISTRY_PASSWORD" ]];then
            REGISTRY_USERNAME=
        fi
        local external_auth;external_auth=$(echo -n "${REGISTRY_USERNAME}:${REGISTRY_PASSWORD}"|base64 -w0)
        local json="{}"
        if [ "$DOCKER_REPOSITORY" == "localhost:5000" ];then
            json="{
                \"auths\": {
                    \"localhost:5000\": {
                        \"auth\": \"${local_auth}\"
                    }
                }
            }"
        elif [ -n "$REGISTRY_USERNAME" ] && [ -n "$REGISTRY_PASSWORD" ];then
            if [ "$INSTALLED_TYPE" = "CLASSIC" ];then
                json="{
                    \"auths\": {
                        \"localhost:5000\": {
                            \"auth\": \"${local_auth}\"
                        },
                        \"${DOCKER_REPOSITORY}\": {
                            \"auth\": \"${external_auth}\"
                        }
                    }
                }"
            else
                json="{
                    \"auths\": {
                        \"${DOCKER_REPOSITORY}\": {
                            \"auth\": \"${external_auth}\"
                        }
                    }
                }"
            fi
        elif [ -z "$REGISTRY_USERNAME" ] && [ -z "$REGISTRY_PASSWORD" ];then
            json="{
                \"auths\": {
                    \"localhost:5000\": {
                        \"auth\": \"${local_auth}\"
                    },
                    \"${DOCKER_REPOSITORY}\": {
                        \"auth\": \"\"
                    }
                }
            }"
        else
            write_log "fatal" "Failed to create registry pull secret for external registry ($DOCKER_REPOSITORY:$REGISTRY_USERNAME:$REGISTRY_PASSWORD). $LOG_SUPPORT_MSG" "failed"
        fi
        json=$(echo -n "${json}"|base64 -w0)
        local name="registrypullsecret"
        if [ $INSTALLED_TYPE = "BYOK" ]; then
          # BYOK: no need to create the registrypullsecret under kube-system ns
          local nss="${CDF_NAMESPACE}"
        else
          local nss="${CDF_NAMESPACE} kube-system"
        fi

        for ns in $nss
        do
            if ! exec_cmd "kubectl get secret ${name} -n ${ns}"; then
              local reTryTimes=0
              while true; do
                exec_cmd "echo '
apiVersion: v1
type: kubernetes.io/dockerconfigjson
kind: Secret
metadata:
  name: ${name}
  namespace: ${ns}
  labels:
    deployments.microfocus.com/cleanup: uninstall
data:
  .dockerconfigjson: \"${json}\"
              '|kubectl create --save-config -f -"
                if [ $? -eq 0 ] || [ $(exec_cmd "kubectl get secret ${name} -n ${ns}"; echo $?) -eq 0 ] ; then
                  write_log "debug" "create secret:${name} successfully."
                  break
                elif [ $reTryTimes -eq $RETRY_TIMES ]; then
                  write_log "fatal" "Failed to create secret:${name}. $LOG_SUPPORT_MSG" "failed"
                else
                  write_log "debug" "Failed to create secret:${name}. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                fi
                reTryTimes=$(( $reTryTimes + 1 ))
                sleep $SLEEP_TIME
              done
            fi
        done

        setStepDone $FUNCNAME
        showStatus "ok"
    else
        showStatus "Already done"
    fi
}

replaceCdfDeployer() {
    local file=$1
    write_log "debug" "Injecting the configuration values into ${file} ..."
    sed -i -e "s@{API_VERSION}@$INSTALLED_TYPE@g" $file
    sed -i -e "s@{K8S_INSTALL_MODE}@$INSTALLED_TYPE@g" $file
    # sed -i -e "s@{ACTION_MODE}@$ACTION_MODE@g" $file
    sed -i -e "s@{SYSTEM_USER_ID}@$SYSTEM_USER_ID@g" $file
    sed -i -e "s@{SYSTEM_GROUP_ID}@$SYSTEM_GROUP_ID@g" $file
    sed -i -e "s@{CDF_NAMESPACE}@$CDF_NAMESPACE@g" $file

    sed -i -e "s@{NFS_SERVER}@$NFS_SERVER@g" $file
    sed -i -e "s@{NFS_FOLDER}@$NFS_FOLDER@g" $file
    sed -i -e "s@{REGISTRY_ORGNAME}@${REGISTRY_ORGNAME}@g" $file
    sed -i -e "s@{IMAGE_ITOM_CDF_DEPLOYER}@${IMAGE_ITOM_CDF_DEPLOYER}@g" $file
    sed -i -e "s@{EXTERNAL_ACCESS_HOST}@${EXTERNAL_ACCESS_HOST}@g" $file
    sed -i -e "s@{CLOUD_PROVIDER}@${CLOUD_PROVIDER}@g" $file
    sed -i -e "s@{K8S_PROVIDER}@${K8S_PROVIDER}@g" $file
    sed -i -e "s@{ALICLOUD_LOADBALANCER_ID}@${LOADBALANCER_ID}@g" $file
    sed -i -e "s@{LOADBALANCER_IP}@${LOADBALANCER_IP}@g" $file
    sed -i -e "s@{LOADBALANCER_INFO}@${LOADBALANCER_INFO}@g" $file
    sed -i -e "s@{ENABLE_FIPS}@${ENABLE_FIPS}@g" $file
    sed -i -e "s@{CDF_ADMIN_TASKS}@${CDF_ADMIN_TASKS}@g" $file
    sed -i -e "s@{DEFAULT_STORAGE_CLASS}@${DEFAULT_STORAGE_CLASS}@g" $file
    sed -i -e "s@{LOGGING_VOL_SIZE}@${LOGGING_VOL_SIZE}@g" $file
    sed -i -e "s@{DEPLOYER_JOB_TAG}@${DEPLOYER_JOB_TAG}@g" $file
    sed -i -e "s@{DEPLOYMENT_NAME}@${DEPLOYMENT_NAME}@g" $file
    sed -i -e "s@{DEPLOYMENT_TYPE}@${DEPLOYMENT_TYPE}@g" $file
    sed -i -e "s@{HEML_DEPLOYMENT}@${HEML_DEPLOYMENT}@g" $file
    sed -i -e "s@{CDF_PHASE}@1.2@g" $file
    sed -i -e "s@{CLUSTER_NAME}@${CLUSTER_NAME}@g" $file
    sed -i -e "s%{PRIMARY_NAMESPACE}%${PRIMARY_NAMESPACE}%g" $file
    sed -i -e "s%{INGRESS_SSL_PORT}%${EXTERNAL_ACCESS_PORT}%g" $file
    sed -i -e "s%{INGRESS_2WAY_SSL_PORT}%${INGRESS_2WAY_SSL_PORT}%g" $file
    sed -i -e "s@{MASTERNODE_TIME_ZONE}@${TZ}@g" $file
    sed -i -e "s@{PLATFORM_VERSION}@${PLATFORM_VERSION}@g" $file
    sed -i -e "s@{SET_FQDN_IN_INGRESS}@${SET_FQDN_IN_INGRESS}@g" $file
    sed -i -e "s@{PERSISTENCE_ACCESS_MODE}@${PERSISTENCE_ACCESS_MODE}@g" $file
    sed -i -e "s@{DATA_VOLUME_SIZE}@${CUS_DATA_VOLUME_SIZE:-"5Gi"}@g" $file

    if [ "$INSTALLED_TYPE" = "CLASSIC" ];then
        sed -i -e "s@{SUITE_NAME}@$SUITE_NAME@g" $file
        sed -i -e "s@{ETCD_ENDPOINT}@${ETCD_ENDPOINT}@g" $file
        sed -i -e "s@{K8S_HOME}@${CDF_HOME}@g" $file
        sed -i -e "s@{CDF_HOME}@${CDF_HOME}@g" $file
        sed -i -e "s@{DEPLOYMENT_LOG_LOCATION}@${DEPLOYMENT_LOG_LOCATION}@g" $file
        sed -i -e "s@{REGISTRY_URL}@${DOCKER_REPOSITORY}@g" $file
    else
        sed -i -e "s@{SUITE_NAME}@itsma@g" $file
        sed -i -e "s@{ETCD_ENDPOINT}@@g" $file
        sed -i -e "s@{K8S_HOME}@@g" $file
        sed -i -e "s@{CDF_HOME}@@g" $file
        sed -i -e "s@{DEPLOYMENT_LOG_LOCATION}@@g" $file
        sed -i -e "s@{REGISTRY_URL}@${DOCKER_REPOSITORY}@g" $file
        sed -i -e "s@{EXTERNAL_ACCESS_PORT}@@g" $file
    fi
}

deployYamlFileForBYOK(){
    yamlFile=$1
    local reTryTimes=0
    while true; do
        if [ $(exec_cmd "kubectl describe -f $yamlFile" -o=false; echo $?) -eq 0 ]
        then
            write_log "debug" "Successfully deployed YAML: $yamlFile"
            break
        else
            exec_cmd "kubectl create --save-config -f $yamlFile" && break
            reTryTimes=$(( $reTryTimes + 1 ))
            if [ $reTryTimes -ge 5 ]; then
                write_log "fatal" "Failed to deploy yaml file $yamlFile. $LOG_SUPPORT_MSG" "failed"
            else
                write_log "debug" "Failed to deploy yaml file $yamlFile. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
            fi
        fi
        sleep $SLEEP_TIME
    done
}

scaleVault(){
  if [ "$INSTALLED_TYPE" = "CLASSIC" -a "$NODE_TYPE" = "master" ];then
    if stepNotDone $FUNCNAME; then
      write_log "step" "Scale itom-vault deployment replica to 2 ..."
      local reTryTimes=0
      while true; do
          if exec_cmd "kubectl patch deployment itom-vault --patch '{\"metadata\":{\"annotations\": {\"deployment.microfocus.com/default-replica-count\": \"2\"}}}' -n ${CDF_NAMESPACE} && kubectl scale --replicas=2 deployment/itom-vault -n ${CDF_NAMESPACE}"; then
            break;
          elif [ $reTryTimes -eq $RETRY_TIMES ]; then
            write_log "fatal" "Failed to scale itom-vault deployment. $LOG_SUPPORT_MSG" "failed"
          else
            write_log "debug" "Failed to scale itom-vault deployment. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
          fi
          reTryTimes=$(( $reTryTimes + 1 ))
          sleep $SLEEP_TIME
      done
      setStepDone $FUNCNAME
      showStatus "ok"
    else
      showStatus "Already done"
    fi
  fi
}

scaleKubeRegistry(){
    local masterNum=$(exec_cmd "kubectl get nodes --selector=$NODESELECT_ARG --no-headers 2>/dev/null|wc -l" -p=true)
    if [ "$INSTALLED_TYPE" = "CLASSIC" -a "$NODE_TYPE" = "master" -a "$masterNum" -eq 3 ];then
        if stepNotDone $FUNCNAME; then
            local componentName=kube-registry
            write_log "step" "Scale $componentName deployment replica to 3 ..."
            local originValues="$TMP_FOLDER/.cdf_chart_kube_registry_origin.json"
            local upgradeValues="$TMP_FOLDER/.cdf_chart_kube_registry_upgrade.json"
            local reTryTimes=0
            exec_cmd "${CDF_HOME}/bin/helm get values $componentName -n $CDF_NAMESPACE -o json > $originValues"
            while true; do
                exec_cmd "$JQ -r '.deployment.replicas=3' $originValues > $upgradeValues"
                exec_cmd "${CDF_HOME}/bin/helm upgrade --debug --install $componentName \
                    $CDF_HOME/charts/${CHART_ITOM_KUBE_REGISTRY} \
                    -f $upgradeValues -n $CDF_NAMESPACE --wait --timeout 15m"
                if [ $? -eq 0 ];then
                    break;
                elif [ "$reTryTimes" -eq "$RETRY_TIMES" ]; then
                    write_log "fatal" "Failed to scale $componentName deployment. $LOG_SUPPORT_MSG" "failed"
                else
                    write_log "debug" "Failed to scale $componentName deployment. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                fi
                reTryTimes=$(( $reTryTimes + 1 ))
                sleep $SLEEP_TIME
            done
            exec_cmd "$RM -f $originValues"
            exec_cmd "$RM -f $upgradeValues"
            setStepDone $FUNCNAME
            showStatus "ok"
        else
            showStatus "Already done"
        fi
    fi
}

checkComponentDeploymentStatus(){
    local release_name=$1
    local helm_status=$(exec_cmd "(${CDF_HOME}/bin/helm list -n ${CDF_NAMESPACE} -o json 2>>$LOG_FILE || echo 'ERROR')|$JQ -r '.[]|select(.name==\"$release_name\").status'" -p=true)
    if [[ "$helm_status" == "failed" ]];then
        write_log "fatal" "Failed to start up $release_name. $LOG_SUPPORT_MSG" "failed"
    fi
    if [[ "$helm_status" != "deployed" ]];then
        return 1
    fi
    local helm_name=
    local deployments=
    deployments=$(exec_cmd "(kubectl get deployment -n ${CDF_NAMESPACE} -o json 2>>$LOG_FILE || echo 'ERROR')|$JQ -r '.items[].metadata.name'" -p=true)
    if [[ $? -ne 0 ]];then
        return 1
    fi
    for dep in $deployments;do
        helm_name=$(exec_cmd "(kubectl get deployment $dep -n ${CDF_NAMESPACE} -o json 2>>$LOG_FILE || echo 'ERROR')|$JQ -r '.metadata.annotations.\"meta.helm.sh/release-name\"'" -p=true)
        if [[ $? -ne 0 ]];then
            return 1
        fi
        if [[ "$helm_name" == "$release_name" ]];then
            local status=
            status=$(exec_cmd "(kubectl get deployment $dep -n ${CDF_NAMESPACE} -o json 2>>$LOG_FILE || echo 'ERROR')|$JQ -r '.status' 2>>$LOG_FILE" -p=true)
            if [[ $? -ne 0 ]];then
                return 2
            fi
            local availableReplicas readyReplicas replicas updatedReplicas unavailableReplicas
            availableReplicas=$(echo $status|$JQ -r '.availableReplicas + 0')
            readyReplicas=$(echo $status|$JQ -r '.readyReplicas + 0')
            replicas=$(echo $status|$JQ -r '.replicas + 0')
            updatedReplicas=$(echo $status|$JQ -r '.updatedReplicas + 0')
            unavailableReplicas=$(echo $status|$JQ -r '.unavailableReplicas + 0')
            if [ "$availableReplicas" = "$readyReplicas" -a "$availableReplicas" = "$replicas" -a "$availableReplicas" = "$updatedReplicas" -a "$unavailableReplicas" -eq 0 ]; then
                :
            else
                write_log "debug" "Component's deployment (${CDF_NAMESPACE}/deployment/$dep) is not running. Wait ..."
                return 2
            fi
        fi
    done
    local daemonsets=
    daemonsets=$(exec_cmd "(kubectl get daemonset -n ${CDF_NAMESPACE} -o json 2>>$LOG_FILE || echo 'ERROR')|$JQ -r '.items[].metadata.name'" -p=true)
    if [[ $? -ne 0 ]];then
        return 1
    fi
    for ds in $daemonsets;do
        helm_name=$(exec_cmd "(kubectl get daemonset $ds -n ${CDF_NAMESPACE} -o json 2>>$LOG_FILE || echo 'ERROR')|$JQ -r '.metadata.annotations.\"meta.helm.sh/release-name\"'" -p=true)
        if [[ $? -ne 0 ]];then
            return 1
        fi
        if [[ "$helm_name" == "$release_name" ]];then
            local status=
            status=$(exec_cmd "(kubectl get daemonset $ds -n ${CDF_NAMESPACE} -o json 2>>$LOG_FILE || echo 'ERROR')|$JQ -r '.status' 2>/dev/null" -p=true)
            if [[ $? -ne 0 ]];then
                return 2
            fi
            local desiredNumberScheduled currentNumberScheduled numberReady updatedNumberScheduled numberAvailable numberUnavailable
            desiredNumberScheduled=$(echo $status|$JQ -r '.desiredNumberScheduled + 0')
            currentNumberScheduled=$(echo $status|$JQ -r '.currentNumberScheduled + 0')
            numberReady=$(echo $status|$JQ -r '.numberReady + 0')
            updatedNumberScheduled=$(echo $status|$JQ -r '.updatedNumberScheduled + 0')
            numberAvailable=$(echo $status|$JQ -r '.numberAvailable + 0')
            numberUnavailable=$(echo $status|$JQ -r '.numberUnavailable + 0')
            if [ "$desiredNumberScheduled" = "$currentNumberScheduled" -a "$desiredNumberScheduled" = "$numberReady" -a "$desiredNumberScheduled" = "$updatedNumberScheduled" -a "$desiredNumberScheduled" = "$numberAvailable" -a "$numberUnavailable" -eq 0 ]; then
                :
            else
                write_log "debug" "Component's daemonset (${CDF_NAMESPACE}/daemonset/$ds) is not running. Wait ..."
                return 2
            fi
        fi
    done
    local statefulsets=
    statefulsets=$(exec_cmd "(kubectl get statefulsets -n ${CDF_NAMESPACE} -o json 2>>$LOG_FILE || echo 'ERROR')|$JQ -r '.items[].metadata.name'" -p=true)
    if [[ $? -ne 0 ]];then
        return 1
    fi
    for sts in $statefulsets;do
        helm_name=$(exec_cmd "(kubectl get statefulsets $sts -n ${CDF_NAMESPACE} -o json 2>>$LOG_FILE || echo 'ERROR')|$JQ -r '.metadata.annotations.\"meta.helm.sh/release-name\"'" -p=true)
        if [[ $? -ne 0 ]];then
            return 1
        fi
        if [[ "$helm_name" == "$release_name" ]];then
            local status=
            status=$(exec_cmd "(kubectl get statefulsets $sts -n ${CDF_NAMESPACE} -o json || echo 'ERROR')|$JQ -r '.status' 2>/dev/null" -p=true)
            if [[ $? -ne 0 ]];then
                return 2
            fi
            local currentReplicas readyReplicas replicas updatedReplicas
            currentReplicas=$(echo $status|$JQ -r '.currentReplicas + 0')
            readyReplicas=$(echo $status|$JQ -r '.readyReplicas + 0')
            replicas=$(echo $status|$JQ -r '.replicas + 0')
            updatedReplicas=$(echo $status|$JQ -r '.updatedReplicas + 0')
            if [ "$currentReplicas" = "$readyReplicas" -a "$currentReplicas" = "$replicas" -a "$currentReplicas" = "$updatedReplicas" ]; then
                :
            else
                write_log "debug" "Component's statefulsets (${CDF_NAMESPACE}/statefulsets/$sts) is not running. Wait ..."
                return 2
            fi
        fi
    done
    return 0
}

checkComponentPodsStatus(){
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]] && [[ "$CAPS_CLUSTER_MANAGEMENT" == "false" ]] && [[ "$CAPS_LOG_COLLECTION" == "false" ]] && [[ "$CAPS_MONITORING" == "false" ]] && [[ "$CAPS_MONITORING_CONTENT" == "false" ]];then
        return
    fi
    write_log "step" "Check component's pods status ..."
    if stepNotDone $FUNCNAME; then
        local reTryTimes=0
        local totalTimes=3600
        while true;do
            checkComponentDeploymentStatus "$CDF_HELM_RELEASE_NAME"
            if [ $? -eq 0 ];then
                break
            fi
            if [ "$reTryTimes" -eq "$totalTimes" ]; then
                write_log "fatal" "A timeout occurred while waiting for some component's deployments to running. $LOG_SUPPORT_MSG" "failed"
            else
                write_log "debug" "Component's deployments are not running. Wait for $totalTimes seconds and recheck: $reTryTimes"
            fi
            reTryTimes=$(( $reTryTimes + 1 ))
            sleep 1
        done

        setStepDone $FUNCNAME
        showStatus "ok"
    else
        showStatus "Already done"
    fi
}

nfsServerIsThisNode(){
    local nfs_server="${NFS_SERVER:-"$NFS_PROV_SERVER"}"
    if [[ $nfs_server =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]];then
        [ "$nfs_server" = "$LOCAL_IP" ] && echo "true" || echo "false"
    else
        if [ "$(echo $nfs_server|tr [:upper:] [:lower:])" = "$(echo $THIS_NODE|tr [:upper:] [:lower:])" ]; then
            echo "true"
        else
            local nfs_ip=
            nfs_ip=$(grep -v '^\s*#' /etc/hosts  2>/dev/null | grep -i $nfs_server|awk '{print $1}')
            if [ "$nfs_ip" = "$LOCAL_IP" ]; then
                echo "true"
            elif [ -z "$nfs_ip" ]; then
                nfs_ip=$(nslookup $nfs_server 2>/dev/null|grep -v '#'|grep 'Address: '|awk '{print $2}')
                [ "$nfs_ip" = "$LOCAL_IP" ] && echo "true" || echo "false"
            else
                echo "false"
            fi
        fi
    fi
}

configNfsFirewallSettings(){
    if [ $(systemctl status firewalld >/dev/null 2>&1; echo $?) -eq 0 -a "$AUTO_CONFIGURE_FIREWALL" = "true" -a "$(nfsServerIsThisNode)" = "true" ]; then
        local nfsPorts="111/tcp
                        111/udp
                        2049/tcp
                        2049/udp
                        20048/tcp
                        20048/udp
                        20049/tcp
                        20049/udp"
        local failedPorts=$(firewalldAddPorts "${nfsPorts[*]}")
        [ -n "$failedPorts" ] && write_log "fatal" "This node is the NFS server and the firewall service is running; we failed to configure the firewall settings for NFS server automatically. Please refer to the $PRODUCT_INFRA_NAME Administration guide for firewall setup guidance." "failed"
    fi
}

tipsForFixVols(){
    echo "You can try to modify the configuration file ($SILENT_CONFIG_FILE) to fix this error, then rerun install"
}

checkVolumesFromJson(){
    if [ -z "$NFS_SERVER" ];then
        return
    fi
    local volume_info=$1
    local ext_opts="$2"
    local nfs_server;nfs_server=$(echo ${volume_info} | $JQ -r ".host")
    local nfs_folder;nfs_folder=$(echo ${volume_info} | $JQ -r ".path")
    local nfs_type;nfs_type=$(echo ${volume_info} | $JQ -r ".type"|tr '[:upper:]' '[:lower:]')
    if [[ -z "$nfs_server" ]] || [[ -z "$nfs_folder" ]];then
        write_log "fatal" "The config file '$SILENT_CONFIG_FILE' does not have the correct internal structure.\n${volume_info}"
    fi
    local tmp_error_msg_log="${TMP_FOLDER}/.check_vol_nfs_error_msg"
    local count=0
    local total_count=5
    while true;
    do
        timeout 30 $CURRENTDIR/scripts/checkNFS.sh --persistence-threshold ${PERSISTENCE_THREHOLD} -t ${nfs_type} -s ${nfs_server} -f ${nfs_folder} -u ${SYSTEM_USER_ID} -g ${SYSTEM_GROUP_ID} ${ext_opts} 1>${tmp_error_msg_log} 2>&1
        local return_code=$?
        if [[ $return_code -ne 0 ]]; then
            if [[ $count -ge $total_count ]];then
                if [[ $return_code == 124 ]];then
                    write_log "fatal" "Check NFS \"${nfs_server}:${nfs_folder}\" timeout. $MSG_NFS_ISSUE_TIPS"
                else
                    local checkNfsTips=""
                    if grep -q 'cannot mount' $tmp_error_msg_log 2>/dev/null;then
                        checkNfsTips="$MSG_NFS_ISSUE_TIPS"
                    fi
                    write_log "fatal" "Check NFS \"${nfs_server}:${nfs_folder}\" error: \n$(cat $tmp_error_msg_log)\nThere is an invalid volume in the configuration file \"${SILENT_CONFIG_FILE}\": \n${volume_info}\n$checkNfsTips\n$(tipsForFixVols)."
                fi
            fi
        else
            if grep 'Warning:' $tmp_error_msg_log 1>/dev/null 2>&1;then
                write_log "warn" "$(grep 'Warning:' $tmp_error_msg_log)"
            fi
            break
        fi
        sleep 5
        count=$((count+1))
    done
}

checkConfigJsonForComm(){
    if [[ "$(isEnabledByTaskName "pv")" == "false" ]];then
        # bosun: PV-ADMIN skip
        return
    fi
    local config_json;config_json=$(cat $SILENT_CONFIG_FILE)
    # check NFS connection
    local volume_info=
    local volume_name=
    local ext_opts=
    local count;count=$(echo ${config_json} | $JQ '.volumes|length')
    local n=0
    while [[ $n -lt $count ]];
    do
        volume_info=$(echo $config_json|$JQ -r ".volumes[$n]")
        checkVolumesFromJson "$volume_info"
        n=$((n+1))
    done
}

checkMandatoryVols(){
    local config_json;config_json=$(cat $SILENT_CONFIG_FILE)
    local mandatory_vols=""
    if [[ "$CAPS_LOG_COLLECTION" == "true" ]] || [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ]] || [[ "$CAPS_CLUSTER_MANAGEMENT" == "true" ]];then
        mandatory_vols="itom-logging-vol"
    fi
    if [[ "$CAPS_MONITORING" == "true" ]];then
        mandatory_vols="$mandatory_vols itom-monitor-vol itom-logging-vol"
    fi
    for mandatory_vol in $mandatory_vols;do
        local find_vol;find_vol=$(echo $config_json|$JQ -r '.volumes[]|select(.name=="'$mandatory_vol'")|.name' 2>/dev/null)
        if [[ "$find_vol" != "$mandatory_vol" ]];then
            write_log "fatal" "A volume named '${mandatory_vol}' is mandatory for cluster in the 'volumes' field, we did not find this volume in the configuration file \"${SILENT_CONFIG_FILE}\""
        fi
    done
}

checkConfigJsonForHelm(){
    if [[ "$(isEnabledByTaskName "pv")" == "false" ]];then
        # helm/bosun: PV-ADMIN skip
        return
    fi
    local config_json;config_json=$(cat $SILENT_CONFIG_FILE)
    # check NFS connection
    local volume_info=
    local volume_name=
    local ext_opts=
    local count;count=$(echo ${config_json} | $JQ '.volumes|length')
    local n=0
    while [[ $n -lt $count ]];
    do
        volume_info=$(echo $config_json|$JQ -r ".volumes[$n]")
        volume_name=$(echo ${volume_info} | $JQ -r ".name")
        elementExistInArray "${volume_name}" "${mandatory_vols}"
        if [[ $? -eq 0 ]];then
            ext_opts='-e'
        else
            ext_opts=''
        fi
        if [[ "${volume_name}" == "itom-vol-claim" ]];then
            # for re-run
            ext_opts=''
        fi
        checkVolumesFromJson "$volume_info" "$ext_opts"
        n=$((n+1))
    done
}

createDbCertsMergeFile(){
    local dbcert=$1
    local file=$2
    local dbcerts=${dbcert//,/ }  #we declared in the doc that certs are dilimitered by comma
    exec_cmd "$RM -f $file"
    for cert in ${dbcerts};do
        local val="$cert"
        if [[ "${cert:0:1}" != "/" ]];then
            val="$(dirname "$SILENT_CONFIG_FILE")/$cert"
        fi
        if [[ ! -f "$val" ]];then
            write_log "fatal" "Cannot connect to database, please check parameters in '$SILENT_CONFIG_FILE': the 'dbCert' file: $cert does not exist."
        fi
        exec_cmd "cat $val >> $file"
        exec_cmd "echo '' >> $file"
    done
}

testIdmDbConnection(){
    if ([[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ]] || [[ "$CAPS_CLUSTER_MANAGEMENT" == "true" ]])  && [[ -f "$SILENT_CONFIG_FILE" ]];then
        local has_attr;has_attr=$($JQ -r 'has("database")' "$SILENT_CONFIG_FILE")
        if [[ "$has_attr" != "true" ]];then
            write_log "fatal" "Configuration file is missing database information"
        fi
        local db_type;db_type=$($JQ -r '.database.type?' "$SILENT_CONFIG_FILE")
        if [ -z "$db_type" ];then
            write_log "fatal" "Configuration file is missing database type information"
        fi
        local embext=${db_type:0:3}
        if [ "$embext" == "ext" ];then
            write_log "step" "Test external IDM database connection ..."
            if stepNotDone $FUNCNAME; then
                db_type=${db_type:3}
                if [ "$db_type" == "postgres" ];then
                    db_type="postgresql"
                fi
                local has_dbcert;has_dbcert=$(cat "$SILENT_CONFIG_FILE"|$JQ -r '.database.param'|$JQ -r 'has("dbCert")')
                local cert_content=""
                if [[ "$has_dbcert" == "true" ]];then
                    local dbcert=$(cat "$SILENT_CONFIG_FILE"|$JQ -r '.database.param.dbCert')
                    if [[ -n "$dbcert" ]];then
                        local mergeCert="${TMP_FOLDER}/.cdf_dbcerts.tmp"
                        createDbCertsMergeFile "$dbcert" "$mergeCert"
                        cert_content=$(cat "$mergeCert")
                    else
                        has_dbcert="false"
                    fi
                fi
                local db_url=""
                local db_host=$(cat "$SILENT_CONFIG_FILE" | $JQ -r '.database.param.dbHost?'); if [ "$db_host" == "null" ];then db_host=""; fi
                local db_port=$(cat "$SILENT_CONFIG_FILE" | $JQ -r '.database.param.dbPort?'); if [ "$db_port" == "null" ];then db_port=""; fi
                local db_name=$(cat "$SILENT_CONFIG_FILE" | $JQ -r '.database.param.dbName?'); if [ "$db_name" == "null" ];then db_name=""; fi
                local db_sid=$(cat "$SILENT_CONFIG_FILE" | $JQ -r '.database.param.dbSid?'); if [ "$db_sid" == "null" ];then db_sid=""; fi
                local db_user=$(cat "$SILENT_CONFIG_FILE" | $JQ -r '.database.param.dbUser?'); if [ "$db_user" == "null" ];then db_user=""; fi
                local db_password=$(cat "$SILENT_CONFIG_FILE" | $JQ -r '.database.param.dbPassword?'); if [ "$db_password" == "null" ];then db_password=""; fi
                local db_schema=$(cat "$SILENT_CONFIG_FILE" | $JQ -r '.database.param.dbSchema?'); if [ "$db_schema" == "null" ];then db_schema=""; fi
                local db_auto_create=$(cat "$SILENT_CONFIG_FILE" | $JQ -r '.database.param.dbAutoCreate?'); if [ "$db_auto_create" == "null" ];then db_auto_create="false"; fi
                local db_tls_skip_hostname_verification=$(cat "$SILENT_CONFIG_FILE" | $JQ -r '.database.param.dbTlsSkipHostnameVerification?'); if [ "$db_tls_skip_hostname_verification" == "null" ];then db_tls_skip_hostname_verification=""; fi
                local db_connection_str=$(cat "$SILENT_CONFIG_FILE" | $JQ -r '.database.param.dbConnectionString?'); if [ "$db_connection_str" == "null" ];then db_connection_str=""; fi
                local db_test_connection="true"
                #$db_auto_create=true,means db is not created, in this case we just test network connection, not db connection
                if [ -n "$db_connection_str" ];then
                    db_url="jdbc:oracle:thin:@$db_connection_str"
                fi

                local reTryTimes=0
                local job_name="cdf-idmdb-check"
                local tmp_secret="tmp-idmdb-check-secret"

                #delete the tmp secret and pod if check pass
                if [ $(exec_cmd "kubectl get secret ${tmp_secret} -n ${CDF_NAMESPACE}" -p=false; echo $?) -eq 0 ] ; then
                    exec_cmd "kubectl delete secret ${tmp_secret} -n ${CDF_NAMESPACE}" -p=false
                fi

                while true; do
                    exec_cmd "kubectl create secret generic ${tmp_secret} -n ${CDF_NAMESPACE} --save-config \\
                        --from-literal=ENABLE_FIPS='${ENABLE_FIPS}' \\
                        --from-literal=TLS_MIN_VERSION='${TLS_MIN_VERSION}' \\
                        --from-literal=DB_SSL_ENABLE='${has_dbcert}' \\
                        --from-literal=DB_TYPE='${db_type}' \\
                        --from-literal=DB_USER='${db_user}' \\
                        --from-literal=DB_PASSWORD='$(echo "${db_password}"|sed -e "s/'/'\\\\''/g")' \\
                        --from-literal=DB_HOST='${db_host}' \\
                        --from-literal=DB_PORT='${db_port}' \\
                        --from-literal=DB_NAME='${db_name}' \\
                        --from-literal=DB_SID='${db_sid}' \\
                        --from-literal=DB_SCHEMA='${db_schema}' \\
                        --from-literal=DB_URL='${db_url}' \\
                        --from-literal=DB_CERT='${cert_content}' \\
                        --from-literal=DB_TLS_SKIP_HOSTNAME_VERIFICATION='${db_tls_skip_hostname_verification}' \\
                        --from-literal=DB_PASSWORD_FLAG='password' \\
                        --from-literal=DB_TEST_CONNECTION='${db_test_connection}' \\
                        --from-literal=DB_AUTO_CREATE='${db_auto_create}' \\
                        --from-literal=DB_CHECK_EMPTY='true' " -m=false
                    if [ $? -eq 0 ];then
                        break
                    else
                        reTryTimes=$(( $reTryTimes + 1 ))
                        if [ $reTryTimes -eq $RETRY_TIMES ]; then
                            write_log "fatal" "Failed to create ${tmp_secret} while checking cdf-apiserver database. $LOG_SUPPORT_MSG" "failed"
                        else
                            write_log "debug" "Failed to create ${tmp_secret} while checking cdf-apiserver database. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                        fi
                        sleep $SLEEP_TIME
                    fi
                done
                local pod_status
                pod_status=$(testDbConnection "$job_name" "$tmp_secret")
                if [[ $pod_status != "Completed" ]];then
                    write_log "fatal" "IDM database connection test failed. $LOG_SUPPORT_MSG" "failed"
                fi
                #delete the tmp secret and pod if check pass
                if [ $(exec_cmd "kubectl get secret ${tmp_secret} -n ${CDF_NAMESPACE}" -p=false; echo $?) -eq 0 ] ; then
                    exec_cmd "kubectl delete secret ${tmp_secret} -n ${CDF_NAMESPACE}" -p=false
                fi
                if [ $(exec_cmd "kubectl get pod ${job_name} -n ${CDF_NAMESPACE}" -p=false; echo $?) -eq 0 ] ; then
                    exec_cmd "kubectl delete pod ${job_name} -n ${CDF_NAMESPACE} --force" -p=false
                fi
                showStatus "ok"
                setStepDone $FUNCNAME
            else
                showStatus "Already done"
            fi
        fi
    fi
}

checkDeployerNFSForClassic(){
    local nfs_server="${NFS_SERVER:-"$NFS_PROV_SERVER"}"
    local nfs_folder="${NFS_FOLDER:-"$NFS_PROV_FOLDER"}"
    local tmp_error_msg_log="${TMP_FOLDER}/.check_nfs_error_msg"
    local count=0
    local total_count=5
    while true;
    do
        timeout 30 $CURRENTDIR/scripts/checkNFS.sh --persistence-threshold ${PERSISTENCE_THREHOLD} -t "nfs" -s ${nfs_server} -f ${nfs_folder} -u ${SYSTEM_USER_ID} -g ${SYSTEM_GROUP_ID} -d 5 -e 1>${tmp_error_msg_log} 2>&1
        local return_code=$?
        if [[ $return_code -ne 0 ]]; then
            if [[ $count -ge $total_count ]];then
                if [[ $return_code == 124 ]];then
                    write_log "fatal" "Check NFS \"${nfs_server}:${nfs_folder}\" timeout. $MSG_NFS_ISSUE_TIPS"
                else
                    local checkNfsTips=""
                    if grep -q 'cannot mount' $tmp_error_msg_log 2>/dev/null;then
                        checkNfsTips="$MSG_NFS_ISSUE_TIPS"
                    fi
                    write_log "fatal" "Check NFS \"${nfs_server}:${nfs_folder}\" error: \n$(cat $tmp_error_msg_log) \n$checkNfsTips"
                fi
            fi
        else
            if grep 'Warning:' $tmp_error_msg_log 1>/dev/null 2>&1;then
                write_log "warn" "$(grep 'Warning:' $tmp_error_msg_log)"
            fi
            break
        fi
        sleep 5
        count=$((count+1))
    done
}

checkCdfAdminPv(){
    local has_pv;has_pv=$(echo $CDF_ADMIN_TASKS|awk -F, '{for(i=1;i<=NF;i++)if($i=="pv"){print "true";break}}')
    if [ "$has_pv" == "true" ];then
        local pv_name="itom-vol"
        if kubectl get pv $pv_name >/dev/null 2>&1;then
            write_log "fatal" "Please remove the PV named $pv_name in kubernetes(kubectl delete pv $pv_name). \n$LOG_SUPPORT_MSG" "failed"
        fi
    fi
}

checkDeployerNFSForBYOK(){
if stepNotDone $FUNCNAME; then
    local pv_name="itom-vol"
    write_log "step" "Check pv: $pv_name..."
    local tmp_file="${TMP_FOLDER}/.cdf_check_deployer_pvc_status_$(cat ${CURRENTDIR}/version.txt).tmp"
    > ${tmp_file}
    local pvc_name="itom-vol-claim"
    local job_name="itom-cdf-deployer-just-check"
    local err_msg=""
    local warn_msg="Warning: The I/O performance of your volume may be inadequate."
    local pv
    local pvc
    local label_val="$(getRandomVal)"
    # clean JOB and PVC
    cleanCheckForBYOK "$job_name" "$pvc_name"
    local has_pv;has_pv=$(echo $CDF_ADMIN_TASKS|awk -F, '{for(i=1;i<=NF;i++)if($i=="pv"){print "true";break}}')
    if [ "$has_pv" == "true" ];then
        # clean PV in "PV manged by CDF"
        exec_cmd "kubectl delete pv $pv_name --grace-period=0 --force"
        err_msg="Failed: ${NFS_SERVER}:${NFS_FOLDER} is not empty"
        local yaml=$CDF_HOME/objectdefs/itom-vol.yaml
        exec_cmd "$CP -f $CURRENTDIR/cdf/objectdefs/itom-vol.yaml $yaml"
        replaceCdfDeployer $yaml
        exec_cmd "sed -i -e 's@{PV_PVC_LABEL_VALUE}@$label_val@g' $yaml"
        pv=$(cat $yaml)
    else
        err_msg="Failed: Cluster admin supplied PV is not empty"
    fi

    local yaml=$CDF_HOME/objectdefs/itom-vol-claim.yaml
    exec_cmd "$CP -f $CURRENTDIR/cdf/objectdefs/itom-vol-claim.yaml $yaml"
    replaceCdfDeployer $yaml
    exec_cmd "sed -i -e 's@{PV_PVC_LABEL_VALUE}@$label_val@g' $yaml"

    if [ "$has_pv" == "true" ];then
        pvc=$(cat $yaml)
    else
        pvc=$(exec_cmd "sed -e '/#{pv-admin-need-remove-it}/d' $yaml" -p=true)
    fi

    updateScriptContentBase64 "$err_msg"

    local image_name="$DOCKER_REPOSITORY/$REGISTRY_ORGNAME/$IMAGE_ITOM_TOOLS_BASE"
    local pod_status="Error"
    echo "
$pv
---
$pvc
---
apiVersion: v1
kind: Pod
metadata:
  name: ${job_name}
  namespace: ${CDF_NAMESPACE}
  labels:
    app: ${job_name}-app
spec:
  containers:
  - image: ${image_name}
    imagePullPolicy: IfNotPresent
    name: ${job_name}
    securityContext:
      readOnlyRootFilesystem: true
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
    env:
    - name: SCRIPT_BASE64
      value: $SCRIPT_BASE64
    command: ['bash', '-ce', 'echo \"\$SCRIPT_BASE64\"|base64 -d > /tmp/cdf_nfs_check.sh;bash /tmp/cdf_nfs_check.sh']
    resources:
      limits:
        cpu: \"1\"
        memory: 2Gi
      requests:
        cpu: 100m
        memory: 200Mi
    volumeMounts:
    - mountPath: /test
      name: test-volume
    - mountPath: /tmp
      name: tmp
  restartPolicy: Never
  dnsPolicy: ClusterFirst
  priority: 0
  imagePullSecrets:
    - name: registrypullsecret
  securityContext:
    runAsUser: ${SYSTEM_USER_ID}
    runAsGroup: ${SYSTEM_GROUP_ID}
    fsGroup: ${SYSTEM_GROUP_ID}
    supplementalGroups: [${SYSTEM_GROUP_ID}]
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  volumes:
  - name: test-volume
    persistentVolumeClaim:
      claimName: ${pvc_name}
  - name: tmp
    emptyDir: {}
    " | kubectl create --save-config -f - 1>${tmp_file} 2>>${tmp_file}
    if [[ $? -ne 0 ]];then
        write_log "fatal" "Failed to create pod $job_name: $(cat ${tmp_file}). \n$LOG_SUPPORT_MSG" "failed"
    fi
    # ContainerCreating needs to set continue_retry=true
    local container_status="
        CrashLoopBackOff
        ErrImagePull
        ImagePullBackOff
        CreateContainerConfigError
        InvalidImageName
        CreateContainerError
        OOMKilled
        Error
        Completed
        ContainerCannotRun
        DeadlineExceeded"
    local continue_retry=false
    local retry_count=60
    while (( $retry_count > 0 )); do
        retry_count=$(( $retry_count - 1 ))
        sleep 5
        pod_status=$(exec_cmd "kubectl get pods $job_name -n ${CDF_NAMESPACE} --no-headers 2>/dev/null|awk '{print \$3}'" -p=true)
        if [[ -n "$pod_status" ]];then
            if echo "$container_status"|xargs -n1|grep "$pod_status" &>/dev/null;then
                break
            fi
            if [[ "$pod_status" == "ContainerCreating" ]];then
                if [[ "$retry_count" -eq 0 ]] && [[ "$continue_retry" == "false" ]];then
                    continue_retry=true
                    retry_count=360
                fi
                local mount_error=$(exec_cmd "kubectl describe pods $job_name -n ${CDF_NAMESPACE} 2>/dev/null|grep '^Events:' -A 100|grep -i 'FailedMount'" -p=true)
                if [[ -n "$mount_error" ]];then
                    write_log "debug" "Unable to attach or mount volumes for $job_name, waiting ..."
                fi
            fi
        fi
    done
    if [[ -z "$pod_status" ]];then
        describeCheckForBYOK "$job_name" "$pvc_name"
        write_log "fatal" "Failed to create pod $job_name. \n$LOG_SUPPORT_MSG" "failed"
    fi
    local pvc_status=$(exec_cmd "kubectl get pvc $pvc_name  -n ${CDF_NAMESPACE} --no-headers -o custom-columns=STATUS:.status.phase 2>/dev/null|awk '{print \$1}'" -p=true)
    if [[ $pod_status == "Completed" ]];then
        local warning_msg;warning_msg=$(kubectl logs $job_name -n ${CDF_NAMESPACE} 2>/dev/null|grep 'Warning:')
        cleanCheckForBYOK "$job_name"
    elif [[ $pod_status == "ImagePullBackOff" ]] || [[ $pod_status == "ErrImagePull" ]];then
        describeCheckForBYOK "$job_name" "$pvc_name"
        local str="Failed to pull image"
        local error_msg;error_msg=$(kubectl describe pods $job_name -n ${CDF_NAMESPACE} 2>/dev/null|grep "$str"|awk -v s="$str" '{i=index($0,s);if(i>0)print substr($0,i)}')
        # cleanCheckForBYOK "$job_name" "$pvc_name"
        # cleanNamespace
        if [[ "$pvc_status" != "Bound" ]];then
            write_log "fatal" "PVC cannot be bound to PV normally (STATUS: $pvc_status). \n$LOG_SUPPORT_MSG" "failed"
        else
            write_log "fatal" "$error_msg. \n$LOG_SUPPORT_MSG" "failed"
        fi
    elif [[ $pod_status == "Error" ]];then
        describeCheckForBYOK "$job_name" "$pvc_name"
        local error_msg;error_msg=$(kubectl logs $job_name -n ${CDF_NAMESPACE} 2>/dev/null)
        # cleanCheckForBYOK "$job_name" "$pvc_name"
        # cleanNamespace
        if [[ "$pvc_status" != "Bound" ]];then
            write_log "fatal" "PVC cannot be bound to PV normally (STATUS: $pvc_status). \n$LOG_SUPPORT_MSG" "failed"
        else
            write_log "fatal" "Check PVC error: \n$error_msg. \n$LOG_SUPPORT_MSG" "failed"
        fi
    else
        describeCheckForBYOK "$job_name" "$pvc_name"
        # cleanCheckForBYOK "$job_name" "$pvc_name"
        # cleanNamespace
        write_log "fatal" "Check PVC timeout. PVC STATUS: $pvc_status. \n$LOG_SUPPORT_MSG" "failed"
    fi
    setStepDone $FUNCNAME
    showStatus "ok"
    if [[ -n "$warning_msg" ]];then
        write_log "warn" "The I/O performance of ${NFS_SERVER}:${NFS_FOLDER} may be inadequate"
    fi
fi
}

describeCheckForBYOK(){
    local job_name=$1
    local pvc_name=$2
    write_log "debug" "===============Pod/PVC/PV details==============="
    exec_cmd "kubectl get pods $job_name -n ${CDF_NAMESPACE}"
    exec_cmd "kubectl describe pods $job_name -n ${CDF_NAMESPACE}"
    exec_cmd "kubectl logs $job_name -n ${CDF_NAMESPACE}"
    exec_cmd "kubectl get pvc $pvc_name -n ${CDF_NAMESPACE}"
    exec_cmd "kubectl describe pvc $pvc_name -n ${CDF_NAMESPACE}"
    exec_cmd "kubectl get pv"
    write_log "debug" "================================================="
}

cleanCheckForBYOK(){
    local job_name=$1
    local pvc_name=$2
    [ -n "$job_name" ] && exec_cmd "kubectl delete pods $job_name -n ${CDF_NAMESPACE} --grace-period=0 --force"
    [ -n "$pvc_name" ] && exec_cmd "kubectl delete pvc $pvc_name -n ${CDF_NAMESPACE} --grace-period=0 --force"
}
cleanNamespace(){
    exec_cmd "kubectl delete secret registrypullsecret -n ${CDF_NAMESPACE} --grace-period=0 --force"
    exec_cmd "kubectl delete ns ${CDF_NAMESPACE} --grace-period=0 --force"
}

updateScriptContentBase64(){
    local err_msg_empty=$1
    local script_content="\
#!/bin/bash
if [ \$(ls /test|grep -v \"lost+found\"|wc -w) -ne 0 ];then
    echo \"$err_msg_empty\"
    exit 100
elif [ \$(touch /test/rw >/tmp/err;echo \$?) -eq 0 ];then
    if [ \$(stat -c %u /test/rw) == ${SYSTEM_USER_ID} -o \$(stat -c %g /test/rw) == ${SYSTEM_GROUP_ID} ];then
        /usr/bin/rm -f /test/rw
        echo OK
    else
        echo \"Failed: folder owner or group is not equals to ${SYSTEM_USER_ID} and ${SYSTEM_GROUP_ID}\"
        exit 102
    fi
else
    cat /tmp/err
    exit 101
fi
t1=\$(date \"+%s\")
timeout 60 dd if=/dev/zero of=/test/zeroFile bs=${PERSISTENCE_THREHOLD}K count=1
t2=\$(date \"+%s\")
[[ \$(( \${t2} - \${t1} )) -gt 2 ]] && echo \"Warning: The I/O performance of your volume may be inadequate.\"
/bin/rm -f /test/zeroFile
"
    SCRIPT_BASE64="$(echo "$script_content"|base64 -w0)"
}

getRandomVal(){
    local digits="${1:-5}"
    local random_id="$(cat /proc/sys/kernel/random/uuid 2>/dev/null|sed 's/-//g'|head -c $digits)"
    if [[ -z "$random_id" ]];then
        random_id="$(cat /dev/urandom 2>/dev/null|tr -cd "[:alnum:]"|head -c $digits)"
    fi
    if [[ -z "$random_id" ]];then
        random_id="$(date +%s | md5sum | cut -c 1-$digits)"
    fi
    echo "$random_id"
}

checkNFSForBYOK(){
    local host=$1
    local path=$2
    local name=$3
    local pv_name="cdf-check-pv-$name"
    local label_name="$(getRandomVal)"
    write_log "step" "Check pv: $name..."
    local tmp_file="${TMP_FOLDER}/.cdf_check_config_nfs_status_$(cat ${CURRENTDIR}/version.txt).tmp"
    > ${tmp_file}
    local pvc_name="cdf-check-pvc-$name"
    local job_name="cdf-check-nfs-$name"
    local err_msg_empty="Failed: ${host}:${path} is not empty"
    # clean JOB and PVC
    cleanCheckForBYOK "$job_name" "$pvc_name"
    exec_cmd "kubectl delete pv $pv_name --grace-period=0 --force"

    updateScriptContentBase64 "$err_msg_empty"

    local image_name="$DOCKER_REPOSITORY/$REGISTRY_ORGNAME/$IMAGE_ITOM_TOOLS_BASE"
    local pod_status="Error"
    echo "
---

kind: PersistentVolume
apiVersion: v1
metadata:
  name: ${pv_name}
  labels:
    pv_pvc_label: \"${label_name}\"
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - $PERSISTENCE_ACCESS_MODE
  persistentVolumeReclaimPolicy: Retain
  storageClassName: ${DEFAULT_STORAGE_CLASS}
  nfs:
    path: ${path}
    server: ${host}

---

kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: ${pvc_name}
  namespace: ${CDF_NAMESPACE}
  labels:
    pv_pvc_label: \"${label_name}\"
spec:
  accessModes:
    - $PERSISTENCE_ACCESS_MODE
  storageClassName: ${DEFAULT_STORAGE_CLASS}
  resources:
    requests:
      storage: 1Gi
  selector:
    matchLabels:
      pv_pvc_label: \"${label_name}\"

---

apiVersion: v1
kind: Pod
metadata:
  name: ${job_name}
  namespace: ${CDF_NAMESPACE}
  labels:
    app: ${job_name}-app
spec:
  containers:
  - image: ${image_name}
    imagePullPolicy: IfNotPresent
    name: ${job_name}
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
    env:
    - name: SCRIPT_BASE64
      value: $SCRIPT_BASE64
    command: ['bash', '-ce', 'echo \"\$SCRIPT_BASE64\"|base64 -d > /tmp/cdf_nfs_check.sh;bash /tmp/cdf_nfs_check.sh']
    resources:
      limits:
        cpu: \"1\"
        memory: 2Gi
      requests:
        cpu: 100m
        memory: 200Mi
    volumeMounts:
    - mountPath: /test
      name: test-volume
    - mountPath: /tmp
      name: tmp
  restartPolicy: Never
  dnsPolicy: ClusterFirst
  priority: 0
  imagePullSecrets:
    - name: registrypullsecret
  securityContext:
    runAsUser: ${SYSTEM_USER_ID}
    runAsGroup: ${SYSTEM_GROUP_ID}
    fsGroup: ${SYSTEM_GROUP_ID}
    supplementalGroups: [${SYSTEM_GROUP_ID}]
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  volumes:
  - name: test-volume
    persistentVolumeClaim:
      claimName: ${pvc_name}
  - name: tmp
    emptyDir: {}
"| kubectl create --save-config -f - 1>${tmp_file} 2>>${tmp_file}
    if [[ $? -ne 0 ]];then
        write_log "fatal" "Failed to create pod $job_name: $(cat ${tmp_file}). \n$LOG_SUPPORT_MSG" "failed"
    fi
    # ContainerCreating needs to set continue_retry=true
    local container_status="
        CrashLoopBackOff
        ErrImagePull
        ImagePullBackOff
        CreateContainerConfigError
        InvalidImageName
        CreateContainerError
        OOMKilled
        Error
        Completed
        ContainerCannotRun
        DeadlineExceeded"
    local continue_retry=false
    local retry_count=60
    while (( $retry_count > 0 )); do
        retry_count=$(( $retry_count - 1 ))
        sleep 5
        pod_status=$(exec_cmd "kubectl get pods $job_name -n ${CDF_NAMESPACE} --no-headers 2>/dev/null|awk '{print \$3}'" -p=true)
        if [[ -n "$pod_status" ]];then
            if echo "$container_status"|xargs -n1|grep "$pod_status" &>/dev/null;then
                break
            fi
            if [[ "$pod_status" == "ContainerCreating" ]];then
                if [[ "$retry_count" -eq 0 ]] && [[ "$continue_retry" == "false" ]];then
                    continue_retry=true
                    retry_count=360
                fi
                local mount_error=$(exec_cmd "kubectl describe pods $job_name -n ${CDF_NAMESPACE} 2>/dev/null|grep '^Events:' -A 100|grep -i 'FailedMount'" -p=true)
                if [[ -n "$mount_error" ]];then
                    write_log "debug" "Unable to attach or mount volumes for $name ($host:$path), waiting ..."
                fi
            fi
        fi
    done
    if [[ -z "$pod_status" ]];then
        describeCheckForBYOK "$job_name" "$pvc_name"
        write_log "fatal" "Failed to create pod $job_name for $name. \n$LOG_SUPPORT_MSG" "failed"
    fi
    local pvc_status=$(exec_cmd "kubectl get pvc $pvc_name  -n ${CDF_NAMESPACE} --no-headers -o custom-columns=STATUS:.status.phase 2>/dev/null|awk '{print \$1}'" -p=true)
    if [[ $pod_status == "Completed" ]];then
        local warning_msg;warning_msg=$(kubectl logs $job_name -n ${CDF_NAMESPACE}|grep 'Warning:')
        cleanCheckForBYOK "$job_name" "$pvc_name"
        if ! exec_cmd "kubectl delete pv $pv_name --grace-period=0 --force";then
            write_log "fatal" "Failed to delete pv $pv_name. \n$LOG_SUPPORT_MSG" "failed"
        fi
    elif [[ $pod_status == "ImagePullBackOff" ]] || [[ $pod_status == "ErrImagePull" ]];then
        describeCheckForBYOK "$job_name" "$pvc_name"
        local str="Failed to pull image"
        local error_msg;error_msg=$(kubectl describe pods $job_name -n ${CDF_NAMESPACE}|grep "$str"|awk -v s="$str" '{i=index($0,s);if(i>0)print substr($0,i)}')
        if [[ "$pvc_status" != "Bound" ]];then
            write_log "fatal" "PVC cannot be bound to PV normally (STATUS: $pvc_status). \n$LOG_SUPPORT_MSG" "failed"
        else
            write_log "fatal" "$error_msg. \n$LOG_SUPPORT_MSG" "failed"
        fi
    elif [[ $pod_status == "Error" ]];then
        describeCheckForBYOK "$job_name" "$pvc_name"
        local error_msg;error_msg=$(kubectl logs $job_name -n ${CDF_NAMESPACE})
        if [[ "$pvc_status" != "Bound" ]];then
            write_log "fatal" "PVC cannot be bound to PV normally (STATUS: $pvc_status). \n$LOG_SUPPORT_MSG" "failed"
        else
            write_log "fatal" "Check PVC error: \n$error_msg. \n$LOG_SUPPORT_MSG" "failed"
        fi
    else
        describeCheckForBYOK "$job_name" "$pvc_name"
        write_log "fatal" "Check PVC timeout. PVC STATUS: $pvc_status. \n$LOG_SUPPORT_MSG" "failed"
    fi
    showStatus "ok"
    if [[ -n "$warning_msg" ]];then
        write_log "warn" "The I/O performance of ${host}:${path} may be inadequate"
    fi
}

record(){
    echo "`getRfcTime 'ns'` DEBUG # $1"|sed -r "s/((sessionId|token|password|privateKey|pass)(\": *\"| *: *|=| *'))[^\"']+/\\1***/gi" >>$LOG_FILE 2>/dev/null
}

wrap_curl(){
    # if [ "$INSTALLED_TYPE" = "CLASSIC" ];then
    #     ${CDF_HOME}/bin/cmd_wrapper -c "$1" -f "$LOG_FILE" -x "DEBUG" $2 $3 $4 $5
    #     return $?
    # fi
    local curl_cmd=$1
    local val=
    local ret_code=
    local container_name="cdf-apiserver"
    local pod_name=

    for (( n=0; n<RETRY_TIMES; n++ ));do
        # check k8s apiserver running
        for (( i=0; i<$RETRY_TIMES; i++));do
            if exec_cmd "kubectl get pods -n ${CDF_NAMESPACE}";then
                break
            fi
            write_log "debug" "Current k8s apiserver unstable and may be a problem with the network or etcd."
            sleep $SLEEP_TIME
        done

        # get pod_name
        local retry=0
        while true; do
            pod_name=$(exec_cmd "kubectl get pods -n ${CDF_NAMESPACE} 2>>'$LOG_FILE'|grep '$container_name'|grep 'Running'|awk '{len=split(\$2,arr,\"/\");if(len==2&&arr[1]>0&&arr[1]==arr[2])print \$1}'" -p true)
            if [ -z "$pod_name" ];then
                if [ "$retry" -gt "$RETRY_TIMES" ]; then
                    write_log "fatal" "Failed to get $container_name pod name. Current k8s apiserver or pod unstable and may be a problem with the network or etcd."
                else
                    retry=$((retry+1))
                    sleep $SLEEP_TIME
                fi
            else
                break
            fi
        done

        # request API
        # val=$(eval "kubectl exec $pod_name -n ${CDF_NAMESPACE} -c $container_name 2>>'$LOG_FILE' -- $curl_cmd" 2>>"$LOG_FILE")
        val=$(exec_cmd "kubectl exec $pod_name -n ${CDF_NAMESPACE} -c $container_name 2>>'$LOG_FILE' -- $curl_cmd" -p=true -m=${CDF_DEV_INSECURITY_DEBUG_LOG} -o=${CDF_DEV_INSECURITY_DEBUG_LOG})
        ret_code=$?
        if [[ "$ret_code" -eq 0 ]];then
            if [[ "$curl_cmd" =~ %\{http_code\} ]];then
                if [[ -n "$val" ]];then
                    write_log "debug" "http_code: ${val:0-3}"
                    break
                else
                    write_log "debug" "kubectl exec exit code is 0, but 'val' is not get any output from stdout, retry ..."
                fi
            else
                break
            fi
        fi
        write_log "debug" "Current k8s or pod unstable and retry run kubectl exec ..."
        sleep $SLEEP_TIME
    done

    if ! echo "$2 $3 $4 $5"|grep '\-[mo]=false' 1>/dev/null 2>&1;then
        record "kubectl exec $pod_name -n ${CDF_NAMESPACE} -c $container_name -- $curl_cmd"
        record "$val"
    fi
    if [[ -z "$val" ]] && [[ "$curl_cmd" =~ %\{http_code\} ]];then
        val="000"
        write_log "debug" "There may be an error in the response of the current API, and the content is empty, cmd exitCode: $ret_code."
    fi
    echo "$val"
    return $ret_code
}

getXtoken(){
    write_log "debug" "Getting X-AUTH-TOKEN"
    local waitForSeconds=0
    local x_auth_token=""
    SILENT_SUPERUSER="${SILENT_SUPERUSER:-admin}"
    local api_url="/urest/v1.1/tokens"
    local body="{\"passwordCredentials\":{\"password\":\"$(echo "${SUPER_USERPWD}"|sed -e 's/\\/\\\\/g' -e 's/"/\\"/g')\",\"username\":\"${SILENT_SUPERUSER}\"},\"tenantName\":\"Provider\"}"
    echo "`getRfcTime 'ns'` DEBUG exec_cmd # curl -k -s -X POST -w \"%{http_code}\" --header 'Content-Type: application/json' --header 'Accept: application/json' -d '{\"passwordCredentials\": {\"password\": \"******\", \"username\": \"${SILENT_SUPERUSER}\"},\"tenantName\": \"Provider\"}' --noproxy ${CDF_APISERVER_HOST} \"${BASE_URL}${api_url}\"" >>$LOG_FILE
    while [ -z "${x_auth_token}" -o "${x_auth_token}" = "null" ]; do
        local apiResponse=$(wrap_curl "curl -k -s -X POST \\
                    -w '%{http_code}' \\
                    --header 'Content-Type: application/json' \\
                    --header 'Accept: application/json' \\
                    -d '$(echo "$body"|sed -e "s/'/'\\\\''/g")' \\
                    --noproxy '${CDF_APISERVER_HOST}' \\
                    '${BASE_URL}${api_url}'" -p=true -m=false)
        local http_code=${apiResponse:0-3}
        if [ "$http_code" = "201" ]; then
            x_auth_token=$(echo "${apiResponse:0:-3}" | $JQ -r '.token')
            X_AUTH_TOKEN="X-AUTH-TOKEN: ${x_auth_token}"
            break
        else
            write_log "fatal" "Authentication failed. Failed to get X-AUTH-TOKEN. API response: ${apiResponse}. For detail logs, please refer to $LOG_FILE"
            exec_cmd "exit 1"
        fi
    done
}

getCsrfTokenSessionID(){
    write_log "debug" "Getting X-CSRF-TOKEN"
    local x_csrf_token=""
    local session_id=""
    local session_name=""
    local api_url="/urest/v1.1/csrf-token"
    local waitForSeconds=0
    local totalSeconds=600
    while true; do
        local apiResponse=$(wrap_curl "curl -k -s -X GET \\
                                    -w '%{http_code}' \\
                                    --header 'Accept: application/json' \\
                                    --header '${X_AUTH_TOKEN}' \\
                                    --noproxy '${CDF_APISERVER_HOST}' \\
                                    '${BASE_URL}${api_url}'" -p=true)
        local http_code=${apiResponse:0-3}
        if [ "$http_code" != "201" ]; then
            if [ "$waitForSeconds" -lt "$totalSeconds" ]; then
                write_log "debug" "Failed to get X-CSRF-TOKEN. API response: ${apiResponse}; will retry in 10 seconds."
                waitForSeconds=$(( waitForSeconds + 10 ))
                sleep 10
            else
                write_log "fatal" "Failed to get X-CSRF-TOKEN. API response: ${apiResponse}. For detail logs, please refer to $LOG_FILE"
            fi
        else
            x_csrf_token=$(echo "${apiResponse:0:-3}" |$JQ -r '.csrfToken')
            session_id=$(echo "${apiResponse:0:-3}" |$JQ -r '.sessionId' )
            session_name=$(echo "${apiResponse:0:-3}" |$JQ -r '.sessionName')
            if [ -z "${session_name}" -o "${session_name}" = "null" ]; then
                session_name="JSESSIONID"
            fi
            X_CSRF_TOKEN="X-CSRF-TOKEN: ${x_csrf_token}"
            JSESSION_ID="${session_name}=${session_id}"
            break
        fi
    done
}

getDeploymentUuid(){
    getXtoken
    getCsrfTokenSessionID
    write_log "debug" "Getting deployment UUID ..."
    local deploymentType=
    local deployment_num=
    local deploymentStatus="INSTALL_FINISHED RECONFIGURE_FAILED UPDATE_FAILED INSTALL_FAILED"
    for status in $deploymentStatus
    do
        local api_url="/urest/v1.1/deployment?deploymentStatus=${status}"
        local apiResponse=$(wrap_curl "curl -k -s -X GET \\
                        -w '%{http_code}' \\
                        --header 'Accept: application/json' \\
                        --header '${X_AUTH_TOKEN}' \\
                        --noproxy '${CDF_APISERVER_HOST}' \\
                        '${BASE_URL}${api_url}'" -p=true)
        local http_code=${apiResponse:0-3}
        if [ "$http_code" != "200" ]; then
            write_log "fatal" "Failed to get deployment UUID.\nAPI response: ${apiResponse:0:-3}"
        else
            local n=0
            deployment_num=$(echo "${apiResponse:0:-3}" | $JQ '. | length')
            while [[ $n -lt $deployment_num ]];
            do
                deploymentType=$(echo "${apiResponse:0:-3}" | $JQ -r ".[$n].deploymentInfo.deploymentType")
                if [[ "$deploymentType" == "PRIMARY" ]];then
                    DEPLOYMENT_UUID=$(echo "${apiResponse:0:-3}" | $JQ -r ".[$n].deploymentInfo.deploymentUuid")
                    DEPLOYMENT_NAME=$(echo "${apiResponse:0:-3}" | $JQ -r ".[$n].deploymentInfo.deploymentName")
                    if [ -n "$DEPLOYMENT_UUID" -a "$DEPLOYMENT_UUID" != "null" ]; then
                        write_log "debug" "Deployment UUID: $DEPLOYMENT_UUID"
                        return
                    fi
                fi
                n=$((n+1))
            done
        fi
    done
    if [ -z "$DEPLOYMENT_UUID" -o "$DEPLOYMENT_UUID" = "null" ]; then
        write_log "fatal" "Currently only supports the PRIMARY suite update and reconfig, does not support additional suite update and reconfig.\n Failed to get PRIMARY suite deployment UUID.\nAPI response: ${apiResponse:0:-3}"
    fi
}

initCdfapiBaseUrl(){
    local cdfApiServerIP=$(exec_cmd "kubectl get svc suite-installer-svc -n ${CDF_NAMESPACE} -o custom-columns=clusterIP:.spec.clusterIP --no-headers 2>/dev/null" -p=true)
    if [ -z "${cdfApiServerIP}" ];then
        write_log "fatal" "Failed to get IP address of cdf-apiserver svc. For detail logs, please refer to $LOG_FILE"
    fi
}

waitCdfApiServerReady(){
    initCdfapiBaseUrl
    write_log "step" "Wait for the cdf-apiserver ready ..."
    local waitSeconds=0
    local timeoutSeconds=1800
    while true; do
        local api_url="/urest/v1.1/healthz"
        local apiResponse=$(wrap_curl "curl -k -s -X GET \\
                        -w '%{http_code}' \\
                        --header 'Content-Type: application/json' \\
                        --header 'Accept: application/json' \\
                        --noproxy '${CDF_APISERVER_HOST}' \\
                        '${BASE_URL}${api_url}'" -p=true)
        local http_code=${apiResponse:0-3}
        if [ "$http_code" == "200" ]; then
            break
        fi
        if [ "$waitSeconds" -lt "$timeoutSeconds" ]; then
            waitSeconds=$(( waitSeconds + 60 ))
            sleep 60
        else
            write_log "fatal" "Waiting for cdf-apiserver timeout.\nAPI response: ${apiResponse:0:-3}. For detail logs, please refer to $LOG_FILE"
        fi
    done
    showStatus "ok"
}

post(){
    local api_url=$1
    local postBody="$(echo "$2"|awk '{printf("%s",$0)}')"
    local expectStatusCode=${3:-"200"}
    local retryCount=${4:-"0"}

    # copy file to pod from local
    if [ "${postBody:0:1}" == "@" ];then
        local uploadFile="${postBody:1}"
        local container_name="cdf-apiserver"
        local pod_name;pod_name=$(exec_cmd "kubectl get pods -n ${CDF_NAMESPACE} 2>/dev/null|grep '$container_name'|grep 'Running'|awk '{len=split(\$2,arr,\"/\");if(len==2&&arr[1]>0&&arr[1]==arr[2])print \$1}'" -p true)
        if [ -z "$pod_name" ];then
            write_log "fatal" "Failed to get ${CDF_NAMESPACE}/$container_name. For detail logs, please refer to $LOG_FILE"
        fi
        local container_tmpfile="/tmp/$(basename $uploadFile)"
        postBody="@$container_tmpfile"
        local waitSeconds=0
        local timeoutSeconds=10
        while true;do
            if exec_cmd "kubectl cp --no-preserve=true $uploadFile ${CDF_NAMESPACE}/$pod_name:$container_tmpfile -c cdf-apiserver";then
                break
            fi
            if [ "$waitSeconds" -lt "$timeoutSeconds" ]; then
                waitSeconds=$(( waitSeconds + 1 ))
                sleep 2
            else
                write_log "fatal" "Failed to copy $uploadFile to ${CDF_NAMESPACE}/$container_name. For detail logs, please refer to $LOG_FILE"
            fi
        done
    fi

    RESP_BODY=""
    getXtoken
    getCsrfTokenSessionID
    local retryTime=0
    while true; do
        local apiResult=$(wrap_curl "curl -k -s -X POST \\
                        -w '%{http_code}' \\
                        --header 'Content-Type: application/json' \\
                        --header 'Accept: application/json' \\
                        --header '${X_AUTH_TOKEN}' \\
                        --header '${X_CSRF_TOKEN}' \\
                        --cookie '${JSESSION_ID}' \\
                        --noproxy '${CDF_APISERVER_HOST}' \\
                        -d '$(echo "$postBody"|sed -e "s/'/'\\\\''/g")' \\
                        '${BASE_URL}${api_url}'" -p=true)
        local http_code=${apiResult:0-3}
        local is_expectStatusCode=
        for statusCode in ${expectStatusCode};do
            if [ "$http_code" = "${statusCode}" ]; then
                is_expectStatusCode="true"
                break
            fi
        done
        if [ -z "${is_expectStatusCode}" ]; then
            if [ "$retryTime" -eq "${retryCount}" ]; then
                if [[ "${http_code}" == "000" ]];then
                    write_log "fatal" "An exception may have occurred on the server backend, and the content of the current API response is empty. For detail logs, please refer to $LOG_FILE"
                else
                    write_log "fatal" "${apiResult}. For detail logs, please refer to $LOG_FILE"
                fi
            else
                retryTime=$((retryTime+1))
            fi
        else
            break
        fi
        sleep 1
    done
    RESP_BODY="${apiResult:0:-3}"
}

uploadMetadata(){
    if [[ -n "$METADATA" ]] && [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ]];then
        write_log "step" "Start upload metadata file ..."
        if stepNotDone $FUNCNAME; then
            local metadata_tmp="$TMP_FOLDER/.cdf_metadata.tpl"
            local metadata_json="$TMP_FOLDER/.cdf_just_for_silent_metadata.json"
            local name="$(basename $METADATA)"
            echo "{\"name\":\"$name\",\"content\":\"" > $metadata_tmp
            base64 $METADATA >> $metadata_tmp
            echo '"}' >> $metadata_tmp
            sed -e ':a;N;$!ba;s/\n//g' $metadata_tmp > $metadata_json
            exec_cmd "$RM -f $metadata_tmp"
            local api_url="/urest/v1.1/metadata?overwrite=true&isAsynchronous=true"
            local postBody="@$metadata_json"
            post "$api_url" "$postBody" "202" "5"
            exec_cmd "$RM -f $metadata_json"

            checkUploadMetadataStatus
            setStepDone $FUNCNAME
            showStatus "ok"
        else
            showStatus "Already done"
        fi
    fi
}

checkUploadMetadataStatus(){
    write_log "debug" "Check upload metadata file status..."
    local count=0
    while true;do
        getXtoken
        getCsrfTokenSessionID
        local api_url="/urest/v1.1/metadata/status"
        local apiResponse=$(wrap_curl "curl -k -s -X GET \\
                        -w '%{http_code}' \\
                        --header 'Accept: application/json' \\
                        --header '${X_AUTH_TOKEN}' \\
                        --noproxy '${CDF_APISERVER_HOST}' \\
                        '${BASE_URL}${api_url}'" -p=true)
        local http_code=${apiResponse:0-3}
        if [ "$http_code" != "200" ]; then
            write_log "fatal" "Failed to upload metadata.\nAPI response: ${apiResponse:0:-3}. For detail logs, please refer to $LOG_FILE"
        else
            local status=$(echo "${apiResponse:0:-3}"|$JQ -r '.threadInfo.threadStatus')
            if [[ "$status" == "COMPLETED" ]];then
                break
            fi
            if [[ "$status" == "EXCEPTION" ]];then
                write_log "fatal" "Failed to upload metadata.\nAPI response: ${apiResponse:0:-3}. For detail logs, please refer to $LOG_FILE"
            fi
            if [ "$count" -lt 60 ]; then
                write_log "debug" "Upload metadata status: $status. Wait for $SLEEP_TIME seconds and retry: $count "
                count=$(( count + 1 ))
                sleep $SLEEP_TIME
            else
                write_log "fatal" "Timeout to upload metadata.\nAPI response: ${apiResponse:0:-3}. For detail logs, please refer to $LOG_FILE"
            fi
        fi
    done
    write_log "debug" "Upload metadata file completed"
}

initDeploymentAlready(){
    local count=0
    while true;do
        getXtoken
        getCsrfTokenSessionID
        write_log "debug" "Getting deployment list ..."
        local api_url="/urest/v1.1/deployment"
        local apiResponse=$(wrap_curl "curl -k -s -X GET \\
                        -w '%{http_code}' \\
                        --header 'Accept: application/json' \\
                        --header '${X_AUTH_TOKEN}' \\
                        --noproxy '${CDF_APISERVER_HOST}' \\
                        '${BASE_URL}${api_url}'" -p=true)
        local http_code=${apiResponse:0-3}
        if [ "$http_code" != "200" ]; then
            if [ "$count" -lt 100 ]; then
                count=$(( count + 1 ))
                write_log "debug" "Waiting for get deployment UUID. $count"
                sleep 3
            else
                write_log "fatal" "Failed to get deployment UUID.\nAPI response: ${apiResponse:0:-3}. For detail logs, please refer to $LOG_FILE"
            fi
        else
            break
        fi
    done

    local deployment_num=$(echo "${apiResponse:0:-3}" | $JQ '. | length')
    local n=0
    while [[ $n -lt $deployment_num ]];do
        INIT_DEPLOYMENT_UUID=$(echo "${apiResponse:0:-3}" |$JQ -r ".[$n].deploymentInfo.deploymentUuid")
        INIT_DEPLOYMENT_NAME=$(echo "${apiResponse:0:-3}" |$JQ -r ".[$n].deploymentInfo.deploymentName")
        local namespace=$(echo "${apiResponse:0:-3}" |$JQ -r ".[$n].deploymentInfo.namespace")
        local value_type=$(echo "${apiResponse:0:-3}" |$JQ -r "[.[$n].deploymentInfo.namespace]|map(type)|.[0]")
        if [[ "$value_type" == "null" ]] || [[ "$namespace" == "<<empty>>" ]] || [ -z "$namespace" ]; then
            return 1
        fi
        n=$((n+1))
    done
    return 0
}

precheckInitDeploymentStatus(){
    local func_name_flag="initDeployment"
    if stepNotDone "$func_name_flag"; then
        write_log "debug" "Check Pre-Status for initDeployment ..."
        local count=0
        while true;do
            getXtoken
            getCsrfTokenSessionID
            local api_url="/urest/v1.1/deployment/${INIT_DEPLOYMENT_UUID}/initDeployment"
            local apiResponse=$(wrap_curl "curl -k -s -X GET \\
                            -w '%{http_code}' \\
                            --header 'Accept: application/json' \\
                            --header '${X_AUTH_TOKEN}' \\
                            --noproxy '${CDF_APISERVER_HOST}' \\
                            '${BASE_URL}${api_url}'" -p=true)
            local http_code=${apiResponse:0-3}
            if [ "$http_code" -ge "200" ] && [ "$http_code" -lt "300" ]; then
                local status=$(echo "${apiResponse:0:-3}"|$JQ -r '.threadInfo.threadStatus')
                if [[ "$status" == "COMPLETED" ]];then
                    # Initialization completed, skip initDeployment.
                    setStepDone "$func_name_flag"
                    break
                fi
                if [[ "$status" == "EXCEPTION" ]];then
                    write_log "debug" "Check init deployment status is $status, need to call initDeployment again."
                    break
                fi
                if [[ "$status" == "null" ]];then
                    write_log "debug" "Check init deployment status is empty."
                    break
                fi
            else
                write_log "debug" "Failed to check init deployment status.\nAPI response: ${apiResponse}."
            fi
            if [ "$count" -lt "360" ]; then
                write_log "debug" "Check init deployment status status: $status. Wait for $SLEEP_TIME seconds and retry: $count "
                count=$(( count + 1 ))
                sleep $SLEEP_TIME
            else
                write_log "debug" "Timeout to check init deployment status, need to call initDeployment again."
                break
            fi
        done
        write_log "debug" "Check Pre-Status end for initDeployment."
    fi
}

requestInitDeployment(){
    local count=0
    while true;do
        getXtoken
        getCsrfTokenSessionID
        local api_url="/urest/v1.1/deployment/${INIT_DEPLOYMENT_UUID}/initDeployment?isAsynchronous=true"
        local body="{}";
        if [ -z "$DEPLOYMENT_NAME" ]; then
            body="{\"deploymentName\":null,\"suite\":\"$SUITE_NAME\",\"deploymentType\":\"PRIMARY\"}"
        else
            body="{\"deploymentName\":\"$DEPLOYMENT_NAME\",\"suite\":\"$SUITE_NAME\",\"deploymentType\":\"PRIMARY\"}"
        fi
        local apiResult=$(wrap_curl "curl -k -s -X POST \\
                        -w \"%{http_code}\" \\
                        --header 'Content-Type: application/json' \\
                        --header 'Accept: application/json' \\
                        --header \"${X_AUTH_TOKEN}\" \\
                        --header \"${X_CSRF_TOKEN}\" \\
                        --cookie \"${JSESSION_ID}\" \\
                        --noproxy \"${CDF_APISERVER_HOST}\" \\
                        -d '$body' \\
                        \"${BASE_URL}${api_url}\"" -p=true)
        local http_code=${apiResult:0-3}
        if [ "$http_code" -ge "200" ] && [ "$http_code" -lt "300" ]; then
            break
        else
            if [ "$count" -lt "$RETRY_TIMES" ]; then
                count=$(( count + 1 ))
                write_log "debug" "Request init deployment. Wait for $SLEEP_TIME seconds and retry: $count "
                sleep $SLEEP_TIME
            else
                write_log "fatal" "Faild to init deployment, ${apiResult}. For detail logs, please refer to $LOG_FILE"
            fi
        fi
    done
    write_log "debug" "The request for init deployment has been accepted by the cdf-apiserver."
}

checkInitDeploymentStatus(){
    write_log "debug" "Check init deployment status..."
    local count=0
    while true;do
        getXtoken
        getCsrfTokenSessionID
        local api_url="/urest/v1.1/deployment/${INIT_DEPLOYMENT_UUID}/initDeployment"
        local apiResponse=$(wrap_curl "curl -k -s -X GET \\
                        -w '%{http_code}' \\
                        --header 'Accept: application/json' \\
                        --header '${X_AUTH_TOKEN}' \\
                        --noproxy '${CDF_APISERVER_HOST}' \\
                        '${BASE_URL}${api_url}'" -p=true)
        local http_code=${apiResponse:0-3}
        if [ "$http_code" -ge "200" ] && [ "$http_code" -lt "300" ]; then
            local status=$(echo "${apiResponse:0:-3}"|$JQ -r '.threadInfo.threadStatus')
            if [[ "$status" == "COMPLETED" ]];then
                break
            fi
            if [[ "$status" == "EXCEPTION" ]];then
                write_log "fatal" "Failed to check init deployment status.\nAPI response: ${apiResponse}. For detail logs, please refer to $LOG_FILE"
            fi
        else
            write_log "debug" "Failed to check init deployment status.\nAPI response: ${apiResponse}."
        fi
        if [ "$count" -lt "360" ]; then
            write_log "debug" "Check init deployment status status: $status. Wait for $SLEEP_TIME seconds and retry: $count "
            count=$(( count + 1 ))
            sleep $SLEEP_TIME
        else
            write_log "fatal" "Timeout to check init deployment status.\nAPI response: ${apiResponse}. For detail logs, please refer to $LOG_FILE"
        fi
    done
    write_log "debug" "Init deployment completed by the cdf-apiserver."
}

# Please do not rename this function name: $func_name_flag === initDeployment
initDeployment(){
    if stepNotDone $FUNCNAME; then
        requestInitDeployment
        checkInitDeploymentStatus
        setStepDone $FUNCNAME
    fi
}

createDeployment(){
    if [[ -n "$METADATA" ]] || ([ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" -o "$CAPS_CLUSTER_MANAGEMENT" == "true" ] && [ -n "$SILENT_CONFIG_FILE" ]);then

    write_log "step" "Init deployment ..."
    if stepNotDone $FUNCNAME; then
        initDeploymentAlready
        precheckInitDeploymentStatus
        initDeployment
        setStepDone $FUNCNAME
        showStatus "ok"
    else
        showStatus "Already done"
    fi

    fi
}

validateLifecycleSupport(){
    local lifecycle=$1
    getXtoken
    getCsrfTokenSessionID
    write_log "debug" "Checking if $lifecycle action is supported via API ..."
    local api_url="/urest/v1.1/deployment/${DEPLOYMENT_UUID}/lifecycle"
    local apiResponse=$(wrap_curl "curl -k -s -X GET \\
                    -w '%{http_code}' \\
                    --header 'Accept: application/json' \\
                    --header '${X_AUTH_TOKEN}' \\
                    --noproxy '${CDF_APISERVER_HOST}' \\
                    '${BASE_URL}${api_url}'" -p=true)
    local http_code=${apiResponse:0-3}
    if [ "$http_code" != "200" ]; then
        write_log "fatal" "API response: ${apiResponse:0:-3}"
    else
        local change_enabled=$(echo "${apiResponse:0:-3}" | $JQ -r ".change.enabledAPI" )
        local reconfig_enabled=$(echo "${apiResponse:0:-3}" | $JQ -r ".reconfig.enabledAPI" )
        local update_enabled=$(echo "${apiResponse:0:-3}" | $JQ -r ".update.enabledAPI" )
        if [ "$lifecycle" = "reconfig" ]; then
            if [ "$change_enabled" != "true" -a "$reconfig_enabled" != "true" ]; then
                write_log "fatal" "suite $lifecycle is NOT supported via API.\nAPI response: ${apiResponse:0:-3}"
            else
                write_log "debug" "suite $lifecycle is supported via API."
            fi
        elif [ "$lifecycle" = "update" ]; then
            if [ "$update_enabled" != "true" ]; then
                write_log "fatal" "suite $lifecycle is NOT supported via API.\nAPI response: ${apiResponse:0:-3}"
            else
                write_log "debug" "suite $lifecycle is supported via API."
            fi
        fi
    fi
}

validateBeforeUpdate(){
    local count=0
    while true;do
        getXtoken
        getCsrfTokenSessionID
        write_log "debug" "Validating before update ..."
        local api_url="/urest/v1.1/deployment/${DEPLOYMENT_UUID}/update?validate=true"
        local config_json="$(cat $SILENT_CONFIG_FILE | sed -e 's/'\''/'\''\\'\'''\''/g')"
        record "curl -k -s -X POST \\
                        -w '%{http_code}' \\
                        --header 'Content-Type: application/json' \\
                        --header 'Accept: application/json' \\
                        --header '${X_AUTH_TOKEN}' \\
                        --header '${X_CSRF_TOKEN}' \\
                        --noproxy '${CDF_APISERVER_HOST}' \\
                        --cookie '${JSESSION_ID}' \\
                        -d '***' \\
                        '${BASE_URL}${api_url}'"
        local apiResponse=$(wrap_curl "curl -k -s -X POST \\
                        -w '%{http_code}' \\
                        --header 'Content-Type: application/json' \\
                        --header 'Accept: application/json' \\
                        --header '${X_AUTH_TOKEN}' \\
                        --header '${X_CSRF_TOKEN}' \\
                        --noproxy '${CDF_APISERVER_HOST}' \\
                        --cookie '${JSESSION_ID}' \\
                        -d '${config_json}' \\
                        '${BASE_URL}${api_url}'" -p=true -m=false)
        local http_code=${apiResponse:0-3}
        if [[ "$http_code" == "200" ]]; then
            write_log "debug" "Validating before update pass"
            break
        fi
        if [[ "$count" -lt 12 ]]; then
            write_log "debug" "Validating before update status: $status. Wait for $SLEEP_TIME seconds and retry: $count "
            count=$(( count + 1 ))
            sleep $SLEEP_TIME
        else
            echo ""
            write_log "fatal" "Validation failed.\nAPI response: ${apiResponse}."
        fi
    done
}

validateUpdateUser(){
    local val="$1"
    if [[ $(echo $val|grep -P "\s" >/dev/null 2>&1; echo $?) -ne 0 ]] && [[ "${#val}" -ge 1 ]]; then
        return 0
    else
        return 1
    fi
}

inputUpdateUser(){
    #hardcode the admin user name and remove -u|--username option, ref: US#1216804
    SILENT_SUPERUSER="admin"
    if [[ -z "$SUPER_USERPWD" ]];then
        read -s -r -p "Administrator password: " user_pwd_1
        while [[ $(validateUpdateUser "$user_pwd_1"; echo $?) -ne 0 ]]; do
            echo -e "\nSorry, the password is incorrect."
            read -s -r -p "Administrator password: " user_pwd_1
        done
        echo ""
        SUPER_USERPWD=$user_pwd_1
    fi
}

checkJsonForUpdate(){
    if [[ -z "$SILENT_CONFIG_FILE" ]] || [[ ! -f "$SILENT_CONFIG_FILE" ]];then
        write_log "fatal" "Need provide json file for silent suite update. Type ./install -h for help."
    fi

    inputUpdateUser

    write_log "loading" "$MSG_CHECK_CONFIG_JSON"

    local cdfApiServerIP=$(exec_cmd "kubectl get svc suite-installer-svc -n ${CDF_NAMESPACE} -o custom-columns=clusterIP:.spec.clusterIP --no-headers 2>/dev/null" -p=true)
    if [ -z "${cdfApiServerIP}" ];then
        write_log "fatal" "Failed to get IP address of cdf-apiserver pod"
    fi

    getDeploymentUuid
    validateLifecycleSupport "update"
    validateBeforeUpdate

    stopLoading
    echo ""
}

checkInfraReady(){
    sourceCdfProfile
    if [[ -n "${CDF_HOME}" ]] && [[ -f "${CDF_HOME}/bin/env.sh" ]];then
        source ${CDF_HOME}/bin/env.sh
    fi
    while true;do
        # clean install ?
        if [[ -z "$CDF_HOME" ]] || [[ -z "$(ls -A "$CDF_HOME" 2>/dev/null)" ]] || [[ "$(ls -A "$CDF_HOME" 2>/dev/null)" == "log" ]];then
            SILENT_LIFECYCLE=
            break
        fi
        # reinstall ?
        if [[ -f "$CDF_INSTALL_RUNTIME_HOME/.cdfInstallCompletedSteps.tmp" ]];then
            if [[ "$CURRENTDIR" == "${CDF_HOME}" ]];then
                write_log "fatal" "The installation is not completed, please go to the build directory and continue to install."
            fi
            break
        fi

        ### update/reconfig

        # run './install' in an error folder, for example: <build folder>
        if [[ "$CURRENTDIR" != "${CDF_HOME}" ]];then
            write_log "fatal" "The $PRODUCT_INFRA_NAME runtime environment has been installed already. You must run commands from the '${CDF_HOME}' folder."
        fi
        # update/reconfig ?
        if [[ -n "$SILENT_LIFECYCLE" ]];then
            break
        fi
        # from 2020.05, install not support secondary deployment
        if kubectl get ep -n ${CDF_NAMESPACE}|awk '{if($1=="cdf-svc")print $2}'|grep -Pq '(\d{1,3}\.){3}\d{1,3}:\d+';then
            write_log "fatal" "Missing specific operation options: update/reconfig."
        fi
        break
    done
}

usage_noinfra(){
    echo -e "
    Usage: $0 [Options]

    Options:
    ## Directories
      --cdf-home               Specifies the absolute path of the installation directory.
                               By default, the installation directory is \"\$HOME/cdf\".
      --tmp-folder             Specifies the absolute path of the temporary folder for placing temporary files.
                               The default temporary folder is '/tmp'.

    ## General K8s cluster settings
      --cluster-name           Specifies the logical name indicates where or what the installation is.
                               The default name is 'cluster-<random numbers>'.
      --k8s-provider           Specifies the k8s provider when installing $PRODUCT_APP_NAME on a k8s cluster.
                               The allowed value of this parameter is 'aws', 'azure', 'gcp', 'openshift', 'generic'.(case insensitive)
      --ipv6                   Whether to enable dual-stack networking. The allowed value of this parameter is 'true' or 'false'.
                               By default, the value is 'false', enable single-stack networking.
      --tls-ciphers            Specifies a list of TLS ciphers. Comma separated cipher list. For example,
                               'TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_AES_128_GCM_SHA256,TLS_AES_256_GCM_SHA384'.
                               By default, 'TLS_AES_128_GCM_SHA256,TLS_AES_256_GCM_SHA384,TLS_CHACHA20_POLY1305_SHA256,
                               TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
                               TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                               TLS_AES_128_CCM_8_SHA256,TLS_AES_128_CCM_SHA256' is used.
      --tls-min-version        Specifies minimum accepted TLS version.
                               The allowed values of this parameter are: 'TLSv1.2', 'TLSv1.3'
                               By default, 'TLSv1.2' is used.
                               Note: If you are using Azure Application Gateway, don't set the TLS_MIN_VERSION to TLSv1.3, which isn't supported currently.

    ## Registry settings
      --registry-ca            Specifies the path of trusted CA root certificate (bas64 X.509 format) of external registry.
      --registry-orgname       Specifies the organization name(namespace) where the suite images are placed.
                               The default name is 'hpeswitom'.
      --registry-password      Specifies the password for registry.
      --registry-password-file Specifies the password file for registry.
      --registry-url           Specifies the url for registry.
      --registry-username      Specifies the username for registry.

    ## Install script settings
      -c, --config             Specifies the absolute path of the configuration json file for silent installation.
      -P, --password           Specifies the password for suite administrator which will be created during installation.
                               Wrap the password with single quotes. For example, 'Password@#\$!123'.
      --skip-warning           Option used to skip the warning(s) in precheck when install.

    ## Application settings
      --app-http-proxy         Specifies the http_proxy setting in pods for application containers.
      --app-https-proxy        Specifies the https_proxy setting in pods for application containers.
      --app-no-proxy           Specifies the no_proxy setting in pods for application containers.
      --apphub-cluster-admin   Option used to enable cluster-admin permissions (aka god-mode) for Apphub.
                               Use '--apphub-cluster-admin' option to enable.
      --apphub-helm-values     Specifies YAML file containing customized configuration for AppHub chart.
                               This file will take higher priority than other settings.
                               Please use this option with the help of techincal support only or you do understand this option clearly.
      --aws-certificate-arn    Specifies the certificate-arn for external ingress on aws.
      --backup-resource-group  Specifies the resource group name used for backup (Azure only).
      --backup-storage-account Specifies the storage account name used for backup (Azure only).
      --backup-storage-api-ca  Specifies the path to storage API CA certificate file.
      --backup-storage-api-url Specifies the URL of storage API.
      --backup-storage-bucket  Specifies the storage bucket name for backup when K8sBackup capability is enabled.
      --backup-storage-credential-file  Specifies the credential file used for accessing storage bucket.
      --backup-storage-secret  Specifies the secret name which contains the credential for accessing storage bucket.
      --capabilities           $PRODUCT_APP_NAME installation capabilities
                               Specify the $PRODUCT_APP_NAME installation capabilities as
                               a comma-delimited set of key=true|false pairs.
                               Supported capabilities (default):
                               ClusterManagement=false
                               DeploymentManagement=true
                               LogCollection=false
                               Monitoring=false
                               MonitoringContent=false
                               NfsProvisioner=false
                               Tools=true
                               K8sBackup=false
      --cat, --cdf-admin-tasks Specifies the admin task for $PRODUCT_SHORT_NAME.
                               The allowed value of this parameter is 'ns','no','pv','cr','pc'.
                               Example: --cdf-admin-tasks 'ns,cr,pv'  (Separate multiple types with commas)
                               The default value is 'ns,no,pv,cr,pc'.
                               Remarks:
                                  ns: Namespace,      no: Node,         pv: PersistentVolumes
                                  cr: ClusterRole,    pc: PriorityClass
      --cdf-namespace          Specifies the $PRODUCT_APP_NAME namespace. The default namespace is 'core'.
      --cluster-wide-ingress   Determine whether to enable external ingress on aws, The allowed value
                               of this parameter is 'true' or 'false'. By default, the value is 'false'.
      -d, --deployment-name    Specifies the deployment name for suite installation.
      --db-crt                 External cdfapiserver database ca certificate.
      --db-tls-skip-hostname-verification  Whether to skip the verification of the hostname in the certificate
                               when using the external cdfapiserver database ca certificate. The allowed value
                               of this parameter is 'true' or 'false'. By default, the value is 'false'.
      --db-password            External cdfapiserver database password.
      --db-url                 External cdfapiserver database connection url.
      --db-user                External cdfapiserver database user name.
      --enable-fips            Option used to allow suties/customer to disable/enable fips. The allowed value
                               of this parameter is 'true' or 'false'. By default, the value is 'false', disable fips.
      --external-access-host   Specifies the external access host.
      --external-access-port   Specifies the external access port.
      -fg, --feature-gates     A set of key=value pairs that describe feature gates for alpha/experimental features.
                               The allowed value of this parameter is mapStringBool.
                               Comma-delimited list of strings, each entry format is NameOfFeature=true|false.
                               Options are:"
      listFeatureGates
      echo -e "      --loadbalancer-info      Specifies the loadbalancer info.
                               This parameter value formats such as: \"KEY1=VALUE1;KEY2=VALUE2;...;KEYn=VALUEn\"
                               Example:
                                 For gcp:
                                   --loadbalancer-info \"LOADBALANCERIP=x.x.x.x\"
                                 For aws:
                                   --loadbalancer-info \"aws-load-balancer-type=nlb;aws-load-balancer-internal=true;LOADBALANCERSOURCERANGES=172.10.0.0/16,172.20.0.0/16\"
                                 For azure:
                                   --loadbalancer-info \"azure-load-balancer-internal=true\"
                                 For generic:
                                   --loadbalancer-info \"LOADBALANCER=true\"
      --logging-vol-size       Specifies the volume size of fluentd component. The size must be a plain integer or as a
                               fixed-point integer and the unit must be one of E,P,T,G,M,K,Ei,Pi,Ti,Gi,Mi,Ki; example: 10Gi
      --nfs-folder             Specifies the folder for NFS, used to create persistent volume claim 'itom-vol-claim'.
                               Make sure the folder is available and empty.
      --nfs-server             Specifies the server for NFS, used to create persistent volume claim 'itom-vol-claim'.
      --nfsprov-folder         Specifies the folder for NFS, used to create NFS provisioner.
                               Make sure the folder is available and empty.
      --nfsprov-server         Specifies the server for NFS, used to create NFS provisioner.
      --node-selector          Specifies the node selector for pods. A comma-separated list of key value pairs and enclosed with single quotes.
                               Example: 'KEY1=VALUE1,KEY2=VALUE2,...,KEYn=VALUEn'
      --set-fqdn-in-ingress    Option used to set FQDN in ingress. Use '--set-fqdn-in-ingress' option to enable.
      --storage-class          Specifies the default storageClass name while creating persistent volumes and persistent volume claims.
      --storage-class-mappings Mapping storageClass name while creating persistent volumes and persistent volume claims.
                               A set of key=value pairs that mapping storageClass name while creating persistent volumes and persistent volume claims
                               comma-delimited list of strings, each entry format is 'storageclass-a=storageclass-1'
                               For example,\"itom-fast=demo-quick,itom-slow=demo-slow\".
      --system-group-id        Specifies the group ID that is used to start the process in container.
                               The default group ID is '1999'.
      --system-user-id         Specifies the user ID to start the process in container.
                               The default user ID is '1999'.
      --ca-folder              User provided folder which contains CA certificate and CA key.

    Usage examples:
    # PV managed by cluster admin
    $0 --registry-url <registry-url> --external-access-host <external-access-host> --k8s-provider <k8s-provider> [Options]

    # PV managed by $PRODUCT_SHORT_NAME
    $0 --nfs-server <nfs-server> --nfs-folder <nfs-folder> --registry-url <registry-url> --external-access-host <external-access-host> --k8s-provider <k8s-provider> [Options]
"
    exit 1;
}

usage(){
    if [ "$INSTALLED_TYPE" = "BYOK" ] || [ "$CLI_NOINFRA" = "true" ];then
        usage_noinfra
    else
        usage_classic
    fi
}

checkShaByField(){
    local field=$1
    # $masterNodes_sha
    local field_sha=$(eval "echo \"\$${field}_sha\"")
    # $_masterNodes_sha
    local _field_sha=$(eval "echo \"\$_${field}_sha\"")
    if [[ "$field_sha" != "$_field_sha" ]];then
        write_log "fatal" "The configuration file ($SILENT_CONFIG_FILE) has been uploaded to cdf-apiserver, and configuration file modification is not supported at this stage. (The '.${field}' field has changed)"
    fi
}

configFieldsSha(){
    local op=$1
    local allowWorkerOnMaster_sha=$(cat $SILENT_CONFIG_FILE|$JQ -r '.allowWorkerOnMaster'                                                      2>/dev/null|sha256sum|awk '{print $1}')
    local masterNodes_sha=$(        cat $SILENT_CONFIG_FILE|$JQ -r '.masterNodes[]   |with_entries(.key=.key|.value=.value)'                   2>/dev/null|sha256sum|awk '{print $1}')
    local workerNodes_sha=$(        cat $SILENT_CONFIG_FILE|$JQ -r '.workerNodes[]   |with_entries(.key=.key|.value=.value)'                   2>/dev/null|sha256sum|awk '{print $1}')
    local volumes_sha=$(            cat $SILENT_CONFIG_FILE|$JQ -r '.volumes[]       |with_entries(.key=.key|.value=.value)'                   2>/dev/null|sha256sum|awk '{print $1}')
    local licenseAgreement_sha=$(   cat $SILENT_CONFIG_FILE|$JQ -r '.licenseAgreement|with_entries(.key=.key|.value=.value)'                   2>/dev/null|sha256sum|awk '{print $1}')
    local connection_sha=$(         cat $SILENT_CONFIG_FILE|$JQ -r '.connection      |with_entries(.key=.key|.value=.value)'                   2>/dev/null|sha256sum|awk '{print $1}')
    local database_sha=$(           cat $SILENT_CONFIG_FILE|$JQ -r '.database        |with_entries(.key=.key|.value=.value)'                   2>/dev/null|sha256sum|awk '{print $1}')
    local capabilities_sha=$(       cat $SILENT_CONFIG_FILE|$JQ -r '.capabilities    |with_entries(.key=.key|.value=.value)'                   2>/dev/null|sha256sum|awk '{print $1}')
    if [[ "$op" == "init" ]];then
        exec_cmd "echo \"_allowWorkerOnMaster_sha=$allowWorkerOnMaster_sha\" >> $PREVIOUS_INSTALL_CONFIG"
        exec_cmd "echo \"_masterNodes_sha=$masterNodes_sha\"                 >> $PREVIOUS_INSTALL_CONFIG"
        exec_cmd "echo \"_workerNodes_sha=$workerNodes_sha\"                 >> $PREVIOUS_INSTALL_CONFIG"
        exec_cmd "echo \"_volumes_sha=$volumes_sha\"                         >> $PREVIOUS_INSTALL_CONFIG"
        exec_cmd "echo \"_licenseAgreement_sha=$licenseAgreement_sha\"       >> $PREVIOUS_INSTALL_CONFIG"
        exec_cmd "echo \"_connection_sha=$connection_sha\"                   >> $PREVIOUS_INSTALL_CONFIG"
        exec_cmd "echo \"_database_sha=$database_sha\"                       >> $PREVIOUS_INSTALL_CONFIG"
        exec_cmd "echo \"_capabilities_sha=$capabilities_sha\"               >> $PREVIOUS_INSTALL_CONFIG"
    elif [[ "$op" == "check" ]];then
        source $PREVIOUS_INSTALL_CONFIG
        for field in allowWorkerOnMaster masterNodes workerNodes volumes licenseAgreement connection database capabilities;do
            checkShaByField "$field"
        done
    fi
}

calcConfigContentSha(){
    local volumes;volumes=$(cat "$SILENT_CONFIG_FILE"|$JQ -r '.volumes')
    local capabilities;capabilities=$(cat "$SILENT_CONFIG_FILE"|$JQ -r '.capabilities|.configuration=[]')
    CALC_CONFIG_SHA=$(echo "{}"|$JQ -r ".capabilities=$capabilities|.volumes=$volumes" -S -c|sha256sum|awk '{print $1}')
}

signConfigContent(){
    # for install
    if [[ -z "$SILENT_LIFECYCLE" ]] && [[ -f "$SILENT_CONFIG_FILE" ]];then
        configFieldsSha "init"
    fi
    # for update
    if [[ "$SILENT_LIFECYCLE" == "update" ]] && [[ -f "$SILENT_CONFIG_FILE" ]];then
        calcConfigContentSha
        exec_cmd "echo \"CONFIG_JSON_SHA='$CALC_CONFIG_SHA'\" >> $PREVIOUS_INSTALL_CONFIG"
    fi
}

stepAlreadyDone(){
    # _STEPS_FILE from PREVIOUS_INSTALL_CONFIG
    [ "$(grep $1 $_STEPS_FILE 2>/dev/null|wc -l)" -eq 0 ] && return 1 || return 0
}

checkConfigContent(){
    # for install
    if [[ -z "$SILENT_LIFECYCLE" ]] && [[ -f "$SILENT_CONFIG_FILE" ]];then
        if stepAlreadyDone "@updateFullJsonParams";then
            configFieldsSha "check"
        fi
    fi
    # for update
    if [[ "$SILENT_LIFECYCLE" == "update" ]] && [[ -f "$SILENT_CONFIG_FILE" ]];then
        calcConfigContentSha
        if [[ "$CALC_CONFIG_SHA" != "$CONFIG_JSON_SHA" ]];then
            write_log "fatal" "You modified the configuration file, silent rerun does not support modifying the configuration file."
        fi
    fi
}

signParamFiles(){
        # $SILENT_CONFIG_FILE
    local files;files="
        $CONFIGFILE
        $METADATA
        $REGISTRY_CA
        $FLUENTD_LOG_RECEIVER_CA
        $REGISTRY_PASSWORD_FILE
    "
    local sha_json='[]'
    for file in $files;do
        if [[ -n "$file" ]] && [[ -f "$file" ]];then
            local sha;sha=$(sha256sum "$file"|awk '{print $1}')
            sha_json=$(exec_cmd "echo '$sha_json'|$JQ -r '.|=.+[{\"file\":\"$file\",\"sha\":\"$sha\"}]' " -p=true)
        fi
    done
    local json_base64;json_base64="$(echo "$sha_json"|base64 -w0)"
    exec_cmd "echo \"FILES_SHA_BASE64='$json_base64'\" >> $PREVIOUS_INSTALL_CONFIG"
}

checkParamFiles(){
    local json;json=$(echo $FILES_SHA_BASE64|base64 -d)
    local num;num=$(echo $json|$JQ -r '.|length')
    local n=0
    while [[ "$n" -lt "$num" ]];do
        local file;file=$(echo $json|$JQ -r ".[$n].file")
        local sha;sha=$(echo $json|$JQ -r ".[$n].sha")
        if [[ ! -f "$file" ]];then
            write_log "fatal" "Cannot continue to install, file '$file' not found."
        fi
        local cur_sha;cur_sha=$(sha256sum "$file"|awk '{print $1}')
        if [[ "$cur_sha" != "$sha" ]];then
            write_log "fatal" "You modified the configuration file '$file', silent rerun does not support modifying the configuration file."
        fi
        n=$((n+1))
    done
}

validateContinuePassword(){
    local pwd="$1"
    local passwd_sha;passwd_sha=$(echo "$pwd"|sha256sum|awk '{print $1}')
    if [[ "$passwd_sha" == "$PASSWD_SHA" ]]; then
        return 0
    else
        return 1
    fi
}

inputContinuePassword(){
    if [[ -z "$SUPER_USERPWD" ]] && [[ -f "$SILENT_CONFIG_FILE" ]];then
        #get adminPassword if exist
        local hasAdminPwd=$($JQ 'has("adminPassword")' $SILENT_CONFIG_FILE)
        if [ "$hasAdminPwd" = "true" ]; then
            local adminPassword=$($JQ -r '.adminPassword' $SILENT_CONFIG_FILE)
            validatePwd "$adminPassword" && SUPER_USERPWD="$adminPassword" || write_log "fatal" "The admin password in $SILENT_CONFIG_FILE does not meet policy requirement. Please update the password and try again.\n$(printPasswordPolicy)"
            return 0
        fi
    fi
    if [[ -z "$SUPER_USERPWD" ]];then
        read -s -r -p "Administrator password: " user_pwd_1
        while [ $(validateContinuePassword "$user_pwd_1"; echo $?) -ne 0 ]; do
            echo -e "\nSorry, the password is incorrect."
            read -s -r -p "Administrator password: " user_pwd_1
        done
        echo ""
        SUPER_USERPWD=$user_pwd_1
    else
        if [ $(validateContinuePassword "$SUPER_USERPWD"; echo $?) -ne 0 ];then
            write_log "fatal" "Your administrator password does not match the previous password."
        fi
    fi
}

checkOpenssl(){
    local sha;sha="$(echo "cdf"|sha256sum|awk '{print $1}')"
    local encry;encry="$(echo "cdf"|openssl enc -e -aes-256-cbc -a -K "${sha:0:32}" -iv "${sha:32:32}" -nosalt 2>/dev/null)"
    local origin;origin="$(echo "$encry"|openssl enc -e -aes-256-cbc -a -K "${sha:0:32}" -iv "${sha:32:32}" -nosalt -d 2>/dev/null)"
    if [[ "$origin" != "cdf" ]];then
        write_log "fatal" "The current system cannot use openssl to encrypt and decrypt strings."
    fi
}

continueInstall(){
    local opt_list=("--db-user --db-password --db-url --db-crt --backup-storage-bucket --backup-storage-credential-file --backup-storage-secret --backup-resource-group --backup-storage-account --backup-storage-api-url --backup-storage-api-ca")
    local passwd_sha;passwd_sha=$(echo "$SUPER_USERPWD"|sha256sum|awk '{print $1}')
    local json;json=$(echo "$ENCRY_CLI_ARGS"|base64 -d|openssl enc -e -aes-256-cbc -a -K "${passwd_sha:0:32}" -iv "${passwd_sha:32:32}" -nosalt -d 2>/dev/null|base64 -d)
    local install_args="$CURRENTDIR/install"
    local num;num=$(echo $json|$JQ -r '.|length')
    local n=0 new_json="[]"
    while [[ "$n" -lt "$num" ]];do
        local found="false"
        local cli;cli=$(echo $json|$JQ -r ".[$n].cli")
        for opt in ${opt_list};do
            if [ "$cli" == "$opt" ];then
                found="true"
                break
            fi
        done
        if [ "$found" == "true" ];then
            local found_in_new="false"
            local cur_cli_arg_json_len=$(echo "$CLI_ARGS_JSON" | $JQ -r '.|length')
            for((i=0;i<$cur_cli_arg_json_len;i++));do
                if [ $(echo "$CLI_ARGS_JSON" | $JQ -r ".[$i].cli") == "$cli" ];then
                    local new_val;new_val=$(echo "$CLI_ARGS_JSON"|$JQ -r ".[$i].val"|base64 -d)
                    install_args="$install_args $cli '$(echo "$new_val"|sed -e "s/'/'\\\\''/g")'"
                    new_json=$(echo "$new_json"|$JQ -r ".|=.+[{\"cli\":\"$cli\",\"val\":\"$(echo "$new_val"|base64 -w0)\"}]")
                    found_in_new="true"
                    break
                fi
            done
            if [ "$found_in_new" == "false" ];then #the new install cmd not provide the db info, should use the old ones
                local has_val;has_val=$(echo $json|$JQ -r ".[$n]|has(\"val\")")
                if [[ "$has_val" == "true" ]];then
                    local val;val=$(echo $json|$JQ -r ".[$n].val"|base64 -d)
                    install_args="$install_args $cli '$(echo "$val"|sed -e "s/'/'\\\\''/g")'"
                    new_json=$(echo "$new_json"|$JQ -r ".|=.+[{\"cli\":\"$cli\",\"val\":\"$(echo "$val"|base64 -w0)\"}]")
                else
                    install_args="$install_args $cli"
                fi
            fi
        else
            local has_val;has_val=$(echo $json|$JQ -r ".[$n]|has(\"val\")")
            if [[ "$has_val" == "true" ]];then
                local val;val=$(echo $json|$JQ -r ".[$n].val"|base64 -d)
                install_args="$install_args $cli '$(echo "$val"|sed -e "s/'/'\\\\''/g")'"
                new_json=$(echo "$new_json"|$JQ -r ".|=.+[{\"cli\":\"$cli\",\"val\":\"$(echo "$val"|base64 -w0)\"}]")
            else
                install_args="$install_args $cli"
                new_json=$(echo "$new_json"|$JQ -r ".|=.+[{\"cli\":\"$cli\"}]")
            fi
        fi
        n=$((n+1))
    done

    sed -i -e "/ESCAPE_CLI_ARGS_BASE64=/ d" $PREVIOUS_INSTALL_CONFIG
    sed -i -e "/ENCRY_CLI_ARGS=/ d" $PREVIOUS_INSTALL_CONFIG
    sed -i -e "/SIGN=/ d" $PREVIOUS_INSTALL_CONFIG

    ESCAPE_CLI_ARGS_BASE64=$(cat $TMP_CLI_ARGS_BASE64_CONFIG 2>/dev/null)
    rm -f $TMP_CLI_ARGS_BASE64_CONFIG

    local encry_cli_args;encry_cli_args=$(echo "$new_json"|base64 -i|openssl enc -e -aes-256-cbc -a -K "${passwd_sha:0:32}" -iv "${passwd_sha:32:32}" -nosalt 2>/dev/null|base64 -w0)
    exec_cmd "echo \"ESCAPE_CLI_ARGS_BASE64='$ESCAPE_CLI_ARGS_BASE64'\" >> $PREVIOUS_INSTALL_CONFIG"
    exec_cmd "echo \"ENCRY_CLI_ARGS='$encry_cli_args'\" >> $PREVIOUS_INSTALL_CONFIG"
    ENCRY_CLI_ARGS=$encry_cli_args
    local sign;sign=$(signContinueConfig "$SUPER_USERPWD")
    exec_cmd "echo \"SIGN='$sign'\" >> $PREVIOUS_INSTALL_CONFIG"

    showStatus "ok"
    eval "$install_args --just-for-cdf-silent-rerun true"
    return $?
}

signContinueConfig(){
    local passwd=$1
    echo "$ESCAPE_CLI_ARGS_BASE64-$PASSWD_SHA-$FILES_SHA_BASE64-$ENCRY_CLI_ARGS-$passwd"|sha256sum|awk '{print $1}'
}

saveParamsFromInteractive(){
    # if some params from user interactive input, should save to CLI_ARGS_JSON
    for passwd_group in '--password -P' '--username -u' '--registry-username' '--registry-password' '--fluentd-log-receiver-password' '--skip-warning' '--db-password';do
        local has_cli=""
        for cli_name in $passwd_group;do
            has_cli=$(exec_cmd "echo '$CLI_ARGS_JSON'|$JQ -r '.[]|select(.cli==\"$cli_name\").cli'" -p=true -m=false -o=false)
            if [[ -n "$has_cli" ]];then
                break
            fi
        done
        # if the cli missing, but the val exist, we should append to CLI_ARGS_JSON
        if [[ -z "$has_cli" ]];then
            if [[ "$cli_name" == '--skip-warning' ]];then
                CLI_ARGS_JSON=$(exec_cmd "echo '$CLI_ARGS_JSON'|$JQ -r '.|=.+[{\"cli\":\"$cli_name\"}]' " -p=true -m=false -o=false)
                continue
            fi

            local val=""
            if [[ "$cli_name" =~ ^(--password|-P)$ ]] && [[ -n "$SUPER_USERPWD" ]];then
                val="$SUPER_USERPWD"
            elif [[ "$cli_name" == '--registry-username' ]] && [[ -n "$REGISTRY_USERNAME" ]];then
                val="$REGISTRY_USERNAME"
            elif [[ "$cli_name" == '--registry-password' ]] && [[ -n "$REGISTRY_PASSWORD" ]];then
                val="$REGISTRY_PASSWORD"
            elif [[ "$cli_name" == '--fluentd-log-receiver-password' ]] && [[ -n "$FLUENTD_LOG_RECEIVER_PASSWORD" ]];then
                val="$FLUENTD_LOG_RECEIVER_PASSWORD"
            elif [[ "$cli_name" =~ ^(-u|--username)$ ]] && [[ -n "$SILENT_SUPERUSER" ]];then
                val="$SILENT_SUPERUSER"
            elif [[ "$cli_name" == '--db-password' ]] && [[ -n "$SUITEDB_PASSWORD" ]];then
                val="$SUITEDB_PASSWORD"
            fi
            if [[ -n "$val" ]];then
                ESCAPE_CLI_ARGS="$ESCAPE_CLI_ARGS \\ \n \t$cli_name ******"
                CLI_ARGS_JSON=$(exec_cmd "echo '$CLI_ARGS_JSON'|$JQ -r '.|=.+[{\"cli\":\"$cli_name\",\"val\":\"$(echo "$val"|base64 -w0)\"}]' " -p=true -m=false -o=false)
            fi
        fi
    done
}

createContinueConfig(){
    if stepNotDone $FUNCNAME; then
        saveParamsFromInteractive

        echo '' > $PREVIOUS_INSTALL_CONFIG

        exec_cmd "echo \"_STEPS_FILE=$STEPS_FILE\" >> $PREVIOUS_INSTALL_CONFIG"

        exec_cmd "echo \"DEPLOYMENT_UUID=$DEPLOYMENT_UUID\" >> $PREVIOUS_INSTALL_CONFIG"
        exec_cmd "echo \"DEPLOYMENT_NAME=$DEPLOYMENT_NAME\" >> $PREVIOUS_INSTALL_CONFIG"

        local cluster_random_id="$(cat /proc/sys/kernel/random/uuid 2>/dev/null|sed 's/-//g'|head -c 10|tr '[A-Z]' '[a-z]')"
        cluster_random_id="${cluster_random_id:-"$(cat /dev/urandom|tr -cd "[:alnum:]"|head -c 10|tr '[A-Z]' '[a-z]')"}"
        exec_cmd "echo \"DEFAULT_CLUSTER_NAME=cluster-$cluster_random_id\" >> $PREVIOUS_INSTALL_CONFIG"

        # save all CLI and properties' args, and escape all passwds
        exec_cmd "echo '$ESCAPE_CLI_ARGS'"
        exec_cmd "echo \"ESCAPE_CLI_ARGS_BASE64='$(echo "$ESCAPE_CLI_ARGS"|base64 -w0)'\" >> $PREVIOUS_INSTALL_CONFIG"

        local passwd_sha;passwd_sha=$(echo "$SUPER_USERPWD"|sha256sum|awk '{print $1}')
        exec_cmd "echo \"PASSWD_SHA='$passwd_sha'\" >> $PREVIOUS_INSTALL_CONFIG"

        signConfigContent
        signParamFiles

        local encry_cli_args;encry_cli_args=$(echo "$CLI_ARGS_JSON"|base64 -i|openssl enc -e -aes-256-cbc -a -K "${passwd_sha:0:32}" -iv "${passwd_sha:32:32}" -nosalt 2>/dev/null|base64 -w0)
        exec_cmd "echo \"ENCRY_CLI_ARGS='$encry_cli_args'\" >> $PREVIOUS_INSTALL_CONFIG"

        echo "INTERNAL_KUBE_REGISTRY_READER_PWD=$INTERNAL_KUBE_REGISTRY_READER_PWD" >> $PREVIOUS_INSTALL_CONFIG
        echo "CLOUDSERVER_SECRET_KEY=$CLOUDSERVER_SECRET_KEY" >> $PREVIOUS_INSTALL_CONFIG
        echo "CLOUDSERVER_CUSTOMER_KEY=$CLOUDSERVER_CUSTOMER_KEY" >> $PREVIOUS_INSTALL_CONFIG

        exec_cmd "chmod 700 $PREVIOUS_INSTALL_CONFIG"

        # reset form file
        ESCAPE_CLI_ARGS_BASE64=""
        PASSWD_SHA=""
        FILES_SHA_BASE64=""
        ENCRY_CLI_ARGS=""
        source $PREVIOUS_INSTALL_CONFIG

        local sign;sign=$(signContinueConfig "$SUPER_USERPWD")
        exec_cmd "echo \"SIGN='$sign'\" >> $PREVIOUS_INSTALL_CONFIG"

        echo ''>> $PREVIOUS_INSTALL_CONFIG
        exec_cmd "sha256sum $PREVIOUS_INSTALL_CONFIG"
        setStepDone $FUNCNAME
    fi
}

saveParams(){
    # Do NOT use exec_cmd() in this function because exec_cmd needs log file,
    # but the tmp folder and log file has not been initialized.
    if [[ -n "$NODE_TYPE" ]] && [[ "$NODE_TYPE" != "first" ]]; then
        return
    fi
    local cli=$1
    local val=$2
    ESCAPE_CLI_ARGS=${ESCAPE_CLI_ARGS:-"$CURRENTDIR/install"}
    CLI_ARGS_JSON=${CLI_ARGS_JSON:-'[]'}
    if [[ "$cli" == "--just-for-cdf-silent-rerun" ]];then
        return
    fi

    local isEmptyValue="false"
    if [[ -z "$val" ]];then
        if [[ "$cli" =~ ^(--cat|--cdf-admin-tasks)$ ]];then
            # allow value is empty, for example: --cat ""
            isEmptyValue="true"
        else
            # no value: for example: --skip-warning
            ESCAPE_CLI_ARGS="$ESCAPE_CLI_ARGS \n $cli"
            CLI_ARGS_JSON=$(echo "$CLI_ARGS_JSON"|$JQ -r ".|=.+[{\"cli\":\"$cli\"}]")
            return
        fi
    fi

    local found="false"
    for escape_cli in '-P' '--password' '--registry-password' '--fluentd-log-receiver-password' '--db-password';do
        if [[ "$escape_cli" == "$cli" ]];then
            found="true"
            break
        fi
    done
    if [[ "$found" == "true" ]];then
        ESCAPE_CLI_ARGS="$ESCAPE_CLI_ARGS \n $cli \"******\""
    else
        ESCAPE_CLI_ARGS="$ESCAPE_CLI_ARGS \n $cli \"$val\""
    fi

    if [[ "$isEmptyValue" == "true" ]];then
        CLI_ARGS_JSON=$(echo "$CLI_ARGS_JSON"|$JQ -r ".|=.+[{\"cli\":\"$cli\",\"val\":\"\"}]")
    else
        CLI_ARGS_JSON=$(echo "$CLI_ARGS_JSON"|$JQ -r ".|=.+[{\"cli\":\"$cli\",\"val\":\"$(echo "$val"|base64 -w0)\"}]")
    fi
}

checkDeploymentUuidExist(){
    local uuid=$1
    if [[ -z "$uuid" ]];then
        return 1
    fi

    inputUpdateUser
    local cdfApiServerIP=$(exec_cmd "kubectl get svc suite-installer-svc -n ${CDF_NAMESPACE} -o custom-columns=clusterIP:.spec.clusterIP --no-headers 2>/dev/null" -p=true)
    if [ -z "${cdfApiServerIP}" ];then
        write_log "fatal" "Failed to get IP address of cdf-apiserver pod"
    fi

    getXtoken
    getCsrfTokenSessionID
    write_log "debug" "Checking deploymentuuid in deployments ..."
    local api_url="/urest/v1.1/deployment?deploymentStatus=NEW&deploymentStatus=FEATURE_SETTED&deploymentStatus=CONF_POD_STARTED&deploymentStatus=SUITE_INSTALL&deploymentStatus=INSTALL_FINISHED&deploymentStatus=INSTALLING&deploymentStatus=RECONFIGURING&deploymentStatus=UPDATING&deploymentStatus=INSTALL_FAILED&deploymentStatus=RECONFIGURE_FAILED&deploymentStatus=UPDATE_FAILED&deploymentStatus=PHASE2_INSTALLING&deploymentStatus=PHASE2_FINISHED&deploymentStatus=PHASE2_FAILED&deploymentMode=suite"
    local apiResult=$(wrap_curl "curl -k -s -X GET \\
                      -w \"%{http_code}\" \\
                      --header 'Content-Type: application/json' \\
                      --header 'Accept: application/json' \\
                      --header \"${X_AUTH_TOKEN}\" \\
                      --header \"${X_CSRF_TOKEN}\" \\
                      --cookie \"${JSESSION_ID}\" \\
                      --noproxy \"${CDF_APISERVER_HOST}\" \\
                      \"${BASE_URL}${api_url}\"" -p=true)
    local http_code=${apiResult:0-3}
    if [ "$http_code" != "200" ]; then
        write_log "fatal" "Getting deploymentuuids error: ${apiResult}"
    else
        local n=0
        local deployment_num=$(echo "${apiResult:0:-3}" | $JQ -r '.|length')
        while [[ $n -lt $deployment_num ]];
        do
            local deployment_uuid=$(echo "${apiResult:0:-3}" | $JQ -r ".[$n].deploymentInfo.deploymentUuid")
            local deployment_name=$(echo "${apiResult:0:-3}" | $JQ -r ".[$n].deploymentInfo.deploymentName")
            if [[ "${deployment_uuid}" == "$uuid" ]]; then
                return 0
            fi
            n=$((n+1))
        done
    fi
    return 1
}
updatePartCliArgs(){
    local opt_list="--db-user \n --db-password \n --db-url \n --db-crt \n --backup-storage-bucket \n --backup-storage-credential-file \n --backup-storage-secret \n --backup-resource-group \n --backup-storage-account \n --backup-storage-api-url \n --backup-storage-api-ca"
    local i=0 prev_cli_args_arrary cur_cli_arg_array new_cli_args tmp_cmd options
    local oldIFS=$IFS
    prev_cli_args_arrary=$(echo $ESCAPE_CLI_ARGS_BASE64|base64 -d)
    IFS=$'\n'
    prev_cli_args_arrary=($(echo -e ${prev_cli_args_arrary}))
    cur_cli_arg_array=($(echo -e ${ESCAPE_CLI_ARGS}))
    options=($(echo -e $opt_list))
    for arg in ${prev_cli_args_arrary[@]};do
        local opt=""
        for option in ${options[@]};do
            if [[ "$arg" =~ "$option" ]];then
                opt=$option
                break
            fi
        done
        local new_arg=""
        if [ -z "$opt" ];then #not the options which may need to change
            new_arg="$arg"
        else
            for cur_arg in ${cur_cli_arg_array[@]};do
                if [[ "$cur_arg" =~ "$opt" ]];then
                    new_arg=$cur_arg
                    break
                fi
            done
        fi
        if [ -n "$new_arg" ];then
            if [ $i -eq 0 ];then
                new_cli_args="$new_arg"
                tmp_cmd="$new_arg"
            else
                new_cli_args="${new_cli_args} \\ \n \t$new_arg"
                tmp_cmd="$tmp_cmd \n $new_arg"
            fi
        else #no found, use old one
            if [ $i -eq 0 ];then
                new_cli_args="$arg"
                tmp_cmd="$arg"
            else
                new_cli_args="${new_cli_args} \\ \n \t$arg"
                tmp_cmd="${tmp_cmd} \n $arg"
            fi
        fi
        ((i++))
    done
    unset IFS
    echo "$tmp_cmd" | base64 -w0 > $TMP_CLI_ARGS_BASE64_CONFIG
    echo "$new_cli_args"
}
checkInstallCompleted(){
    [[ -n "$JUST_FOR_CDF_SILENT_RERUN" ]] && return

    local silentType=${1:-"installation"}
    if [[ -f "$PREVIOUS_INSTALL_CONFIG" ]];then
        # cd "$CURRENTDIR"
        source "$PREVIOUS_INSTALL_CONFIG"  2>/dev/null
        if [ $? -ne 0 ];then
            write_log "fatal" "Unable to load configuration file '$PREVIOUS_INSTALL_CONFIG'."
        fi
        local updateUuidExist=1
        checkDeploymentUuidExist "$DEPLOYMENT_UUID"
        updateUuidExist=$?
        if [[ "$silentType" == "installation" ]] || [[ "$updateUuidExist" == "0" ]];then
            echo -e "! Warning: The previous $silentType did not finish."
            echo -e "Command line from previous $silentType:"
            echo -e "$(updatePartCliArgs)"
            local confirm=""
            while [[ ! "$confirm" =~ ^(y|Y|n|N)$ ]];do
                read -p "> Do you want to continue the previous $silentType? (yY/nN): " confirm
            done
            if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                if [[ "$silentType" != "installation" ]];then
                    echo "Exit"
                    exit 1
                fi
                if [[ "$INSTALLED_TYPE" == "CLASSIC" ]] && [[ -n "$SILENT_CONFIG_FILE" ]];then
                    if grep -e 'launchExtend' $CDF_INSTALL_RUNTIME_HOME/.cdfInstallCompletedSteps.tmp -q 2>/dev/null;then
                        local masters="$(cat $SILENT_CONFIG_FILE|$JQ -r '.masterNodes[].hostname')"
                        local workers="$(cat $SILENT_CONFIG_FILE|$JQ -r '.workerNodes[].hostname')"
                        local nodes="$(echo "$masters $workers"|xargs|sed -r -e 's/ /,/g')"
                        if [[ -n "$nodes" ]];then
                            nodes="($nodes)"
                        fi
                        echo  "! Warning: We will only uninstall $PRODUCT_INFRA_NAME from the current working node. To uninstall $PRODUCT_SHORT_NAME completely, you must log in to other nodes$nodes and run the \$CDF_HOME/uninstall.sh command to uninstall $PRODUCT_INFRA_NAME manually."
                    fi
                fi
                bash "${CDF_HOME}/uninstall.sh"
                exit 0
            fi
            inputContinuePassword
            write_log "step" "Analyze the $silentType steps ..."
            local sign;sign=$(signContinueConfig "$SUPER_USERPWD")
            if [[ "$SIGN" != "$sign" ]];then
                write_log "fatal" "The configuration file '$PREVIOUS_INSTALL_CONFIG' is incorrectly structured and cannot be parsed correctly."
            fi
            checkConfigContent
            checkParamFiles
            continueInstall
            exit $?
        else
            exec_cmd "echo 'Clear invalid cache file: $PREVIOUS_INSTALL_CONFIG'"
            exec_cmd "echo 'Clear invalid cache file: $STEPS_FILE'"
            exec_cmd "$RM -f $PREVIOUS_INSTALL_CONFIG"
            exec_cmd "$RM -f $STEPS_FILE"
        fi
    else
        exec_cmd "echo 'Clear invalid cache file: $STEPS_FILE'"
        exec_cmd "$RM -f $STEPS_FILE"
    fi
}

installCdfAlias(){
    local is_sudo=false
    local source="${CURRENTDIR}/cdf/scripts/itom-cdf-alias.sh"
    if [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
        exec_cmd "$CP -f $source $CDF_ALIAS"
    fi
    exec_cmd "chmod 644 $CDF_ALIAS"
}

cdfAliasWarining(){
    if [[ -z "$SILENT_CONFIG_FILE" ]] && [[ -n "$CDF_ALIAS_WARNING" ]];then
        write_log "warn" "$CDF_ALIAS_WARNING."
    fi
}

showCdfEnvTips(){
    if [[ "$K8S_PROVIDER" =~ ^cdf ]];then
        local cdf_env_file="${CDF_HOME}/bin/env.sh"
    else
        local cdf_env_file="$CDF_PROFILE"
    fi
    export CDF_ENV_VARS_TIPS="How to apply $PRODUCT_SHORT_NAME environment variables:
                             # Load the $PRODUCT_SHORT_NAME environment variables into the current shell
                             source $cdf_env_file
                             source $CDF_ALIAS
                             # or, log out and back in"
    if [[ -z "$SILENT_CONFIG_FILE" ]];then
        write_log "info" "$CDF_ENV_VARS_TIPS."
    fi
}

showCdfHelmNotes(){
    if [[ -z "$SILENT_CONFIG_FILE" ]];then
        exec_cmd "${CDF_HOME}/bin/helm get notes $CDF_HELM_RELEASE_NAME -n $CDF_NAMESPACE"
        if [ $? -eq 0 ];then
            write_log "info" "\n$(${CDF_HOME}/bin/helm get notes $CDF_HELM_RELEASE_NAME -n $CDF_NAMESPACE)"
        fi
    fi
}

checkNamespaceViaSa(){
    local ns=$1
    local reTryTimes=0
    while true; do
        if [ $(exec_cmd "kubectl get sa default -n ${ns}"; echo $?) -eq 0 ]; then
            write_log "debug" "Get sa default on ${ns} successfully."
            break
        elif [ $reTryTimes -eq 3 ]; then
            write_log "debug" "Failed to get default serviceaccount on ${ns} namespace."
            # write_log "fatal" "Namespaces \"${ns}\" not found. $LOG_SUPPORT_MSG" "failed"
            # suite
            if [[ -z "$SILENT_CONFIG_FILE" ]] || [[ -n "$METADATA" ]]; then
                write_log "warn" "User install $PRODUCT_SHORT_NAME with ns-admin setting but the namespace isn't created yet. Try to create the namespace $ns ..."
            fi
            break
        else
            write_log "debug" "Failed to get default serviceaccount on ${ns} namespace. Wait for $SLEEP_TIME seconds and retry: $reTryTimes "
        fi
        reTryTimes=$(( $reTryTimes + 1 ))
        sleep $SLEEP_TIME
    done
}

checkApiResourcesByNs(){
    local ns=$1
    local total=0
    for rs in $(kubectl api-resources --verbs=list --namespaced -o name|grep -v "events.events.k8s.io"|grep -v "events"|sort|uniq);do
        local name;name="$(echo $rs|tr '[:upper:]' '[:lower:]')"
        local count=0
        if [[ "$name" == "serviceaccounts" ]];then
            count="$(kubectl get $rs -n $ns --no-headers 2>/dev/null|awk '$1!="default"'|wc -l)"
        elif [[ "$name" == "secrets" ]];then
            local has_secret;has_secret="$(kubectl get sa default -n $ns -o json 2>/dev/null|$JQ -r '.|has("secrets")')"
            if [[ "$has_secret" == "true" ]];then
                local default_secrets;default_secrets="$(kubectl get sa default -n $ns -o json 2>/dev/null|$JQ -r '.secrets[].name')"
                local pattern;pattern="^($(echo $default_secrets|xargs|tr ' ' '|'))$"
                count="$(kubectl get $rs -n $ns --no-headers 2>/dev/null|awk -v names="$pattern" '$1 !~ names'|wc -l)"
            fi
        else
            count="$(kubectl get $rs -n $ns --no-headers 2>/dev/null|wc -l)"
        fi
        if [[ "$count" -gt 0 ]];then
            total=$(($total + $count))
            write_log "warn" "$count $rs resource$([[ "$count" -gt 1 ]] && echo s) found in $ns namespace"
        fi
    done
    if [[ "$total" -gt 0 ]] && [[ "$CLI_SKIP_PRECHECK_WARNING" != "true" ]];then
        read -p "! Warning: $total resource$([[ "$total" -gt 1 ]] && echo s) found in $ns namespace. Do you want to continue the installation? (yY/nN):" confirm
        if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
            exit 1
        fi
    fi
}

checkDeploymentUuidFormat(){
    if [[ -n "$(echo "$1"|grep -Po '^[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}$')" ]];then
        return 0
    fi
    return 1
}

labelNamespace(){
    local ns=$1
    local key=$2
    local val=$3
    exec_cmd "kubectl label ns ${ns} ${key}=${val}"
    if [ $? -ne 0 ];then
        write_log "fatal" "Failed to label namespace ${ns}. Please label the namespaces with below command:\nkubectl label ns ${ns} ${key}=${val}"
    fi
}

pathNamespaceForNsAdmin(){
    if stepNotDone $FUNCNAME; then
        local suite_ns="$DEPLOYMENT_NAME"
        local core_json=$(kubectl get ns ${CDF_NAMESPACE} -o json)
        local suite_json=$(kubectl get ns ${suite_ns} -o json)
        local is_user_set_core_deployname=$(    echo "$core_json"   |$JQ -r '.metadata.labels|has("deployments.microfocus.com/deployment-name")')
        local is_user_set_suite_deployname=$(   echo "$suite_json"  |$JQ -r '.metadata.labels|has("deployments.microfocus.com/deployment-name")')
        local user_set_core_deployname=$(       echo "$core_json"   |$JQ -r '.metadata.labels."deployments.microfocus.com/deployment-name"')
        local user_set_suite_deployname=$(      echo "$suite_json"  |$JQ -r '.metadata.labels."deployments.microfocus.com/deployment-name"')
        if [[ "$is_user_set_core_deployname" == "true" ]];then
            if [[ "$user_set_core_deployname" != "$DEPLOYMENT_NAME" ]];then
                write_log "fatal" "The deployment name of -d option isnt match with the value of label deployments.microfocus.com/deployment-name in ${CDF_NAMESPACE}"
            fi
        fi
        if [[ "$is_user_set_suite_deployname" == "true" ]];then
            if [[ "$user_set_suite_deployname" != "$DEPLOYMENT_NAME" ]];then
                write_log "fatal" "The deployment name of -d option isnt match with the value of label deployments.microfocus.com/deployment-name in ${suite_ns}"
            fi
        fi
        local is_user_set_core_uuid=$(  echo "$core_json"   |$JQ -r '.metadata.labels|has("deployments.microfocus.com/deployment-uuid")')
        local is_user_set_suite_uuid=$( echo "$suite_json"  |$JQ -r '.metadata.labels|has("deployments.microfocus.com/deployment-uuid")')
        local user_set_core_uuid=$(     echo "$core_json"   |$JQ -r '.metadata.labels."deployments.microfocus.com/deployment-uuid"')
        local user_set_suite_uuid=$(    echo "$suite_json"  |$JQ -r '.metadata.labels."deployments.microfocus.com/deployment-uuid"')
        if [[ "$is_user_set_core_uuid" == "true" ]];then
            if ! checkDeploymentUuidFormat "$user_set_core_uuid";then
                write_log "fatal" "The value of label deployments.microfocus.com/deployment-uuid in namespace ${CDF_NAMESPACE} is incorrect, the deployment uuid must be lower case alphanumeric characters or '-' (e.g. '963c226a-f8ba-46c3-8cfa-7654a1daf22e', regex used for validation is '[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}')"
            fi
        fi
        if [[ "$is_user_set_suite_uuid" == "true" ]];then
            if ! checkDeploymentUuidFormat "$user_set_suite_uuid";then
                write_log "fatal" "The value of label deployments.microfocus.com/deployment-uuid in namespace ${suite_ns} is incorrect., the deployment uuid must be lower case alphanumeric characters or '-' (e.g. '963c226a-f8ba-46c3-8cfa-7654a1daf22e', regex used for validation is '[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}')"
            fi
        fi
        if [[ "$is_user_set_suite_uuid" == "true" ]] && [[ "$is_user_set_core_uuid" == "true" ]] && [[ "$user_set_core_uuid" != "$user_set_suite_uuid" ]];then
            write_log "fatal" "The value of label deployments.microfocus.com/deployment-uuid in namespace ${CDF_NAMESPACE} and ${suite_ns} isn't match"
        fi
        local uuid=
        if [[ "$is_user_set_core_uuid" == "false" ]] && [[ "$is_user_set_suite_uuid" == "false" ]];then
            uuid=$(exec_cmd "cat /proc/sys/kernel/random/uuid" -p=true)
            if ! checkDeploymentUuidFormat "$uuid";then
                write_log "fatal" "Failed to get the system uuid."
            fi
        fi
        if [[ "$is_user_set_core_uuid" == "false" ]];then
            if [[ "$is_user_set_suite_uuid" == "true" ]];then
                uuid="$user_set_suite_uuid"
            fi
            write_log "warn" "User install $PRODUCT_SHORT_NAME with ns-admin setting but the namespace isn't label yet. Try to label deployment-uuid the namespace ${CDF_NAMESPACE} ..."
            labelNamespace "${CDF_NAMESPACE}" "deployments.microfocus.com/deployment-uuid" "$uuid"
        fi
        if [[ "$is_user_set_suite_uuid" == "false" ]];then
            if [[ "$is_user_set_core_uuid" == "true" ]];then
                uuid="$user_set_core_uuid"
            fi
            write_log "warn" "User install $PRODUCT_SHORT_NAME with ns-admin setting but the namespace isn't label yet. Try to label deployment-uuid the namespace ${suite_ns} ..."
            labelNamespace "${suite_ns}" "deployments.microfocus.com/deployment-uuid" "$uuid"
        fi
        if [[ "$is_user_set_core_deployname" == "false" ]];then
            write_log "warn" "User install $PRODUCT_SHORT_NAME with ns-admin setting but the namespace isn't label yet. Try to label deployment-name the namespace ${CDF_NAMESPACE} ..."
            labelNamespace "${CDF_NAMESPACE}" "deployments.microfocus.com/deployment-name" "$DEPLOYMENT_NAME"
        fi
        if [[ "$is_user_set_suite_deployname" == "false" ]];then
            write_log "warn" "User install $PRODUCT_SHORT_NAME with ns-admin setting but the namespace isn't label yet. Try to label deployment-name the namespace ${suite_ns} ..."
            labelNamespace "${suite_ns}" "deployments.microfocus.com/deployment-name" "$DEPLOYMENT_NAME"
        fi
        setStepDone $FUNCNAME
    fi
}

labelCdfNamespace(){
    if stepNotDone $FUNCNAME; then
        write_log "debug" "Label namespace: ${CDF_NAMESPACE}"
        local json="$(kubectl get ns ${CDF_NAMESPACE} -o json 2>/dev/null)"
        if [[ -z "$json" ]];then
            write_log "fatal" "Failed to run kubectl get namespace $CDF_NAMESPACE. $LOG_SUPPORT_MSG" "failed"
        fi
        local cur_uuid="$(echo "$json"|$JQ -r '.metadata.labels."deployments.microfocus.com/deployment-uuid" // empty')"
        local cur_deployname="$(echo "$json"|$JQ -r '.metadata.labels."deployments.microfocus.com/deployment-name" // empty')"

        if [[ -z "$cur_uuid" ]];then
            local uuid=$(exec_cmd "cat /proc/sys/kernel/random/uuid 2>/dev/null" -p=true)
            labelNamespace "${CDF_NAMESPACE}" "deployments.microfocus.com/deployment-uuid" "$uuid"
        fi

        if [[ -z "$cur_deployname" ]];then
            labelNamespace "${CDF_NAMESPACE}" "deployments.microfocus.com/deployment-name" "cdf"
        fi

        setStepDone $FUNCNAME
    fi
}

checkNsResources(){
    local suite_ns;suite_ns="$(echo $DEPLOYMENT_NAME|tr '[:upper:]' '[:lower:]')"
    for ns in "$CDF_NAMESPACE" "$suite_ns";do
        checkNamespaceViaSa "$ns"
        local val;val=$(kubectl get sa default -n ${ns} -o json 2>/dev/null|$JQ -r '.metadata.annotations."deployment.microfocus.com/namespace"')
        if [[ "$val" == "used" ]];then
            write_log "fatal" "The ${ns} namespace has already been used. $LOG_SUPPORT_MSG" "failed"
        fi
        checkApiResourcesByNs "$ns"
    done
}

isNodesNotSkipwarning(){
    local nodes_type=$1
    local config=$2
    if [[ "$($JQ -r ".${nodes_type}|length" ${config})" -gt 0 ]];then
        local skipwarnings;skipwarnings="$($JQ -r ".${nodes_type}[].skipWarning" ${config} 2>/dev/null|uniq)"
        [[ "$skipwarnings" != "true" ]] && return 0
    fi
    return 1
}

operationsEntry(){
    local optionalTypeNum=0
    if [[ $SILENT_RECONFIG ]];then optionalTypeNum=$((optionalTypeNum+1)); fi
    if [[ $SILENT_UPDATE ]];then optionalTypeNum=$((optionalTypeNum+1)); fi
    if (( $optionalTypeNum > 1 ));then
        write_log "fatal" "Cannot do suite deployment, delete, reconfig and update at the same time."
    else
        if [[ -n "$SILENT_CONFIG_FILE" ]] || [[ -n "$SILENT_UPDATE" ]]; then
            sourceCdfProfile
            [[ -f "${CDF_HOME}/bin/env.sh" ]] && source ${CDF_HOME}/bin/env.sh
            checkFeatureGatesSilentVols
            if [[ "$SILENT_LIFECYCLE" == "update" ]];then
                ps -ef|grep -v $$|grep -v $PPID|grep -v grep|grep -v sudo|grep -P '\Winstall\s'|grep -P '\s\-\-update\s' -sq;
                if [[ $? -eq 0 ]]; then
                    write_log "fatal" "Already have one update process running on this node. QUIT."
                    exit 9
                fi
                if [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
                    export STEPS_FILE="$CDF_INSTALL_RUNTIME_HOME/.cdfUpdateCompletedSteps.tmp"
                else
                    export STEPS_FILE="$CDF_INSTALL_RUNTIME_HOME/.cdfUpdateCompletedSteps_$(cat ${CURRENTDIR}/version.txt).tmp"
                fi
                checkInstallCompleted "update"
                [[ ! -f "$STEPS_FILE" ]] && checkJsonForUpdate
                # start create "$STEPS_FILE"
                createContinueConfig
            fi

            if [[ -z "$SUPER_USERPWD" ]]; then
                [ "$($JQ 'has("adminPassword")' $SILENT_CONFIG_FILE)" = "true" ] && SUPER_USERPWD="$($JQ -r '.adminPassword' $SILENT_CONFIG_FILE)"
            fi
            #hardcode the admin user name and remove -u|--username option, ref: US#1216804
            SILENT_SUPERUSER="admin"
            if [ -n "$DEPLOYMENT_NAME" ]; then silent_deployment_name="-d $DEPLOYMENT_NAME"; fi
            if [ -n "$SILENT_SUPERUSER" ]; then silent_user="-u $SILENT_SUPERUSER"; fi
            if [ -n "$SUPER_USERPWD" ]; then silent_pwd="-p '$(echo "$SUPER_USERPWD"|sed -e "s/'/'\\\\''/g")'"; fi
            if [ -n "$SILENT_TIMEOUT_MINUTES" ]; then silent_timeout_opt="-t $SILENT_TIMEOUT_MINUTES"; fi
            if [ -n "$METADATA" ]; then silent_metadata_opt="-m $METADATA"; fi
            if [ -n "$INTERNAL_KUBE_REGISTRY_USERNAME" ]; then silent_registry_user_opt="-U $INTERNAL_KUBE_REGISTRY_USERNAME"; fi
            if [ -n "$SUPER_USERPWD" ]; then silent_registry_pwd_opt="-P '$(echo "$SUPER_USERPWD"|sed -e "s/'/'\\\\''/g")'"; fi
            if [ -n "$CLI_SYSTEM_USER_ID" ]; then silent_uid_opt="--uid $CLI_SYSTEM_USER_ID"; fi
            if [ -n "$CLI_SYSTEM_GROUP_ID" ]; then silent_gid_opt="--gid $CLI_SYSTEM_GROUP_ID"; fi
            if [ -n "$SILENT_CONFIG_FILE" ]; then silent_config_opt="-c $SILENT_CONFIG_FILE"; fi
            eval "${CURRENTDIR}/tools/silent-install/silent_main.sh $silent_config_opt -L '$SILENT_LIFECYCLE' $silent_user $silent_pwd $silent_end_state $silent_timeout_opt $silent_ext_rep $silent_deployment_name $silent_imgfolder_opt -T '$INSTALLED_TYPE' $silent_metadata_opt $silent_registry_user_opt $silent_registry_pwd_opt $silent_uid_opt $silent_gid_opt"
        else
            write_log "fatal" "Need provide json file for silent suite reconfig/update. Type ./install -h for help."
        fi
    fi
}

checkConfigVolumesChanged(){
    local volumes_sha=$(cat $SILENT_CONFIG_FILE|$JQ  -r '.volumes[]|with_entries(.key=.key|.value=.value)' 2>/dev/null|sha256sum |awk '{print $1}')
    source $PREVIOUS_INSTALL_CONFIG
    if [[ "$_volumes_sha" != "$volumes_sha" ]];then
        return 0
    fi
    return 1
}

updateConfigVolumesSha(){
    local volumes_sha=$(cat $SILENT_CONFIG_FILE|$JQ  -r '.volumes[]|with_entries(.key=.key|.value=.value)' 2>/dev/null|sha256sum |awk '{print $1}')
    exec_cmd "sed -i -r -e '/^_volumes_sha=\w+$/ d' $PREVIOUS_INSTALL_CONFIG"
    exec_cmd "echo '_volumes_sha=$volumes_sha' >> $PREVIOUS_INSTALL_CONFIG"
}

preCheckAllVolumes(){
    if stepNotDone $FUNCNAME; then
        checkConfigJsonSchema
        if [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
            checkNodeHostnames
        fi
        if [ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ];then
            checkConfigJson
        else
            checkConfigJsonForHelm
        fi
        setStepDone $FUNCNAME
    fi
}

preCheckSilentConfig(){
    if [ -n "$SILENT_CONFIG_FILE" ]; then
        if stepNotDone "@updateFullJsonParams";then
            checkConfigVolumesChanged
            if [[ $? -eq 0 ]];then
                exec_cmd "sed -i -r -e '/^preCheckAllVolumes$/ d' $STEPS_FILE"
            fi

            preCheckAllVolumes

            updateConfigVolumesSha
        fi
    fi
}

checkConfigNFSForBYOK(){
    if [[ -n "$SILENT_CONFIG_FILE" ]] && [[ -f "$SILENT_CONFIG_FILE" ]];then
        if stepNotDone $FUNCNAME; then
            local length=$(exec_cmd "cat $SILENT_CONFIG_FILE|$JQ -r '.volumes|length'" -p=true)
            for n in $(seq 0 $((length-1))|xargs);do
                local host=$(exec_cmd "cat $SILENT_CONFIG_FILE|$JQ -r '.volumes[$n].host'" -p=true)
                local path=$(exec_cmd "cat $SILENT_CONFIG_FILE|$JQ -r '.volumes[$n].path'" -p=true)
                local name=$(exec_cmd "cat $SILENT_CONFIG_FILE|$JQ -r '.volumes[$n].name'" -p=true)
                if [[ "$name" == "itom-vol-claim" ]];then
                    continue
                fi
                checkNFSForBYOK "$host" "$path" "$name"
            done
            setStepDone $FUNCNAME
        fi
    fi
}

preCheckSilentConfigForBYOK(){
    # PV manged by CDF
    local has_pv;has_pv=$(echo $CDF_ADMIN_TASKS|awk -F, '{for(i=1;i<=NF;i++)if($i=="pv"){print "true";break}}')
    if [[ "$has_pv" == "true" ]] && [[ -n "$SILENT_CONFIG_FILE" ]]; then
        if stepNotDone "@updateFullJsonParams";then
            checkConfigVolumesChanged
            if [[ $? -eq 0 ]];then
                exec_cmd "sed -i -r -e '/^checkConfigNFSForBYOK$/ d' $STEPS_FILE"
            fi

            checkConfigNFSForBYOK

            updateConfigVolumesSha
        fi
    fi
}

configNfsProvisioner(){
    if [[ "$CAPS_NFS_PROVISIONER" == "true" ]];then
        write_log "step" "Upload the $NFS_PROVISIONER_RELEASE_NAME chart to Kubernetes ..."
        if stepNotDone $FUNCNAME; then
            local chart="${CURRENTDIR}/cdf/charts/$CHART_ITOM_NFS_PROVISIONER"
            # --set fullnameOverride=nfs-provisioner-itom-nfs-provisioner   clusterrole[-runner]
            exec_cmd "${CDF_HOME}/bin/helm upgrade --debug --install -n $CDF_NAMESPACE $NFS_PROVISIONER_RELEASE_NAME $chart \\
                $SET_HELM_CHART_TLS_OPTIONS \\
                --set global.docker.registry=$DOCKER_REPOSITORY \\
                --set global.docker.orgName=$REGISTRY_ORGNAME \\
                --set global.docker.imagePullSecret=registrypullsecret \\
                --set global.securityContext.user=$SYSTEM_USER_ID \\
                --set global.securityContext.fsGroup=$SYSTEM_GROUP_ID \\
                --set nfs.server=$NFS_PROV_SERVER \\
                --set nfs.path=$NFS_PROV_FOLDER \\
                --set storageClass.name=$NFS_PROVISIONER_STORAGECLASS \\
                --set storageClass.reclaimPolicy=Retain \\
                --set storageClass.provisionerName=$NFS_PROVISIONER_RELEASE_NAME"
            if [ $? -ne 0 ]; then
                write_log "fatal" "Failed to start up $NFS_PROVISIONER_RELEASE_NAME. $LOG_SUPPORT_MSG" "failed"
            fi
            setStepDone $FUNCNAME
            showStatus "ok"
        else
            showStatus "Already done"
        fi
        checkNfsProvisionerStatus
    fi
}

checkNfsProvisionerStatus(){
    write_log "step" "Check $NFS_PROVISIONER_RELEASE_NAME status ..."
    if stepNotDone $FUNCNAME; then
        local reTryTimes=0
        local totalTimes=3600
        while true;do
            checkComponentDeploymentStatus "$NFS_PROVISIONER_RELEASE_NAME"
            if [ $? -eq 0 ];then
                break
            fi
            if [ "$reTryTimes" -eq "$totalTimes" ]; then
                write_log "fatal" "A timeout occurred while waiting for $NFS_PROVISIONER_RELEASE_NAME to running. $LOG_SUPPORT_MSG" "failed"
            else
                write_log "debug" "Component's deployments are not running. Wait for $totalTimes seconds and recheck: $reTryTimes"
            fi
            reTryTimes=$(( $reTryTimes + 1 ))
            sleep 1
        done

        setStepDone $FUNCNAME
        showStatus "ok"
    else
        showStatus "Already done"
    fi
}

configureCdfVolume() {
    # on-premise, BYOK create pv at begin
    if [ "$INSTALLED_TYPE" = "CLASSIC" ];then
        write_log "step" "Configure and create $PRODUCT_SHORT_NAME volume ..."
        if stepNotDone $FUNCNAME; then
            local yaml="$CDF_HOME/objectdefs/itom-cdf-volume.yaml"
            if [ -f "$CDF_HOME/objectdefs/itom-vol-claim.yaml" ];then
                if [[ "$CAPS_NFS_PROVISIONER" == "true" ]];then
                    exec_cmd "$CP -f $CDF_HOME/objectdefs/itom-vol-claim.yaml $yaml"
                    exec_cmd "sed -i -e '/#{pv-admin-need-remove-it}/d' $yaml"
                else
                    if [ ! -f "$CDF_HOME/objectdefs/itom-vol.yaml" ];then
                        write_log "fatal" "Not found $CDF_HOME/objectdefs/itom-vol.yaml. $LOG_SUPPORT_MSG" "failed"
                    fi
                    local pv="$(cat $CDF_HOME/objectdefs/itom-vol.yaml)"
                    local pvc="$(cat $CDF_HOME/objectdefs/itom-vol-claim.yaml)"
                    exec_cmd "printf '%s\n%s\n%s\n\n' '$pv' '$pvc' > $yaml"
                fi
            else
                write_log "fatal" "Failed to create yaml file $yaml. $LOG_SUPPORT_MSG" "failed"
            fi
            replaceCdfDeployer $yaml
            local label_val="$(getRandomVal)"
            exec_cmd "sed -i -e 's@{PV_PVC_LABEL_VALUE}@$label_val@g' $yaml"

            deployYamlFile $yaml
            waitPvcBound "itom-vol-claim"
            setStepDone $FUNCNAME
            showStatus "ok"
        else
            showStatus "Already done"
        fi
    fi
}

waitPvcBound(){
    local pvc_name=$1
    local json=

    json=$(exec_cmd "kubectl get pvc $pvc_name -n $CDF_NAMESPACE -o json 2>/dev/null" -p=true)
    if [[ $? -ne 0 ]];then
        write_log "fatal" "Failed to get pvc: $CDF_NAMESPACE/$pvc_name. $LOG_SUPPORT_MSG" "failed"
    fi
    local sc="$(echo $json|$JQ -r '.spec.storageClassName')"

    json=$(exec_cmd "kubectl get sc -o json" -p=true)
    if [[ $? -ne 0 ]];then
        if echo $json|grep -q 'Error from server (Forbidden)';then
            write_log "debug" "Current user cannot to get storageClass."
            return
        else
            write_log "fatal" "Failed to get storageClass. $LOG_SUPPORT_MSG" "failed"
        fi
    fi

    json=$(exec_cmd "kubectl get sc -o json 2>/dev/null" -p=true)
    local volumeBindingMode="$(echo $json|$JQ -r ".items[]|select(.metadata.name==\"$sc\").volumeBindingMode")"
    if [[ "$volumeBindingMode" == "WaitForFirstConsumer" ]];then
        write_log "debug" "PVC: $pvc_name, volumeBindingMode: $volumeBindingMode, no need to wait for PVC status to be Bound."
        return
    fi

    local reTryTimes=0
    while true;do
        local phase=$(exec_cmd "kubectl get pvc -n $CDF_NAMESPACE $pvc_name -o json 2>/dev/null|$JQ -r '.status.phase'" -p=true)
        if [[ "$phase" == "Bound" ]];then
            break
        fi
        if [ $reTryTimes -ge 20 ]; then
            write_log "fatal" "Failed to bound pv: $pvc_name. $LOG_SUPPORT_MSG" "failed"
        else
            write_log "debug" "Wait pvc($pvc_name) bound pv. Wait for $SLEEP_TIME seconds and retry: $reTryTimes "
        fi
        reTryTimes=$(( $reTryTimes + 1 ))
        sleep $SLEEP_TIME
    done
}

checkVolumeSize(){
    local key="$1"
    local val="$2"
    local file="$3"
    local tips=""
    if [[ -f "$file" ]];then
        tips="in '$file'"
    fi
    local size=$(echo $val | sed -r 's/^([0-9.]+)(.*)/\1/g')
    local unit=$(echo $val | sed -r 's/^([0-9.]+)(.*)/\2/g')
    if [ $(echo $size| grep '[^0-9.]' |wc -l) -ne 0 -o "$size" = "." ];then write_log "fatal" "Invalid value for $key $tips: '$val', the value must be a plain integer or as a fixed-point integer with unit (allowed unit: E,P,T,G,M,K,Ei,Pi,Ti,Gi,Mi,Ki)";fi
    if ([ ${#unit} -eq 1 ]&&[[ ! "$unit" =~  E|P|T|G|M|K ]]) || ([ ${#unit} -eq 2 ]&&[[ ! "$unit" =~  Ei|Pi|Ti|Gi|Mi|Ki ]]) || [ ${#unit} -gt 2 ] ; then write_log "fatal" "Invalid unit for $key $tips: '$unit', allowed unit: E,P,T,G,M,K,Ei,Pi,Ti,Gi,Mi,Ki"; fi
}

getVolumeSize(){
    local volumeKey="$1"
    $CURRENTDIR/bin/yq eval ".global.persistence.$volumeKey // \"\"" "$APPHUB_HELM_VALUES" 2>/dev/null
}

getVolumeSizes(){
    if [[ -n "$APPHUB_HELM_VALUES" ]];then
        export CUS_LOG_VOLUME_SIZE="$(getVolumeSize "logVolumeSize")"
        export CUS_DATA_VOLUME_SIZE="$(getVolumeSize "dataVolumeSize")"
        export CUS_DB_VOLUME_SIZE="$(getVolumeSize "dbVolumeSize")"
        export CUS_PROMETHEUS_VOLUME_SIZE="$(getVolumeSize "prometheusVolumeSize")"
        if [ -n "$CUS_LOG_VOLUME_SIZE" ];then
            LOGGING_VOL_SIZE="$CUS_LOG_VOLUME_SIZE"
        fi
    fi
}

checkVolumeSizes(){
    getVolumeSizes
    if [ -n "$CUS_LOG_VOLUME_SIZE" ];then
        checkVolumeSize ".global.persistence.logVolumeSize" "$CUS_LOG_VOLUME_SIZE"
    fi
    if [ -n "$CUS_DATA_VOLUME_SIZE" ];then
        checkVolumeSize ".global.persistence.dataVolumeSize" "$CUS_DATA_VOLUME_SIZE"
    fi
    if [ -n "$CUS_DB_VOLUME_SIZE" ];then
        checkVolumeSize ".global.persistence.dbVolumeSize" "$CUS_DB_VOLUME_SIZE"
    fi
    if [ -n "$CUS_PROMETHEUS_VOLUME_SIZE" ];then
        checkVolumeSize ".global.persistence.prometheusVolumeSize" "$CUS_PROMETHEUS_VOLUME_SIZE"
    fi
}

checkPvcAccessModes(){
    getPvcAccessModes
    if [[ -n "$PERSISTENCE_ACCESS_MODE" ]];then
        if [[ "$PERSISTENCE_ACCESS_MODE" =~ ^(ReadWriteOnce|ReadOnlyMany|ReadWriteMany|ReadWriteOncePod)$ ]];then
            write_log "debug" "User set .global.persistence.accessMode=$PERSISTENCE_ACCESS_MODE"
        else
            write_log "fatal" "Invalid value for '.global.persistence.accessMode' in $APPHUB_HELM_VALUES: $PERSISTENCE_ACCESS_MODE, allowed values: ReadWriteOnce,ReadOnlyMany,ReadWriteMany,ReadWriteOncePod"
        fi
    fi
}

getPvcAccessModes(){
    if [[ -z "$PERSISTENCE_ACCESS_MODE" ]];then
        local accessMode=
        if [[ -n "$APPHUB_HELM_VALUES" ]];then
            local hasAccessMode=$($CURRENTDIR/bin/yq eval '.global.persistence|has("accessMode")' "$APPHUB_HELM_VALUES")
            if [[ "$hasAccessMode" == "true" ]];then
                accessMode=$($CURRENTDIR/bin/yq eval '.global.persistence.accessMode' "$APPHUB_HELM_VALUES")
            fi
        fi
        export PERSISTENCE_ACCESS_MODE=${accessMode:-"ReadWriteMany"}
    fi
}

configurePv() {
    local vol_name=$1
    local vol_host=$2
    local vol_path=$3
    local vol_size="${4:-"5Gi"}"

    write_log "step" "Configure and create $vol_name pv ..."
    local cur_step_flag="pvc_$(echo $vol_name|sed -r 's/[^a-zA-Z0-9]/_/g')"
    if stepNotDone $cur_step_flag; then
        local yaml="$CDF_HOME/objectdefs/pv-$vol_name.yaml"
        local has_pv;has_pv=$(echo $CDF_ADMIN_TASKS|awk -F, '{for(i=1;i<=NF;i++)if($i=="pv"){print "true";break}}')
        if [ "$has_pv" == "true" ];then
            local label_val="$(getRandomVal)"
            local pv_name=$(echo "$vol_name"|sed -r 's/-vol$//')
            exec_cmd "kubectl delete pv $pv_name --grace-period=0 --force"
            echo "
kind: PersistentVolume
apiVersion: v1
metadata:
  name: $pv_name
  labels:
    pv_pvc_label: \"$label_val\"
spec:
  capacity:
    storage: \"${vol_size}\"
  accessModes:
    - $PERSISTENCE_ACCESS_MODE
  persistentVolumeReclaimPolicy: Retain
  storageClassName: \"${DEFAULT_STORAGE_CLASS}\"
  nfs:
    path: ${vol_path}
    server: \"${vol_host}\"

            "> $yaml
        fi

        if [ "$INSTALLED_TYPE" = "CLASSIC" ];then
            deployYamlFile $yaml
        else
            deployYamlFileForBYOK $yaml
        fi
        setStepDone $cur_step_flag
        showStatus "ok"
    else
        showStatus "Already done"
    fi
}

configureVolume() {
    local vol_name=$1
    local vol_host=$2
    local vol_path=$3
    local vol_size=

    case "$vol_name" in
        itom-logging-vol )
            vol_size="$CUS_LOG_VOLUME_SIZE"
            ;;
        itom-vol-claim )
            vol_size="$CUS_DATA_VOLUME_SIZE"
            ;;
        db-single-vol )
            vol_size="$CUS_DB_VOLUME_SIZE"
            ;;
        itom-monitor-vol )
            vol_size="$CUS_PROMETHEUS_VOLUME_SIZE"
            ;;
    esac
    vol_size="${vol_size:-"5Gi"}"

    write_log "step" "Configure and create $vol_name volume ..."
    local cur_step_flag="pvc_$(echo $vol_name|sed -r 's/[^a-zA-Z0-9]/_/g')"
    if stepNotDone $cur_step_flag; then
        exec_cmd "kubectl delete pvc $vol_name -n $CDF_NAMESPACE --grace-period=0 --force"
        local yaml="$CDF_HOME/objectdefs/pvc-$vol_name.yaml"
        echo "" > $yaml
        local label_name=""
        local has_pv;has_pv=$(echo $CDF_ADMIN_TASKS|awk -F, '{for(i=1;i<=NF;i++)if($i=="pv"){print "true";break}}')
        if [ "$has_pv" == "true" ];then
            local pv_name=$(echo "$vol_name"|sed -r 's/-vol$//')
            label_name="$(getRandomVal)"
            exec_cmd "kubectl delete pv $pv_name --grace-period=0 --force"
            echo "
kind: PersistentVolume
apiVersion: v1
metadata:
  name: $pv_name
  labels:
    pv_pvc_label: \"$label_name\"
spec:
  capacity:
    storage: \"${vol_size}\"
  accessModes:
    - $PERSISTENCE_ACCESS_MODE
  persistentVolumeReclaimPolicy: Retain
  storageClassName: \"${DEFAULT_STORAGE_CLASS}\"
  nfs:
    path: ${vol_path}
    server: \"${vol_host}\"

            ">> $yaml
        fi

        echo "
---
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: $vol_name
  namespace: ${CDF_NAMESPACE}
  labels:                                      #{pv-admin-need-remove-it}
    pv_pvc_label: \"$label_name\"              #{pv-admin-need-remove-it}
spec:
  accessModes:
    - $PERSISTENCE_ACCESS_MODE
  storageClassName: \"${DEFAULT_STORAGE_CLASS}\"
  resources:
    requests:
      storage: \"${vol_size}\"
  selector:                                    #{pv-admin-need-remove-it}
    matchLabels:                               #{pv-admin-need-remove-it}
      pv_pvc_label: \"$label_name\"            #{pv-admin-need-remove-it}

        ">> $yaml
        if [ "$has_pv" != "true" ];then
            exec_cmd "sed -i -e '/#{pv-admin-need-remove-it}/d' $yaml"
        fi
        if [ "$INSTALLED_TYPE" = "CLASSIC" ];then
            deployYamlFile $yaml
        else
            deployYamlFileForBYOK $yaml
        fi
        waitPvcBound "$vol_name"
        setStepDone $cur_step_flag
        showStatus "ok"
    else
        showStatus "Already done"
    fi
}

configureVolumesFromConfig(){
    if [[ -z "$SILENT_CONFIG_FILE" ]];then
        return
    fi
    # CAPS_DEPLOYMENT_MANAGEMENT=false
    write_log "info" "Creating all required volumes ..."
    local monitor_pv_name=
    local monitor_pv_host=
    local monitor_pv_path=
    local num=$(cat $SILENT_CONFIG_FILE|$JQ -r '.volumes|length')
    for (( n=0; n<num; n++ ));do
        local name=$(cat $SILENT_CONFIG_FILE|$JQ -r ".volumes[$n].name")
        if [[ "$name" == "itom-vol-claim" ]];then
            continue
        fi
        local host=$(cat $SILENT_CONFIG_FILE|$JQ -r ".volumes[$n].host")
        local path=$(cat $SILENT_CONFIG_FILE|$JQ -r ".volumes[$n].path")
        if [[ "$name" == "itom-monitor-vol" ]];then
            monitor_pv_name="$name"
            monitor_pv_host="$host"
            monitor_pv_path="$path"
            continue
        fi
        configureVolume "$name" "$host" "$path"
    done

    local has_pv
    has_pv=$(echo $CDF_ADMIN_TASKS|awk -F, '{for(i=1;i<=NF;i++)if($i=="pv"){print "true";break}}')
    if [[ "$has_pv" == "true" ]] && [[ -n "$monitor_pv_name" ]];then
        configurePv "$monitor_pv_name" "$monitor_pv_host" "$monitor_pv_path" "$CUS_PROMETHEUS_VOLUME_SIZE"
    fi
}

configureVolumesFromInternal(){
    if [[ -z "$SILENT_CONFIG_FILE" ]];then
        return
    fi
    local type=$($JQ -r ".database.type" $SILENT_CONFIG_FILE)
    if [[ $type == "intpostgres" ]];then
        configureVolume "db-single-vol"
    fi
    if [[ "$CAPS_CLUSTER_MANAGEMENT $CAPS_DEPLOYMENT_MANAGEMENT $CAPS_LOG_COLLECTION $CAPS_MONITORING" =~ true ]];then
        configureVolume "itom-logging-vol"
    fi
}

configureVolumes(){
    if [[ "$(isEnabledByTaskName pv)" == "true" ]];then
        # PV-CDF
        configureVolumesFromConfig
    else
        # PV-ADMIN
        configureVolumesFromInternal
    fi
}

addLabelOnNodes(){
    write_log "step" "Start add labels on node(s) ..."
    if stepNotDone $FUNCNAME; then
        local nodes="$(exec_cmd "kubectl get nodes --no-headers 2>/dev/null|awk '{print \$1}'|xargs" -p=true)"
        local role_master_nodes="$(exec_cmd "kubectl get nodes -l node-role.kubernetes.io/master --no-headers 2>/dev/null|awk '{print \$1}'|xargs" -p=true)"
        local role_control_nodes="$(exec_cmd "kubectl get nodes -l $MASTER_NODELABEL_KEY --no-headers 2>/dev/null|awk '{print \$1}'|xargs" -p=true)"
        local role_controlplane_nodes="$(exec_cmd "kubectl get nodes -l node-role.kubernetes.io/controlplane --no-headers 2>/dev/null|awk '{print \$1}'|xargs" -p=true)"
        local master_nodes="$role_master_nodes $role_control_nodes $role_controlplane_nodes"
        local isExistMaster
        for node in ${nodes} ; do
            isExistMaster="$(echo "$master_nodes"|xargs -n1|sort|uniq|awk -v n="${node}" '$1==n')"
            if [[ -n "$isExistMaster" ]];then
                continue
            fi
            for label in "role=loadbalancer" "Worker=label"; do
                local reTryTimes=0
                while true; do
                    if [[ $(exec_cmd "kubectl get nodes -l $label --no-headers 2>/dev/null|grep -c $node" -p=true) -eq 0 ]]; then
                        write_log "debug" "Labeling $label on node $node..."
                        exec_cmd "kubectl label node ${node} $label"
                        if [[ $? -eq 0 ]]; then
                            break
                        elif [[ $reTryTimes -eq $RETRY_TIMES ]]; then
                            write_log "fatal" "Failed to label $label on node $node."
                        else
                            reTryTimes=$(( $reTryTimes + 1 ))
                            write_log "debug" "Failed to label $label on node $node. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                            sleep $SLEEP_TIME
                        fi
                    else
                        write_log "debug" "Node $node already labelled $label."
                        break
                    fi
                done
            done
        done
        setStepDone $FUNCNAME
        showStatus "ok"
    else
      showStatus "Already done"
    fi
}

applyCdfPriorityClass(){
    write_log "step" "Create cdf-priority-classes ..."
    if stepNotDone $FUNCNAME; then
        local reTryTimes=0
        local file="$CURRENTDIR/cdf/objectdefs/cdf-priority-classes.yaml"
        while true; do
            exec_cmd "kubectl apply -f $file"
            if [[ $? -eq 0 ]]; then
                exec_cmd "$CP -f $file $CDF_HOME/objectdefs/"
                break
            elif [[ $reTryTimes -eq $RETRY_TIMES ]]; then
                write_log "fatal" "Failed to create $file."
            else
                reTryTimes=$(( $reTryTimes + 1 ))
                write_log "debug" "Failed to create $file. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                sleep $SLEEP_TIME
            fi
        done
        setStepDone $FUNCNAME
        showStatus "ok"
    else
      showStatus "Already done"
    fi
}

createAddNodeConfigMap(){
    local cm="addnode-configmap"
    write_log "step" "Create the $cm configmap  ..."
    if stepNotDone $FUNCNAME; then
        local reTryTimes=0
        local file="$CURRENTDIR/k8s/cfg/cdf-addnode.json"
        while true; do
            if ! exec_cmd "kubectl get configmap $cm -n ${CDF_NAMESPACE}"; then
                exec_cmd "kubectl create --save-config configmap $cm -n ${CDF_NAMESPACE} --from-file=INSTALL_CONFIG=$file"
                if [[ $? -eq 0 ]]; then
                    break
                elif [[ $reTryTimes -eq $RETRY_TIMES ]]; then
                    write_log "fatal" "Failed to create configmap $cm."
                else
                    reTryTimes=$(( $reTryTimes + 1 ))
                    write_log "debug" "Failed to create configmap $cm. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                    sleep $SLEEP_TIME
                fi
            else
                write_log "debug" "Configmap $cm already exists."
                break
            fi
        done
        setStepDone $FUNCNAME
        showStatus "ok"
    else
      showStatus "Already done"
    fi
}

createYamlTemplatesConfigMap(){
    local cm="yaml-templates"
    local reTryTimes=0
    write_log "step" "Create the $cm configmap ..."
    if stepNotDone $FUNCNAME; then
        local yaml="$CURRENTDIR/cdf/objectdefs/itom-cdf-deployer.yaml"
        local phase2_yaml="$CURRENTDIR/cdf/objectdefs/itom-cdf-deployer-phase2.yaml"
        while true; do
            exec_cmd "kubectl create --save-config cm $cm -n ${CDF_NAMESPACE} \\
            --from-file=itom-cdf-deployer.yaml=$yaml \\
            --from-file=itom-cdf-deployer-phase2.yaml=$phase2_yaml"
            if [ $? -eq 0 ] || [[ $(exec_cmd "kubectl get cm $cm -n ${CDF_NAMESPACE}"; echo $?) -eq 0 ]] ; then
                write_log "debug" "Create $cm configmap successfully."
                break
            elif [[ $reTryTimes -ge $RETRY_TIMES ]]; then
                write_log "fatal" "Failed to create $cm configmap. "
            fi
            reTryTimes=$(( $reTryTimes + 1 ))
            sleep $SLEEP_TIME
        done
        if ! exec_cmd "kubectl label configmap ${cm} -n ${CDF_NAMESPACE} deployments.microfocus.com/cleanup=uninstall";then
            write_log "fatal" "Failed to label ${cm} configmap. $LOG_SUPPORT_MSG" "failed"
        fi
        setStepDone $FUNCNAME
        showStatus "ok"
    else
      showStatus "Already done"
    fi
}

getBoolByCompare(){
    local compare=$1
    local vals=$2
    if [[ -n "$vals" ]];then
        echo "$vals"|awk -F, -v a="$compare" '{b="false";for(i=1;i<=NF;i++)if($i==a)b="true";print b}'
    else
        echo "false"
    fi
}

isEnabledByFeatureName(){
    if checkFeatureEnabled "$1";then
        echo "true"
    else
        echo "false"
    fi
}

isEnabledByTaskName(){
    getBoolByCompare "$1" "$CDF_ADMIN_TASKS"
}

updateValues() {
    local inputFile=$1
    local tmpFile="$TMP_FOLDER/cdf-apphub-values-patch-tmp.yaml"
    local outputFile=$2
    local key="$3"
    local value="$4"
    if [[ -z "$value" ]];then
        return
    fi
    local fileName=$(basename ${inputFile})
    if [[ "${value}" == "true" ]] || [[ "${value}" == "false" ]] || [[ "${value}" == "null" ]] ; then
        $CURRENTDIR/bin/yq eval ''${key}'|='${value}'' ${inputFile} 2>/dev/null > ${tmpFile}
    else
        $CURRENTDIR/bin/yq eval ''${key}'|="'${value}'"' ${inputFile} 2>/dev/null > ${tmpFile}
    fi
    ###check if command return failed or old values count less than the count before update.
    #if old values count less than the count before update, maybe command have some error or the yq command temp file create failed, in this case, we will retry.
    if [[ $? -ne 0 ]] || [[ $($CURRENTDIR/bin/yq eval ${tmpFile}|wc -l) -lt $($CURRENTDIR/bin/yq eval ${inputFile}|wc -l) ]]; then
        exec_cmd "$RM -f ${tmpFile}"
        write_log "fatal" "Failed to update value of key: ${key}."
    else
        exec_cmd "chmod 600 ${tmpFile}"
        exec_cmd "$MV -f ${tmpFile} ${outputFile}"
    fi
}

replaceEscapeValue(){
    local placeholder=$1
    local escapeValue=$2
    local file=$3

    if [[ -z "$escapeValue" ]];then
        sed -i -e "s@$placeholder@@g" "$file"
        return
    fi

    local tmp_value=
    tmp_value=$(echo "$escapeValue"|sed \
        -e 's/"/{CDF_FLAG_DOUBLEQUOTATION}/g' \
        -e 's/&/{CDF_FLAG_REFERENCE}/g' \
        -e 's/\\/{CDF_FLAG_BACKSLASH}/g' \
        -e 's/\^/{CDF_FLAG_HEAD}/g' \
        -e 's/\$/{CDF_FLAG_DOLLAR}/g' \
        -e 's/`/{CDF_FLAG_EXEC}/g' \
        -e 's/!/{CDF_FLAG_EXCLAMATION}/g' \
        -e 's/\[/{CDF_FLAG_BRACKET}/g' \
        -e 's/\//{CDF_FLAG_SLASH}/g')
    sed -i -e "s/$placeholder/\"$tmp_value\"/g" "$file"
    sed -i -e 's/{CDF_FLAG_DOUBLEQUOTATION}/\\\"/g' "$file"
    sed -i -e 's/{CDF_FLAG_BACKSLASH}/\\\\/g' "$file"
    sed -i -e 's/{CDF_FLAG_REFERENCE}/\&/g' "$file"
    sed -i -e 's/{CDF_FLAG_HEAD}/^/g' "$file"
    sed -i -e 's/{CDF_FLAG_DOLLAR}/$/g' "$file"
    sed -i -e 's/{CDF_FLAG_EXEC}/`/g' "$file"
    sed -i -e 's/{CDF_FLAG_EXCLAMATION}/!/g' "$file"
    sed -i -e 's/{CDF_FLAG_BRACKET}/[/g' "$file"
    sed -i -e 's/{CDF_FLAG_SLASH}/\//g' "$file"
}

tplRemoveBeginToEnd(){
    local file=$1
    local name=$2
    exec_cmd "sed -i -r -e '/# {0,}-{1,}BEGIN $name-{1,}/,/# {0,}-{1,}END $name-{1,}/d' '$file'"
}

updateValuesYaml(){
    local file="$CDF_HOME/objectdefs/cdf-chart.values.yaml"
    exec_cmd "$CP -f $CURRENTDIR/cdf/objectdefs/cdf-chart.values.yaml $file"

    if [[ "$USER_SET_TLS_MIN_VERSION" == "false" ]] && [[ "$USER_SET_TLS_CIPHERS" == "false" ]];then
        tplRemoveBeginToEnd "$file" "TLS"
    else
        if [[ "$USER_SET_TLS_MIN_VERSION" == "true" ]];then
            sed -i -e "s@{tlsMinVersion}@$TLS_MIN_VERSION@g" "$file"
        else
            sed -i -e '/{tlsMinVersion}/d' "$file"
        fi
        if [[ "$USER_SET_TLS_CIPHERS" == "true" ]];then
            sed -i -e "s@{tlsCiphers}@$TLS_CIPHERS@g" "$file"
        else
            sed -i -e '/{tlsCiphers}/d' "$file"
        fi
    fi

    sed -i -e "s@{deploymentManagement}@$CAPS_DEPLOYMENT_MANAGEMENT@g" "$file"
    sed -i -e "s@{suiteDeploymentManagement}@$CAPS_SUITE_DEPLOYMENT_MANAGEMENT@g" "$file"
    sed -i -e "s@{clusterManagement}@$CAPS_CLUSTER_MANAGEMENT@g" "$file"
    sed -i -e "s@{logCollection}@$CAPS_LOG_COLLECTION@g" "$file"
    sed -i -e "s@{monitoring}@$CAPS_MONITORING@g" "$file"
    sed -i -e "s@{monitoringContent}@$CAPS_MONITORING_CONTENT@g" "$file"

    if [[ "$CDF_ADMIN_TASKS" =~ (^|,)cr(,|$) ]];then
        sed -i -e "s@{clusterRoleCreate}@true@g" "$file"
    else
        sed -i -e "s@{clusterRoleCreate}@false@g" "$file"
    fi

    replaceEscapeValue "{userPassword}" "$SUPER_USERPWD" "$file"

    if [[ "$IPV6" == "false" ]];then
        tplRemoveBeginToEnd "$file" "ipv6"
    fi

    sed -i -e "s@{cluster.name}@$CLUSTER_NAME@g" "$file"
    sed -i -e "s@{docker.registry}@$DOCKER_REPOSITORY@g" "$file"
    sed -i -e "s@{docker.orgName}@$REGISTRY_ORGNAME@g" "$file"
    if [[ -n "$REGISTRY_CA" ]];then
        sed -i -e "s@{docker.tlsCert}@$(cat $REGISTRY_CA|base64 -w0)@g" "$file"
    else
        sed -i -e '/{docker.tlsCert}/d' "$file"
    fi
    sed -i -e "s@{imagePullSecret}@registrypullsecret@g" "$file"
    sed -i -e "s@{securityContext.user}@$SYSTEM_USER_ID@g" "$file"
    sed -i -e "s@{securityContext.fsGroup}@$SYSTEM_GROUP_ID@g" "$file"
    sed -i -e "s@{setFqdnInIngress}@$SET_FQDN_IN_INGRESS@g" "$file"
    sed -i -e "s@{storageClasses.default}@$DEFAULT_STORAGE_CLASS@g" "$file"

    # handle $STORAGE_CLASS_MAPPINGS begin
    if [[ -n "$STORAGE_CLASS_MAPPINGS" ]];then
        local kvs="$(echo "$STORAGE_CLASS_MAPPINGS"|sed 's/,/ /g'|xargs -n1|awk -F= '$1 != "default" && $1 != "" {print $1 ":" $2}'|xargs)"
        for kv in $kvs;do
            # copy this line: {storageClasses.keys.values}
            sed -i -r -e 's@^[ ]{1,}\{storageClasses\.keys\.values\}@&\n&_update@' "$file"
            # replace first line: remove flag 'g'
            sed -i -e "s@{storageClasses.keys.values}_update@$(echo "$kv"|sed 's/:/: /')@" "$file"
        done
    fi
    sed -i '/{storageClasses.keys.values}/ d' "$file"
    # handle $STORAGE_CLASS_MAPPINGS end

    # handle $LOADBALANCER_INFO begin
    if [[ -n "$LOADBALANCER_INFO" ]];then
        local kvs="$(echo "$LOADBALANCER_INFO"|sed 's/;/ /g'|xargs -n1|sed 's/=/:/')"
        for kv in $kvs;do
            local k="$(echo "$kv"|awk -F: '{print $1}')"
            if [[ "$k" == "LOADBALANCER" ]];then
                # Ignore LOADBALANCER, LOADBALANCER does not need to be added to annotations.
                continue
            fi
            if [[ "$k" == "LOADBALANCERSOURCERANGES" ]];then
                sed -i -e "s#{loadBalancer.sourceRanges}#$(echo "$LOADBALANCERSOURCERANGES"|sed -r -e 's/^|$/"/g' -e 's/,/", "/g')#g" "$file"
            elif [[ "$k" == "LOADBALANCERID" ]];then
                sed -i -e "s#{loadbalancerId}#$LOADBALANCER_ID#g" "$file"
            elif [[ "$k" == "LOADBALANCERIP" ]];then
                sed -i -e "s#{loadBalancerIP}#$LOADBALANCER_IP#g" "$file"
            elif [[ "$k" == "aws-load-balancer-type" ]];then
                sed -i -e "s#{awsLoadbalancerType}#$AWS_LOADBALANCER_TYPE#g" "$file"
            elif [[ "$k" == "aws-load-balancer-internal" ]];then
                sed -i -e "s#{awsLoadbalancerInternal}#$AWS_LOADBALANCER_INTERNAL#g" "$file"
            elif [[ "$k" == "azure-load-balancer-internal" ]];then
                sed -i -e "s#{azureLoadbalancerInternal}#$AZURE_LOADBALANCER_INTERNAL#g" "$file"
            else
                # copy this line: {loadBalancer.annotations.keys.values}
                sed -i -r -e 's@^[ ]{1,}\{loadBalancer\.annotations\.keys\.values\}@&\n&_update@' "$file"
                # replace first line: remove flag 'g'
                sed -i -e "s@{loadBalancer.annotations.keys.values}_update@$(echo "$kv"|sed -e 's/:/: "/' -e 's/$/"/')@" "$file"
            fi
        done
    fi
    sed -i '/{loadBalancer.annotations.keys.values}/ d' "$file"

    sed -i -e '/{loadBalancerIP}/d' "$file"
    sed -i -e '/{loadbalancerId}/d' "$file"
    sed -i -e '/{awsLoadbalancerType}/d' "$file"
    sed -i -e '/{awsLoadbalancerInternal}/d' "$file"
    sed -i -e '/{azureLoadbalancerInternal}/d' "$file"
    sed -i -e '/{loadBalancer.sourceRanges}/d' "$file"
    # handle $LOADBALANCER_INFO end

    sed -i -e "s@{fipsMode}@$ENABLE_FIPS@g" "$file"
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ]] && [[ "$(isEnabledByFeatureName AppHubUI)" == "true" ]];then
        sed -i -e "s@{appHubUI}@true@g" "$file"
    else
        sed -i -e "s@{appHubUI}@false@g" "$file"
    fi
    sed -i -e "s#{httpsProxy}#$APP_HTTPS_PROXY#g" "$file"
    sed -i -e "s#{httpProxy}#$APP_HTTP_PROXY#g" "$file"
    sed -i -e "s#{noProxy}#$APP_NO_PROXY#g" "$file"
    if [[ -z "$APP_HTTPS_PROXY" ]] && [[ -z "$APP_HTTP_PROXY" ]] && [[ -z "$APP_NO_PROXY" ]];then
        tplRemoveBeginToEnd "$file" "proxy"
    fi
    sed -i -e "s@{nfsProvisioner}@$CAPS_NFS_PROVISIONER@g" "$file"
    sed -i -e "s@{timezone}@$TZ@g" "$file"
    sed -i -e "s@{k8sProvider}@$K8S_PROVIDER@g" "$file"
    sed -i -e "s@{manageClusterRoles}@$(isEnabledByTaskName cr)@g" "$file"
    sed -i -e "s@{manageNodes}@$(isEnabledByTaskName no)@g" "$file"
    sed -i -e "s@{manageNamespaces}@$(isEnabledByTaskName ns)@g" "$file"
    sed -i -e "s@{managePersistVolumes}@$(isEnabledByTaskName pv)@g" "$file"
    sed -i -e "s@{managePriorityClasses}@$(isEnabledByTaskName pc)@g" "$file"
    sed -i -e "s@{loadBalancerIP}@$LOADBALANCER_IP@g" "$file"

    if [[ -n "$AWS_EIP" ]];then
        sed -i -e "s#{awsEip}#$AWS_EIP#g" "$file"
    else
        sed -i -e '/{awsEip}/d' "$file"
    fi
    if [[ -n "$AWS_REGION" ]];then
        sed -i -e "s#{awsRegion}#$AWS_REGION#g" "$file"
    else
        sed -i -e '/{awsRegion}/d' "$file"
    fi

    if [[ "$K8S_PROVIDER" == "aws" ]] && [ -n "$CLUSTER_WIDE_INGRESS" -o -n "$AWS_CERTIFICATE_ARN" ];then
        if [[ -n "$CLUSTER_WIDE_INGRESS" ]];then
            sed -i -e "s#{clusterWideIngress}#$CLUSTER_WIDE_INGRESS#g" "$file"
        else
            sed -i -e '/{clusterWideIngress}/d' "$file"
        fi
        if [[ -n "$AWS_CERTIFICATE_ARN" ]];then
            sed -i -e "s#{awsCertificateArn}#$AWS_CERTIFICATE_ARN#g" "$file"
        else
            sed -i -e '/{awsCertificateArn}/d' "$file"
        fi
    else
        tplRemoveBeginToEnd "$file" "AWS_LB_ingress"
    fi

    local externalAccessHost=
    local externalType=
    local vaultDeploymentType=
    local portalIngressExternalType=NodePort
    local nodePortAutoAssign=
    local vaultBackend="file"
    if [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
        vaultDeploymentType=CHART_PRIMARY
        externalAccessHost="$(hostname -f | tr '[:upper:]' '[:lower:]')"
        # handle nodeSelector
        nodeSelector="$NODESELECT"
        sed -i -e "s@{nodeSelector.keys.values}@$nodeSelector@g" "$file"
    else
        vaultDeploymentType=CHART
        externalAccessHost="$EXTERNAL_ACCESS_HOST"

        if [[ "$K8S_PROVIDER" == "gcp" ]] || [[ "$K8S_PROVIDER" == "aws" ]] || [[ "$K8S_PROVIDER" == "azure" ]] || [[ "$K8S_PROVIDER" == "openshift" ]]; then
            if [[ -n "$LOADBALANCER_INFO" ]] && ([[ "$K8S_PROVIDER" == "gcp" ]] || [[ "$K8S_PROVIDER" == "aws" ]] || [[ "$K8S_PROVIDER" == "azure" ]]);then
                externalType=LoadBalancer
                portalIngressExternalType=LoadBalancer
            else
                externalType=NodePort
                portalIngressExternalType=NodePort
                nodePortAutoAssign=true
            fi
        fi

        if [[ "$K8S_PROVIDER" == "generic" ]]; then
                externalType=NodePort
                portalIngressExternalType=NodePort
            if [[ "$LOADBALANCER_INFO" =~ (^|;)LOADBALANCER=true(;|$) ]]; then
                nodePortAutoAssign=true
            fi
        fi

        # handle nodeSelector
        if [ -n "$NODE_SELECTOR" ]; then
            local kvs="$(echo "$NODE_SELECTOR"|sed 's/,/ /g'|xargs -n1|awk -F= '$1 != "" {print $1 ":" $2}'|xargs)"
            for kv in $kvs;do
                # copy this line: {nodeSelector.keys.values}
                sed -i -r -e 's@^[ ]{1,}\{nodeSelector\.keys\.values\}@&\n&_update@' "$file"
                # replace first line: remove flag 'g'
                sed -i -e "s@{nodeSelector.keys.values}_update@$(echo "$kv"|sed -e 's/:/: "/' -e 's/$/"/')@" "$file"
            done
            sed -i -e "/{nodeSelector.keys.values}/ d" "$file"
        else #delete nodeSelector for byok when not set
            tplRemoveBeginToEnd "$file" "nodeSelector"
        fi

        # remove etcdClientCert on BYOK
        tplRemoveBeginToEnd "$file" "etcdClientCert"
        # BYOK not need tolerations
        tplRemoveBeginToEnd "$file" "tolerations"
    fi
    sed -i -e "s@{portalIngress.external.type}@$portalIngressExternalType@g" "$file"
    sed -i -e "s@{externalAccessHost}@$externalAccessHost@g" "$file"
    sed -i -e "s@{externalAccessPort}@$EXTERNAL_ACCESS_PORT@g" "$file"
    sed -i -e "s@{vault.deploymentType}@$vaultDeploymentType@g" "$file"
    sed -i -e "s@{vault.vaultBackend}@$vaultBackend@g" "$file"
    sed -i -e "s@{frontendIngress.external.type}@$externalType@g" "$file"
    if [[ "$nodePortAutoAssign" == "true" ]];then
        sed -i -e "s#{nodePortAutoAssign}#$nodePortAutoAssign#g" "$file"
    else
        sed -i -e '/{nodePortAutoAssign}/d' "$file"
    fi
    if [[ -z "$externalType" ]] && [[ "$nodePortAutoAssign" != "true" ]];then
        tplRemoveBeginToEnd "$file" "frontendIngress"
    fi

    #CR#OCTCR19S1765190
    if [[ "$CDF_NAMESPACE" == "core" ]]; then
        sed -i -e "s@{vault.realmList}@RIC:$CERTIFICATE_PERIOD,RID:$CERTIFICATE_PERIOD,RE:$CERTIFICATE_PERIOD@g" "$file"
    else
        sed -i -e "s@{vault.realmList}@RID:$CERTIFICATE_PERIOD,RE:$CERTIFICATE_PERIOD@g" "$file"
    fi

    local externalAccessCertPort=
    if [[ -n "$SILENT_CONFIG_FILE" ]];then
        externalAccessCertPort="$(getValueFromConfig '.connection.externalAccessCertPort')"
    fi
    if [[ -n "$externalAccessCertPort" ]];then
        sed -i -e "s@{externalAccessCertPort}@$externalAccessCertPort@g" "$file"
    else
        sed -i -e '/{externalAccessCertPort}/d' "$file"
    fi

    local internal=
    local cdfapiserverdbTlsEnabled=false
    local cdfapiserverdbTlsCert=
    local cdfapiserverdbUrl=
    local cdfapiserverdbUSer=
    local cdfapiserverdbPwd=
    if [ -n "$SUITEDB_URL" ] && [ -n "$SUITEDB_USER" ] && [ -n "$SUITEDB_PASSWORD" ];then
        internal=false
        if [ -n "$SUITEDB_CERT" ];then
            cdfapiserverdbTlsCert="$(cat $SUITEDB_CERT|base64 -w0)"
        fi
        cdfapiserverdbUrl=$SUITEDB_URL
        cdfapiserverdbUSer=$SUITEDB_USER
        cdfapiserverdbPwd=$SUITEDB_PASSWORD
    else
        internal=true
    fi

    local cdfapiserverdbEnabled=false
    if [  "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" -o "$CAPS_CLUSTER_MANAGEMENT" == "true" ] && [ -z "$SUITEDB_URL" ];then
        cdfapiserverdbEnabled=true
    fi

    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]];then
        # disable db in Helm mode, does not mean using external db.
        internal=false
    fi
    if [[ -n "$cdfapiserverdbTlsCert" ]] || [[ "$internal" == "true" ]];then
        cdfapiserverdbTlsEnabled=true
    fi

    if [[ -n "$CDF_APISERVER_POD_START_LIMIT" ]];then
        sed -i -e "s@{cdfapiserver.podStartLimit}@$CDF_APISERVER_POD_START_LIMIT@g" "$file"
    else
        sed -i -e '/{cdfapiserver.podStartLimit}/d' "$file"
    fi

    sed -i -e "s@{cdfapiserver.tlsEnabled}@$cdfapiserverdbTlsEnabled@g" "$file"

    sed -i -e "s@{cdfapiserverdb.enabled}@$cdfapiserverdbEnabled@g" "$file"
    sed -i -e "s@{cdfapiserver.internal}@$internal@g" "$file"
    if [[ -n "$cdfapiserverdbTlsCert" ]];then
        sed -i -e "s@{cdfapiserver.tlsCert}@$cdfapiserverdbTlsCert@g" "$file"
    else
        sed -i -e '/{cdfapiserver.tlsCert}/d' "$file"
    fi
    if [[ -n "$SUITEDB_TLS_SKIP_HOSTNAME_VERIFICATION" ]];then
        sed -i -e "s@{tlsSkipHostnameVerification}@$SUITEDB_TLS_SKIP_HOSTNAME_VERIFICATION@g" "$file"
    else
        sed -i -e "s@{tlsSkipHostnameVerification}@false@g" "$file"
    fi
    if [[ -n "$cdfapiserverdbUrl" ]];then
        sed -i -e "s#{cdfapiserver.dbUrl}#$cdfapiserverdbUrl#g" "$file"
    else
        sed -i -e '/{cdfapiserver.dbUrl}/d' "$file"
    fi
    if [[ -n "$cdfapiserverdbUSer" ]];then
        replaceEscapeValue "{cdfapiserver.user}" "$cdfapiserverdbUSer" "$file"
    else
        sed -i -e '/{cdfapiserver.user}/d' "$file"
    fi
    if [[ -n "$cdfapiserverdbPwd" ]];then
        replaceEscapeValue "{cdfapiserver.userPassword}" "$cdfapiserverdbPwd" "$file"
    else
        sed -i -e '/{cdfapiserver.userPassword}/d' "$file"
    fi

    if [[ -n "$SKIP_CHECK_ON_NODE_LOST" ]];then
        sed -i -e "s@{skipCheckOnNodeLost}@$SKIP_CHECK_ON_NODE_LOST@g" "$file"
    else
        sed -i -e '/{skipCheckOnNodeLost}/d' "$file"
    fi

    if [[ "$CDF_ADMIN_TASKS" =~ (^|,)ns(,|$) ]];then
        sed -i -e '/{deploymentUuid}/d' "$file"
    else
        local uuid=$(kubectl get ns $CDF_NAMESPACE -o json|$JQ -r '.metadata.labels."deployments.microfocus.com/deployment-uuid"')
        sed -i -e "s#{deploymentUuid}#$uuid#g" "$file"
    fi

    if [[ -n "$DEPLOYMENT_NAME" ]];then
        sed -i -e "s#{deploymentName}#$DEPLOYMENT_NAME#g" "$file"
    else
        sed -i -e '/{deploymentName}/d' "$file"
    fi

    if [[ "$SET_APPHUB_CLUSTER_ADMIN" == "true" ]];then
        sed -i -e "s#{requireClusterAdmin}#$SET_APPHUB_CLUSTER_ADMIN#g" "$file"
    else
        tplRemoveBeginToEnd "$file" "apphubApiserver"
    fi

    # CAPS_LOG_COLLECTION begin
    if [[ "$CAPS_LOG_COLLECTION" == "true" ]];then
        if [[ -n "$FLUENTD_LOG_RECEIVER_URL" ]];then
            replaceEscapeValue "{logging.receiver.url}" "$FLUENTD_LOG_RECEIVER_URL" "$file"
        else
            sed -i -e '/{logging.receiver.url}/d' "$file"
        fi

        if [[ -n "$FLUENTD_LOG_RECEIVER_USER" ]];then
            replaceEscapeValue "{logging.receiver.user}" "$FLUENTD_LOG_RECEIVER_USER" "$file"
        else
            sed -i -e '/{logging.receiver.user}/d' "$file"
        fi

        if [[ -n "$FLUENTD_LOG_RECEIVER_PASSWORD" ]];then
            replaceEscapeValue "{logging.receiver.password}" "$FLUENTD_LOG_RECEIVER_PASSWORD" "$file"
        else
            sed -i -e '/{logging.receiver.password}/d' "$file"
        fi

        if [[ -n "$FLUENTD_LOG_RECEIVER_TOKEN" ]];then
            replaceEscapeValue "{logging.receiver.token}" "$FLUENTD_LOG_RECEIVER_TOKEN" "$file"
        else
            sed -i -e '/{logging.receiver.token}/d' "$file"
        fi

        if [[ -n "$FLUENTD_LOG_RECEIVER_CA" ]];then
            sed -i -e "s@{logging.receiver.caCert}@$(cat $FLUENTD_LOG_RECEIVER_CA|base64 -w0)@g" "$file"
        else
            sed -i -e '/{logging.receiver.caCert}/d' "$file"
        fi

        if [[ -n "$FLUENTD_LOG_CACHE_LIMIT_SIZE" ]];then
            sed -i -e "s@{logging.input.storageLimitSize}@$FLUENTD_LOG_CACHE_LIMIT_SIZE@g" "$file"
        else
            sed -i -e '/{logging.input.storageLimitSize}/d' "$file"
        fi

        if [[ -n "$FLUENTD_LOG_CACHE_FOLDER" ]];then
            sed -i -e "s@{logging.input.dataDir}@$FLUENTD_LOG_CACHE_FOLDER@g" "$file"
        else
            sed -i -e '/{logging.input.dataDir}/d' "$file"
        fi

        sed -i -e "s@{logging.receiver.type}@$FLUENTD_LOG_RECEIVER_TYPE@g" "$file"
        sed -i -e "s@{logging.receiver.format}@$FLUENTD_LOG_RECEIVER_OUTPUT_FORMAT@g" "$file"
        sed -i -e "s@{logging.receiver.delimiter}@$FLUENTD_LOG_RECEIVER_OUTPUT_DELIMITER@g" "$file"

        if [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
            sed -i -e "s@{logging.hostLogDir.runtimeLog}@$RUNTIME_CDFDATA_HOME@g" "$file"
            sed -i -e "s@{logging.hostLogDir.cdfLog}@$CDF_HOME/log@g" "$file"
        else
            sed -i -e "s@{logging.hostLogDir.runtimeLog}@/var/lib@g" "$file"
            sed -i -e "s@{logging.hostLogDir.cdfLog}@@g" "$file"
        fi
    else
        tplRemoveBeginToEnd "$file" "CAPS_LOG_COLLECTION"
    fi
    # CAPS_LOG_COLLECTION end

    if [[ -n "$FLUENTD_LOG_RECEIVER_ES_CLOUDID" ]];then
        sed -i -e "s@{elasticSearch.cloudId}@$FLUENTD_LOG_RECEIVER_ES_CLOUDID@g" "$file"
    else
        tplRemoveBeginToEnd "$file" "elasticSearch.cloud.config"
    fi

    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]] && [[ "$CAPS_CLUSTER_MANAGEMENT" == "false" ]];then
        sed -i -e '/dbVolumeClaim: db-single-vol/d' "$file"
        tplRemoveBeginToEnd "$file" "featureGates"
        if [[ ! "$CDF_ADMIN_TASKS" =~ (^|,)pv(,|$) ]];then
            sed -i -e '/logVolumeClaim: itom-logging-vol/d' "$file"
        fi
    fi

    # Remove the component fields that are not enabled.

    if [[ "$CAPS_SUITE_DEPLOYMENT_MANAGEMENT" == "false" ]] || [[ "$CAPS_DEPLOYMENT_MANAGEMENT $CAPS_CLUSTER_MANAGEMENT" == "false false" ]];then
        tplRemoveBeginToEnd "$file" "cdfapiserver"
    fi

    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT $CAPS_CLUSTER_MANAGEMENT $CAPS_MONITORING" == "false false false" ]];then
        tplRemoveBeginToEnd "$file" "vault"
        tplRemoveBeginToEnd "$file" "portalIngress"
    fi

    if [[ -n "$SILENT_CONFIG_FILE" ]] && [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ]] && [[ -z "$METADATA" ]];then
        patchValuesYaml "$file" "$internal"
    fi
}

getValueFromConfig(){
    local filter=$1
    exec_cmd "$JQ -r '$filter // empty' $SILENT_CONFIG_FILE" -p=true
}

patchValuesYaml(){
    local file=$1
    local globalDbInternal=$2
    local externalHostname="$EXTERNAL_ACCESS_HOST"
    # byok: prefer to use CLI parameters; if CLI has no value, then use the config parameter;;
    # on-premise: use the config.json parameter;
    if [[ -z "$externalHostname" ]] || [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
        externalHostname="$(getValueFromConfig '.connection.externalHostname')"
        externalHostname="$(echo "$externalHostname"|tr '[:upper:]' '[:lower:]')"
    fi
    local rootCrt="$(getValueFromConfig '.connection.rootCrt')"
    local serverCrt="$(getValueFromConfig '.connection.serverCrt')"
    local serverKey="$(getValueFromConfig '.connection.serverKey')"
    # local port="$(getValueFromConfig '.connection.port')"
    # local certAuthPort="$(getValueFromConfig '.connection.certAuthPort')"
    # local serverCrtFile="$(getValueFromConfig '.connection.serverCrtFile')"
    # local serverCrtPassword="$(getValueFromConfig '.connection.serverCrtPassword')"
    local serverCrtType="$(getValueFromConfig '.connection.serverCrtType')" #""
    if [[ "$serverCrtType" == "PKCS#12" ]];then
        if [ ! -f "$CDF_INSTALL_RUNTIME_HOME/pfx_server.key" -o ! -f "$CDF_INSTALL_RUNTIME_HOME/pfx_server.crt" ]; then
             write_log "fatal" "Failed to get $CDF_INSTALL_RUNTIME_HOME/pfx_server.key or $CDF_INSTALL_RUNTIME_HOME/pfx_server.crt from $SILENT_CONFIG_FILE"
        fi
        serverCrt="$CDF_INSTALL_RUNTIME_HOME/pfx_server.crt"
        serverKey="$CDF_INSTALL_RUNTIME_HOME/pfx_server.key"
    fi

    local dbType=""
    local dbHost=""
    local dbPort=""
    local dbName=""
    local dbUser=""
    local dbPassword=""
    local dbEmbedded=""
    local dbSslEnable="false"
    local dbAutoCreate=""
    local dbConnectionString=""
    local dbSchema=""
    local dbOrcway=""
    local dbSid=""
    local dbCert=""
    local dbTlsSkipHostnameVerification=""
    local type="$(getValueFromConfig '.database.type')"

    if [[ "$type" == "intpostgres" ]];then
        dbType="postgresql"
        dbEmbedded="true"
        dbSslEnable="true"
        dbAutoCreate="true"
        # dbHost="itom-postgresql.$CDF_NAMESPACE"
        # dbPort="5432"
        # dbName="cdfidmdb"
        # dbUser="postgres"
        dbPassword=""
        dbConnectionString=""
        dbSchema=""
        dbOrcway=""
        # dbCert="$(getValueFromConfig '.database.param.dbCert')"
        dbSid=""
    fi

    #"extpostgres"
    if [[ "$type" == "extpostgres" ]];then
        dbType="postgresql"
        dbEmbedded="false"
        dbAutoCreate="$(getValueFromConfig '.database.param.dbAutoCreate')"
        dbHost="$(getValueFromConfig '.database.param.dbHost')"
        dbPort="$(getValueFromConfig '.database.param.dbPort')"
        dbName="$(getValueFromConfig '.database.param.dbName')"
        dbUser="$(getValueFromConfig '.database.param.dbUser')"
        dbPassword="$(getValueFromConfig '.database.param.dbPassword')"
        dbSchema="$(getValueFromConfig '.database.param.dbSchema')"
        dbCert="$(getValueFromConfig '.database.param.dbCert')"
        dbTlsSkipHostnameVerification="$(getValueFromConfig '.database.param.dbTlsSkipHostnameVerification')"
        dbOrcway=""
        dbConnectionString=""
        dbSid=""
    fi
    # "extoracle"
    if [[ "$type" == "extoracle" ]];then
        dbType="oracle"
        dbEmbedded="false"
        dbAutoCreate="$(getValueFromConfig '.database.param.dbAutoCreate')"
        dbSchema="$(getValueFromConfig '.database.param.dbSchema')"
        dbPassword="$(getValueFromConfig '.database.param.dbPassword')"
        dbHost="$(getValueFromConfig '.database.param.dbHost')"
        dbPort="$(getValueFromConfig '.database.param.dbPort')"
        dbName="$(getValueFromConfig '.database.param.dbName')"
        dbUser="$(getValueFromConfig '.database.param.dbUser')"
        dbOrcway="$(getValueFromConfig '.database.param.dbOrcway')"
        dbConnectionString="$(getValueFromConfig '.database.param.dbConnectionString')"
        dbCert="$(getValueFromConfig '.database.param.dbCert')"
        dbSid="$(getValueFromConfig '.database.param.dbSid')"
    fi

    if [[ -n "$externalHostname" ]]; then
        updateValues ${file} ${file} '.global.externalAccessHost' "${externalHostname}"
    fi
    # if [[ -n "$port" ]]; then
    #     updateValues ${file} ${file} '.global.externalAccessPort' "${port}"
    # fi
    ##set idm/portalIngress/frontendIngress pod replicas to 1 OCTCR19S1412756 in 2021.11
    if [[ "${CAPS_DEPLOYMENT_MANAGEMENT}" == "true" ]] || [[ "${CAPS_CLUSTER_MANAGEMENT}" == "true" ]] || [[ "${CAPS_MONITORING}" == "true" ]] ; then
        updateValues ${file} ${file} '.portalIngress.deployment.replicas' "1"
    fi
    if [[ "${CAPS_DEPLOYMENT_MANAGEMENT}" == "true" ]] || [[ "${CAPS_CLUSTER_MANAGEMENT}" == "true" ]] ;then
        updateValues ${file} ${file} '.idm.deployment.replicas' "1"
    fi
    if [[ "${CAPS_DEPLOYMENT_MANAGEMENT}" == "true" ]] ; then
        updateValues ${file} ${file} '.frontendIngress.deployment.replicas' "1"
    fi
    ##set idm pod replicas to 1 OCTCR19S1412756 in 2021.11
    updateValues ${file} ${file} '.idm.deployment.replicas' "1"

    ###OCTCR19S1415319  [Install]Enable monitoring capability failed due to Secret "sh.helm.release.v1.apphub.v3"  invalid error
    if [[ -f "$serverCrt" ]] && [[ -s "$serverCrt" ]]; then
        local serverCrtContent=$(cat $serverCrt|base64 -w0)
        updateValues ${file} ${file} '.portalIngress.nginx.tls.cert' "${serverCrtContent}"
        updateValues ${file} ${file} '.frontendIngress.nginx.tls.cert' "${serverCrtContent}"
    fi
    if [[ -f "$serverKey" ]] && [[ -s "$serverKey" ]]; then
        local serverKeyContent=$(cat $serverKey|base64 -w0)
        updateValues ${file} ${file} '.portalIngress.nginx.tls.key' "${serverKeyContent}"
        updateValues ${file} ${file} '.frontendIngress.nginx.tls.key' "${serverKeyContent}"
    fi
    if [[ -f "$rootCrt" ]] && [[ -s "$rootCrt" ]]; then
        local caContent=$(cat $rootCrt|base64 -w0)
        updateValues ${file} ${file} '.caCertificates."CUS_ca.crt"' "${caContent}"
    fi

    local dbCertContent=
    if [[ -n "${dbCert}" ]];then
        dbSslEnable=true
        local mergeCert="${TMP_FOLDER}/.cdf_dbcerts.tmp"
        createDbCertsMergeFile "$dbCert" "$mergeCert"
        dbCertContent="$(cat "$mergeCert"|base64 -w0)"
    fi

    # updateValues ${file} ${file} '.global.cluster.k8sProvider' "generic"
    updateValues ${file} ${file} '.global.database.internal' "${dbEmbedded}"
    updateValues ${file} ${file} '.global.database.createDb' "${dbAutoCreate}"
    updateValues ${file} ${file} '.global.database.tlsEnabled' "${dbSslEnable}"
    updateValues ${file} ${file} '.global.database.admin' "${dbUser}"
    updateValues ${file} ${file} '.global.database.adminPassword' "CDF_FLAG_global_database_adminPassword"
    replaceEscapeValue "CDF_FLAG_global_database_adminPassword" "${dbPassword}" "$file"
    updateValues ${file} ${file} '.global.database.type' "${dbType}"
    updateValues ${file} ${file} '.global.database.host' "${dbHost}"
    updateValues ${file} ${file} '.global.database.port' "${dbPort}"
    updateValues ${file} ${file} '.global.database.tlsCert' "${dbCertContent}"
    updateValues ${file} ${file} '.global.database.tlsSkipHostnameVerification' "${dbTlsSkipHostnameVerification}"
    updateValues ${file} ${file} '.global.database.oracleConnectionString' "${dbConnectionString}"

    if [[ "$dbType" == "oracle" ]];then
        if [[ -n "${dbSid}" ]];then
            updateValues ${file} ${file} '.global.database.oracleSid' "${dbSid}"
        else
            # To compatible with earlier versions.
            updateValues ${file} ${file} '.global.database.oracleSid' "${dbName}"
        fi
    fi

    updateValues ${file} ${file} '.defaultdb.persistence.dbVolumeClaim' "db-single-vol"
    updateValues ${file} ${file} '.defaultdb.persistence.subPath' "baseinfra-1.0/postgresql106"
    updateValues ${file} ${file} '.defaultdb.labels."deployments.microfocus.com/component"' "itom-db-default"

    if [[ "$dbAutoCreate" == "true" ]];then
        updateValues ${file} ${file} '.idm.deployment.database.user' ""
        updateValues ${file} ${file} '.idm.deployment.database.userPassword' ""
        updateValues ${file} ${file} '.idm.deployment.database.schema' ""
        updateValues ${file} ${file} '.idm.deployment.database.dbName' ""

        updateValues ${file} ${file} '.apphub-apiserver.deployment.database.user' ""
        updateValues ${file} ${file} '.apphub-apiserver.deployment.database.userPassword' ""
        updateValues ${file} ${file} '.apphub-apiserver.deployment.database.schema' ""
        updateValues ${file} ${file} '.apphub-apiserver.deployment.database.dbName' ""
    else
        updateValues ${file} ${file} '.idm.deployment.database.user' "${dbUser}"
        updateValues ${file} ${file} '.idm.deployment.database.userPassword' "CDF_FLAG_idm_deployment_database_userPassword"
        replaceEscapeValue "CDF_FLAG_idm_deployment_database_userPassword" "${dbPassword}" "$file"
        updateValues ${file} ${file} '.idm.deployment.database.schema' "${dbSchema}"
        updateValues ${file} ${file} '.idm.deployment.database.dbName' "${dbName}"

        updateValues ${file} ${file} '.apphub-apiserver.deployment.database.user' "${dbUser}"
        updateValues ${file} ${file} '.apphub-apiserver.deployment.database.userPassword' "CDF_FLAG_apphub_apiserver_deployment_database_userPassword"
        replaceEscapeValue "CDF_FLAG_apphub_apiserver_deployment_database_userPassword" "${dbPassword}" "$file"
        updateValues ${file} ${file} '.apphub-apiserver.deployment.database.schema' "${dbSchema}"
        updateValues ${file} ${file} '.apphub-apiserver.deployment.database.dbName' "${dbName}"
    fi
}

startMiniCdf(){
    write_log "step" "Upload the $CDF_HELM_RELEASE_NAME chart to Kubernetes ..."
    if stepNotDone $FUNCNAME; then
        updateValuesYaml
        local file="$CDF_HOME/objectdefs/cdf-chart.values.yaml"
        local tgz="${CURRENTDIR}/cdf/charts/${CHART_ITOM_APPHUB_MINI}"
        local appendUserYaml= cdfPkiJson cdfCaKey cdfCaCert
        cdfPkiJson=$(exec_cmd "kubectl get secret cdf-pki -n $CDF_NAMESPACE -o json" -p true)
        if [ $? -eq 0 ];then
            cdfCaCert=$(echo "$cdfPkiJson" | jq -r '.data."cdf_ca.crt"?')
        fi
        # helm mode (non-suite)
        if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]] || [ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" -a -n "$SILENT_CONFIG_FILE" -a -z "$METADATA" ];then
            tgz="${CURRENTDIR}/cdf/charts/${CHART_ITOM_APPHUB}"
        fi
        if [[ -n "$APPHUB_HELM_VALUES" ]] && [[ -f "$APPHUB_HELM_VALUES" ]];then
            appendUserYaml=" -f $APPHUB_HELM_VALUES "
        fi

        if [ -n "$cdfCaCert" ] && [ "$cdfCaCert" != "null" ];then
            appendUserYaml=" --set 'caCertificates.cdf_ca\.crt'=$cdfCaCert $appendUserYaml "
        fi

        exec_cmd "${CDF_HOME}/bin/helm upgrade --debug --install $CDF_HELM_RELEASE_NAME $tgz -n $CDF_NAMESPACE -f $file $appendUserYaml"

        if [ $? -ne 0 ]; then
            write_log "fatal" "Failed to start up $CDF_HELM_RELEASE_NAME. $LOG_SUPPORT_MSG" "failed"
        fi

        setStepDone $FUNCNAME
        showStatus "ok"
    else
        showStatus "Already done"
    fi
    # exit 100
}

checkAll(){
    # if [[ "$NODE_TYPE" == "first" ]] && [[ -f "$SILENT_CONFIG_FILE" ]];then
    #     write_log "step" "Check the silent installation configuration file ..."
    # else
    #     write_log "step" "Check the installation parameters ..."
    # fi
    #when db check failed, user may re-run, db parameters should also be checked in re-run
    #but we should not check when extending nodes
    if [ "$NODE_TYPE" = "first" ];then
        if [[ "$CAPS_SUITE_DEPLOYMENT_MANAGEMENT" == "true" ]];then
            checkCdfapiserverDbParameter
            checkDBConflicts
        fi
    fi
    if [ "$NODE_TYPE" = "first" ] && [ ! -f "$STEPS_FILE" ] ; then
        checkAllCaNumber
        checkCustomRegistryCa
        checkAppHubHelmValues
        checkNodeHostnames
        # checkNodeConnect
        configNfsFirewallSettings
        checkDeployerNFSForClassic
        if [ -n "$SILENT_CONFIG_FILE" ]; then
            checkConfigJsonSchema
            if [ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ];then
                checkConfigJson
            else
                checkConfigJsonForHelm
            fi
        fi
    fi
    if [[ -n "$JUST_FOR_CDF_SILENT_RERUN" ]]; then
        [[ -n "$SILENT_CONFIG_FILE" ]] && preCheckSilentConfig
    fi
    # showStatus "ok"
    if [ "$NODE_TYPE" = "first" ]; then
        checkLBConnection
        precheckAll
        checkOpenssl
        checkMetadataForSuite
        createSuperUser
    fi
}

installInfra(){
    if ! bash ${CURRENTDIR}/cri/scripts/install-containerd.sh;then
        write_log "fatal" "containerd installation failed."
    fi
    if ! bash ${CURRENTDIR}/k8s/scripts/install-k8s.sh;then
        write_log "fatal" "k8s installation failed."
    fi
    if [ "$NODE_TYPE" = "first" ] && [ "$DOCKER_REPOSITORY" = "localhost:5000" ] ; then
        loadNodeImages
        tagImages
    fi
}

deployMiniCdf(){
    # itom-cdf-common begin
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" ]];then
        createYamlTemplatesConfigMap
    fi
    # helm mode (non-suite)
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]] || [ "$CAPS_DEPLOYMENT_MANAGEMENT" == "true" -a -n "$SILENT_CONFIG_FILE" -a -z "$METADATA" ];then
        configureVolumes
    fi
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]];then
        labelCdfNamespace
    fi
    if [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
        applyCdfPriorityClass
        createAddNodeConfigMap
    else
        if [[ "$CDF_ADMIN_TASKS" =~ (^|,)no(,|$) ]];then
            addLabelOnNodes
        fi
    fi
    # itom-cdf-common end
    if [[ "$CAPS_DEPLOYMENT_MANAGEMENT" == "false" ]] && [[ "$CAPS_CLUSTER_MANAGEMENT" == "false" ]] && [[ "$CAPS_LOG_COLLECTION" == "false" ]] && [[ "$CAPS_MONITORING" == "false" ]] && [[ "$CAPS_MONITORING_CONTENT" == "false" ]];then
        return
    fi
    startMiniCdf
}

enableK8sBackup(){
    if [[ "$CAPS_K8S_BACKUP" == "true" ]];then
        write_log "step" "Enable kubernetes backup ..."
        if stepNotDone $FUNCNAME; then
            local componentName=itom-velero
            #uninstall velero chart for rerun
            if ${CDF_HOME}/bin/helm list -q -n $CDF_NAMESPACE|grep $componentName >/dev/null 2>&1; then
                exec_cmd "${CDF_HOME}/bin/helm uninstall $componentName -n $CDF_NAMESPACE"
                if [ $? -ne 0 ]; then
                    write_log "fatal" "Failed to uninstall $componentName helm release for redeploy. $LOG_SUPPORT_MSG" "failed"
                fi
            fi
            #deploy velero chart
            if [[ "$K8S_PROVIDER" =~ ^cdf ]];then
                local accessKey='cloudserver'
                local secretKey=$CLOUDSERVER_SECRET_KEY
                local customerKey=$CLOUDSERVER_CUSTOMER_KEY
                local s3Cert='itom-cloudserver'
                local labelKey="$(echo "$MASTER_NODELABEL_KEY"|sed 's/\./\\./g')"
                local labelVal="$(echo "$MASTER_NODELABEL_VAL"|sed 's/\./\\./g')"
                exec_cmd "${CDF_HOME}/bin/helm upgrade --debug --install $componentName ${CURRENTDIR}/cdf/charts/${CHART_ITOM_VELERO} -n $CDF_NAMESPACE --wait --timeout 15m \
                          $SET_HELM_CHART_TLS_OPTIONS \
                          --set global.docker.imagePullSecret=registrypullsecret \
                          --set global.docker.registry=$DOCKER_REPOSITORY \
                          --set global.docker.orgName=$REGISTRY_ORGNAME \
                          --set global.securityContext.user=$SYSTEM_USER_ID \
                          --set global.securityContext.fsGroup=$SYSTEM_GROUP_ID \
                          --set global.cluster.tolerations[0].key=$TAINT_MASTER_KEY \
                          --set global.cluster.tolerations[0].operator=Exists \
                          --set global.cluster.tolerations[0].effect=NoSchedule \
                          --set-string global.nodeSelector.\"$labelKey\"=\"$labelVal\" \
                          --set fullnameOverride=velero \
                          --set configuration.provider=aws \
                          --set snapshotsEnabled=false \
                          --set cleanUpCRDs=true \
                          --set upgradeCRDs=true \
                          --set cloudserver.deployment.accessKey=${accessKey} \
                          --set cloudserver.deployment.secretKey=${secretKey} \
                          --set cloudserver.deployment.masterKey=${customerKey} \
                          --set cloudserver.deployment.tls.crt=$(cat $CDF_HOME/ssl/$s3Cert.crt | base64 -w0) \
                          --set cloudserver.deployment.tls.key=$(cat $CDF_HOME/ssl/$s3Cert.key | base64 -w0) \
                          --set cloudserver.deployment.tls.ca=$(cat $CDF_HOME/ssl/ca.crt | base64 -w0) \
                          --set configuration.backupStorageLocation.caCert=$(cat $CDF_HOME/ssl/ca.crt | base64 -w0)"
            elif [[ "$K8S_PROVIDER" =~ ^(aws|azure|gcp|openshift|generic)$ ]];then
                #common cmd
                local commCmd="${CDF_HOME}/bin/helm upgrade --debug --install $componentName ${CURRENTDIR}/cdf/charts/${CHART_ITOM_VELERO} -n $CDF_NAMESPACE --wait --timeout 15m "
                #common options
                if [[ "$K8S_PROVIDER" =~ ^(openshift|generic)$ ]]; then
                    local provider="aws"
                else
                    local provider="$K8S_PROVIDER"
                fi
                local commonOpts="--set fullnameOverride=velero \
                            --set cleanUpCRDs=true \
                            --set upgradeCRDs=true \
                            --set global.cluster.k8sProvider=$provider \
                            $SET_HELM_CHART_TLS_OPTIONS \
                            --set global.docker.imagePullSecret=registrypullsecret \
                            --set global.docker.registry=$DOCKER_REPOSITORY \
                            --set global.docker.orgName=$REGISTRY_ORGNAME \
                            --set global.securityContext.user=$SYSTEM_USER_ID \
                            --set global.securityContext.fsGroup=$SYSTEM_GROUP_ID \
                            --set configuration.provider=$provider \
                            --set configuration.backupStorageLocation.bucket=$BACKUP_STORAGE_BUCKET \
                            --set cloudserver.deployment.enabled=false"
                if [ -n "$BACKUP_STORAGE_SECRET" ]; then
                    local credentialOpt="--set credentials.existingSecret=$BACKUP_STORAGE_SECRET "
                elif [ -n "$BACKUP_STORAGE_CREDENTIAL_FILE" ]; then
                    local credentialOpt="--set-file credentials.secretContents.cloud=$BACKUP_STORAGE_CREDENTIAL_FILE "
                fi
                #specific options
                if [[ "$K8S_PROVIDER" = "aws" ]]; then
                    local sse="AES256"
                    local specOptions="--set configuration.backupStorageLocation.config.region=$AWS_BUCKET_REGION \
                          --set configuration.backupStorageLocation.config.serverSideEncryption=$sse \
                          --set configuration.volumeSnapshotLocation.config.region=$AWS_BUCKET_REGION "
                elif [ "$K8S_PROVIDER" = "azure" ]; then
                    local apiTimeout="5m"
                    local specOptions="--set configuration.backupStorageLocation.config.resourceGroup=$BACKUP_RESOURCE_GROUP \
                          --set configuration.backupStorageLocation.config.storageAccount=$BACKUP_STORAGE_ACCOUNT \
                          --set configuration.volumeSnapshotLocation.config.apiTimeout=$apiTimeout "
                elif [[ "$K8S_PROVIDER" =~ ^(openshift|generic)$ ]]; then
                    local specOptions="--set snapshotsEnabled=false \
                          --set configuration.backupStorageLocation.config.region=s3 \
                          --set configuration.backupStorageLocation.config.s3ForcePathStyle=true \
                          --set configuration.backupStorageLocation.config.s3Url=$BACKUP_STORAGE_API_URL "
                    if [ -n "$BACKUP_STORAGE_API_CA" ]; then
                        specOptions="$specOptions --set configuration.backupStorageLocation.caCert=$(cat $BACKUP_STORAGE_API_CA | base64 -w0)"
                    fi
                fi
                # helm install
                exec_cmd "$commCmd $commonOpts $credentialOpt $specOptions"
            fi

            # helm install command return error
            if [ $? -ne 0 ]; then
                write_log "fatal" "Failed to start up $componentName. $LOG_SUPPORT_MSG" "failed"
            fi

            #create the schedule just after deploy velero and remove the first backup
            local backupName
            local scheduleName="k8s-backup"
            if [ "$K8S_PROVIDER" = "openshift" ];then
                local excludeNs="kube-system,default,openshift*"
            else
                local excludeNs="kube-system,default"
            fi
            #enable schedule backup
            exec_cmd "${CDF_HOME}/bin/velero schedule create $scheduleName --schedule=\"0 0 * * *\" --exclude-namespaces='$excludeNs'"
            if [ $? -ne 0 ]; then
                write_log "fatal" "Failed to create schedule backup. $LOG_SUPPORT_MSG" "failed"
            fi
            #check bsl status is Available
            local reTryTimes=0
            while true
            do
               local bslStatus=$(exec_cmd "kubectl get bsl default -n $CDF_NAMESPACE -o json | $JQ -r '.status.phase'" -p=true)
                if [[ "$bslStatus" == "Available" ]]; then
                    break
                elif [[ $reTryTimes -eq $RETRY_TIMES ]]; then
                    write_log "fatal" "The bsl status is $bslStatus; please check cloudserver pod log." "failed"
                else
                    write_log "debug" "The bsl status is $bslStatus. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                fi
                reTryTimes=$(( $reTryTimes + 1 ))
                sleep $SLEEP_TIME
            done
            #create a backup for test
            local backupName="installer-test-velero-backup"
            if velero get backup $backupName >/dev/null 2>&1; then
                exec_cmd "echo 'Y' | ${CDF_HOME}/bin/velero delete backup $backupName"
                sleep $SLEEP_TIME
            fi
            exec_cmd "${CDF_HOME}/bin/velero backup create $backupName --exclude-namespaces='$excludeNs'"
            if [ $? -ne 0 ]; then
                write_log "fatal" "Failed to create test backup. $LOG_SUPPORT_MSG" "failed"
            fi
            #check backup status, raise error if status is not Completed finally
            local reTryTimes=0
            while true
            do
                local backupJson=$(kubectl get backup $backupName -n $CDF_NAMESPACE -o json 2>/dev/null)
                local backupStatus=$(exec_cmd "echo '$backupJson' | $JQ -r '.status.phase'" -p=true)
                if [ "$backupStatus" = "Completed" ]; then
                    break
                elif [[ $reTryTimes -eq $RETRY_TIMES ]]; then
                    write_log "fatal" "Failed to create backup. $LOG_SUPPORT_MSG" "failed"
                elif [ "$backupStatus" = "Failed" -o "$backupStatus" = "PartiallyFailed" ]; then
                    local reason=$(exec_cmd "echo '$backupJson' | $JQ -r '.status.failureReason'" -p=true)
                    if [[ $reason =~ "status code: 500" ]] || [[ $reason =~ "TLS handshake timeout" ]]; then #internal server error, maybe server is not available now, need to retry.
                        write_log "debug" "Failed to create backup: $reason. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                        #delete && create
                        exec_cmd "echo 'Y' | ${CDF_HOME}/bin/velero delete backup $backupName"
                        sleep $SLEEP_TIME
                        exec_cmd "${CDF_HOME}/bin/velero backup create $backupName --exclude-namespaces='$excludeNs'"
                    else
                        write_log "fatal" "Create backup failed, please make sure you provide the correct backup parameters for installation. $LOG_SUPPORT_MSG" "failed"
                    fi
                else
                    write_log "debug" "Failed to create backup or backup is still in progress. Wait for $SLEEP_TIME seconds and retry: $reTryTimes"
                fi
                reTryTimes=$(( $reTryTimes + 1 ))
                sleep $SLEEP_TIME
            done
            #delete test backup
            exec_cmd "echo 'Y' | ${CDF_HOME}/bin/velero delete backup $backupName"
            if [ $? -ne 0 ]; then
                write_log "warn" "Failed to delete test backup $backupName; you can delete it manually later. $LOG_SUPPORT_MSG" "warning"
            fi
            #set label on secret for uninstall
            local secretName="velero-restic-credentials"
            if exec_cmd "kubectl get secret $secretName -n ${CDF_NAMESPACE}"; then
                exec_cmd "kubectl label secret $secretName -n ${CDF_NAMESPACE} deployments.microfocus.com/cleanup=uninstall --overwrite"
                if [ $? -ne 0 ]; then
                    write_log "warn" "Failed to label secret $secretName; you can label it manually later (deployments.microfocus.com/cleanup=uninstall). $LOG_SUPPORT_MSG" "warning"
                fi
            fi
            #set done
            setStepDone $FUNCNAME
            showStatus "ok"
            [[ "$K8S_PROVIDER" =~ ^cdf ]] && exec_cmd "rm -rf $CDF_HOME/ssl/${s3Cert}.*"
        else
            showStatus "Already done"
        fi
    fi
}

prechecksForBYOK(){
    #check os for bastion node, supported OS: rhel, centos, ubuntu, oracle and amazon linux
    local isSupportedOS=$(cat /etc/os-release 2>/dev/null | grep -iE 'Oracle Linux|CentOS Linux|Red Hat Enterprise Linux|Amazon Linux|Ubuntu' | wc -l)
    if [ "$isSupportedOS" -eq 0 ]; then
        #not supported os or no read permission or not find os-release file
        if [ "$CLI_SKIP_PRECHECK_WARNING" != "true" ]; then
            echo "! Warning: The release of this Linux distro is not certified, this may cause the problems on installation or tools usage. Please refer to the support matrix for detailed information."
            read -p "Are you sure you want to continue? (Yy/Nn) " confirm
            if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                exit 1
            fi
        fi
    fi
}

##MAIN
# CLI Option types:
# P1 (Phase 1)  -- used for mini CDF installation
# P2 (Phase 2)  -- used for extending node
#   -Mandatory  -- mandatory option
#   -Optional   -- optional, only used when value is set
#   --All       -- used for extending both master and worker nodes
#   --Master    -- Only used when extending MASTER node
#   --Worker    -- Only used when extending WORKER node

if [ "$(find "$CURRENTDIR/" -maxdepth 5 -name kubelet -type f 2>/dev/null|wc -l)" -gt 0 ];then
    while true;do
        if echo "$@"|grep -Pq '(^|\s)--noinfra(\s|$)';then
            export INSTALLED_TYPE="BYOK"; break
        fi
        input_k8s_provider="$(echo "$@"|grep -Po '(^|\s)--k8s-provider\s+[\S]+'|xargs|awk '{print $2}')"
        if [[ -n "$input_k8s_provider" ]];then
            if [[ "$input_k8s_provider" =~ ^cdf ]];then
                export INSTALLED_TYPE="CLASSIC"; break
            else
                export INSTALLED_TYPE="BYOK"; break
            fi
        fi
        export INSTALLED_TYPE="CLASSIC"; break
    done
else
    export INSTALLED_TYPE="BYOK"
fi

if [[ "$INSTALLED_TYPE" == "CLASSIC" ]];then
    export CLI_NOINFRA="false"
    export readonly CDF_PROFILE="/etc/profile.d/itom-cdf.sh"

    if [ -f "${CURRENTDIR}/scripts/common.sh" ];then
        source ${CURRENTDIR}/scripts/common.sh
    fi
else
    export CLI_NOINFRA="true"
    export readonly CDF_PROFILE="$HOME/itom-cdf.sh"
fi

[[ -f "$CDF_PROFILE" ]] && source $CDF_PROFILE

CLI_ARGS_JSON='[]'

while [ ! -z $1 ]; do
    step=2 ##shift step,default 2
    case "$1" in
      -m|--metadata )                           setOptionVal "$1" "$2" "METADATA";;
      -p|--properties )                         setOptionVal "$1" "$2" "CLI_CONFIGFILE";;
      --backup-storage-api-ca)                  setOptionVal "$1" "$2" "CLI_BACKUP_STORAGE_API_CA";;
      --backup-storage-api-url)                 setOptionVal "$1" "$2" "CLI_BACKUP_STORAGE_API_URL";;
      --backup-storage-bucket)                  setOptionVal "$1" "$2" "CLI_BACKUP_STORAGE_BUCKET";;
      --backup-storage-credential-file)         setOptionVal "$1" "$2" "CLI_BACKUP_STORAGE_CREDENTIAL_FILE";;
      --backup-storage-secret)                  setOptionVal "$1" "$2" "CLI_BACKUP_STORAGE_SECRET";;
      --backup-resource-group)                  setOptionVal "$1" "$2" "CLI_BACKUP_RESOURCE_GROUP";;
      --backup-storage-account)                 setOptionVal "$1" "$2" "CLI_BACKUP_STORAGE_ACCOUNT";;
      --capabilities )                          setOptionVal "$1" "$2" "CLI_CAPABILITIES";;
      --cat|--cdf-admin-tasks )
        if [[ -z "$2" ]];then
            export CLI_CDF_ADMIN_TASKS="none"
            export CDF_ADMIN_TASKS="none"
        else
            setOptionVal "$1" "$2" "CLI_CDF_ADMIN_TASKS"
        fi
      ;;
      --cdf-home )                              setOptionVal "$1" "$2" "CLI_CDF_HOME";;
      --cdf-namespace )                         setOptionVal "$1" "$2" "CLI_CDF_NAMESPACE";;
      --cluster-wide-ingress )                  setOptionVal "$1" "$2" "CLI_CLUSTER_WIDE_INGRESS";;
      --logging-vol-size )                      setOptionVal "$1" "$2" "CLI_LOGGING_VOL_SIZE";;
      --apphub-helm-values )                    setOptionVal "$1" "$2" "CLI_APPHUB_HELM_VALUES";;
      --app-http-proxy )                        setOptionVal "$1" "$2" "CLI_APP_HTTP_PROXY";;
      --app-https-proxy )                       setOptionVal "$1" "$2" "CLI_APP_HTTPS_PROXY";;
      --app-no-proxy )                          setOptionVal "$1" "$2" "CLI_APP_NO_PROXY";;
      --auto-configure-firewall )               setOptionVal "$1" "$2" "CLI_AUTO_CONFIGURE_FIREWALL";;
      --aws-certificate-arn )                   setOptionVal "$1" "$2" "CLI_AWS_CERTIFICATE_ARN";;
      --aws-eip )                               setOptionVal "$1" "$2" "CLI_AWS_EIP";;
      --aws-region )                            setOptionVal "$1" "$2" "CLI_AWS_REGION";;
      --cloud-provider )                        setOptionVal "$1" "$2" "CLI_CLOUD_PROVIDER";;
      --k8s-provider )                          setOptionVal "$1" "$2" "CLI_K8S_PROVIDER";;
      --crt-http-proxy )                        setOptionVal "$1" "$2" "CLI_CRT_HTTP_PROXY";;
      --crt-https-proxy )                       setOptionVal "$1" "$2" "CLI_CRT_HTTPS_PROXY";;
      --crt-no-proxy )                          setOptionVal "$1" "$2" "CLI_CRT_NO_PROXY";;
      --fail-swap-on )                          setOptionVal "$1" "$2" "CLI_FAIL_SWAP_ON";;
      -fg|--feature-gates )                     setOptionVal "$1" "$2" "CLI_FEATURE_GATES";;
      --enable-fips )                           setOptionVal "$1" "$2" "CLI_ENABLE_FIPS";;
      --enable-k8s-audit-log )                  setOptionVal "$1" "$2" "CLI_ENABLE_K8S_AUDIT_LOG";;
      --fips-entropy-threshold )                setOptionVal "$1" "$2" "CLI_FIPS_ENTROPY_THRESHOLD";;
      --flannel-backend-type )                  setOptionVal "$1" "$2" "CLI_FLANNEL_BACKEND_TYPE";;
      --flannel-port )                          setOptionVal "$1" "$2" "CLI_FLANNEL_PORT";;
      --flannel-directrouting )                 setOptionVal "$1" "$2" "CLI_FLANNEL_DIRECTROUTING";;
      --flannel-iface )                         setOptionVal "$1" "$2" "CLI_FLANNEL_IFACE";;
      --ha-virtual-ip )                         setOptionVal "$1" "$2" "CLI_HA_VIRTUAL_IP";;
      --load-balancer-host )                    setOptionVal "$1" "$2" "CLI_LOAD_BALANCER_HOST";;
      --k8s-home )                              setOptionVal "$1" "$2" "CLI_K8S_HOME";;
      --runtime-home )                          setOptionVal "$1" "$2" "CLI_RUNTIME_CDFDATA_HOME";;
      --kubelet-home )                          setOptionVal "$1" "$2" "CLI_KUBELET_HOME";;
      --keepalived-nopreempt )                  setOptionVal "$1" "$2" "CLI_KEEPALIVED_NOPREEMPT";;
      --keepalived-virtual-router-id)           setOptionVal "$1" "$2" "CLI_KEEPALIVED_VIRTUAL_ROUTER_ID";;
      --keepalived-advert-int)                  setOptionVal "$1" "$2" "CLI_KEEPALIVED_ADVERT_INT";;
      --master-api-ssl-port )                   setOptionVal "$1" "$2" "CLI_MASTER_API_SSL_PORT";;
      --registry-orgname )                      setOptionVal "$1" "$2" "CLI_REGISTRY_ORGNAME";;
      --registry-ca)                            setOptionVal "$1" "$2" "CLI_REGISTRY_CA";;
      --cluster-name )                          setOptionVal "$1" "$2" "CLI_CLUSTER_NAME";;
      -D|--docker-repository|--registry-url )   setOptionVal "$1" "$2" "CLI_DOCKER_REPOSITORY";;
      --system-user-id )                        setOptionVal "$1" "$2" "CLI_SYSTEM_USER_ID";;
      --system-group-id )                       setOptionVal "$1" "$2" "CLI_SYSTEM_GROUP_ID";;
      --k8s-user-id )                           setOptionVal "$1" "$2" "CLI_K8S_USER_ID";;
      --k8s-group-id )                          setOptionVal "$1" "$2" "CLI_K8S_GROUP_ID";;
      --etcd-user-id )                          setOptionVal "$1" "$2" "CLI_ETCD_USER_ID";;
      --etcd-group-id )                         setOptionVal "$1" "$2" "CLI_ETCD_GROUP_ID";;
      --device-type)                            setOptionVal "$1" "$2" "CLI_DEVICE_TYPE";;
      --etcd-endpoint )                         setOptionVal "$1" "$2" "CLI_ETCD_ENDPOINT";;
      --k8s-master-ip )                         setOptionVal "$1" "$2" "K8S_MASTER_IP";;
      --node-host )                             setOptionVal "$1" "$2" "NODE_HOST";;
      --node-type )                             setOptionVal "$1" "$2" "NODE_TYPE";;
      --node-selector )                         setOptionVal "$1" "$2" "NODE_SELECTOR";;
      --pod-cidr )                              setOptionVal "$1" "$2" "CLI_POD_CIDR";;
      --pod-cidr-subnetlen )                    setOptionVal "$1" "$2" "CLI_POD_CIDR_SUBNETLEN";;
      --service-cidr )                          setOptionVal "$1" "$2" "CLI_SERVICE_CIDR";;
      --ipv6 )                                  setOptionVal "$1" "$2" "CLI_IPV6";;
      --ipv6-pod-cidr )                         setOptionVal "$1" "$2" "CLI_IPV6_POD_CIDR";;
      --ipv6-pod-cidr-subnetlen )               setOptionVal "$1" "$2" "CLI_IPV6_POD_CIDR_SUBNETLEN";;
      --ipv6-service-cidr )                     setOptionVal "$1" "$2" "CLI_IPV6_SERVICE_CIDR";;
      # internal parameter: --dns-svc-ip
      --dns-svc-ip )                            setOptionVal "$1" "$2" "CLI_DNS_SVC_IP";;
      --skip-check-on-node-lost )               setOptionVal "$1" "$2" "CLI_SKIP_CHECK_ON_NODE_LOST";;
      --skip-failed-worker-node )               setOptionVal "$1" "$2" "CLI_SKIP_FAILED_WORKER_NODE";;
      --tmp-folder )                            setOptionVal "$1" "$2" "CLI_TMP_FOLDER";;
      --deployment-log-location )               setOptionVal "$1" "$2" "CLI_DEPLOYMENT_LOG_LOCATION";;
      --session-name )                          setOptionVal "$1" "$2" "CLI_SESSION_NAME";;
      --kube-dns-hosts )                        setOptionVal "$1" "$2" "CLI_KUBE_DNS_HOSTS";;
      --validity )                              setOptionVal "$1" "$2" "CLI_CERTIFICATE_PERIOD";;
      # internal parameter : --just-for-cdf-silent-rerun
      --just-for-cdf-silent-rerun )             setOptionVal "$1" "$2" "JUST_FOR_CDF_SILENT_RERUN";;
      # Replace --ca-file --cert-file  --key-file
      --all-certs-dir )                         setOptionVal "$1" "$2" "CLI_ALL_CERTS_DIR";;
      -c|--config )                             setOptionVal "$1" "$2" "SILENT_CONFIG_FILE";;
      -e|--end-state )                          setOptionVal "$1" "$2" "END_STATE";;
      -i|--image-folder )                       setOptionVal "$1" "$2" "SILENT_IMAGE_FOLDER";;
      -t|--timeout )                            setOptionVal "$1" "$2" "SILENT_TIMEOUT_MINUTES";;
      -u|--username )                           setOptionVal "$1" "$2" "SILENT_SUPERUSER";;
      -d|-n|--deployment-name )                 setOptionVal "$1" "$2" "DEPLOYMENT_NAME";;
      --nfs-server )                            setOptionVal "$1" "$2" "NFS_SERVER";;
      --nfs-folder )                            setOptionVal "$1" "$2" "NFS_FOLDER";;
      --nfsprov-server )                        setOptionVal "$1" "$2" "NFS_PROV_SERVER";;
      --nfsprov-folder )                        setOptionVal "$1" "$2" "NFS_PROV_FOLDER";;
      --registry-username )                     setOptionVal "$1" "$2" "REGISTRY_USERNAME";;
      --registry-password )                     checkOptionVal "$1" "$2"; export REGISTRY_PASSWORD="$2";;
      --registry-password-file )                setOptionVal "$1" "$2" "REGISTRY_PASSWORD_FILE";;
      --external-access-host )                  setOptionVal "$1" "$2" "EXTERNAL_ACCESS_HOST";;
      --external-access-port )                  setOptionVal "$1" "$2" "CLI_EXTERNAL_ACCESS_PORT";;
      --loadbalancer-info )                     setOptionVal "$1" "$2" "LOADBALANCER_INFO";;
      --db-user)                                setOptionVal "$1" "$2" "SUITEDB_USER";;
      --db-url)                                 setOptionVal "$1" "$2" "SUITEDB_URL";;
      --db-crt)                                 setOptionVal "$1" "$2" "SUITEDB_CERT";;
      --db-tls-skip-hostname-verification)      setOptionVal "$1" "$2" "SUITEDB_TLS_SKIP_HOSTNAME_VERIFICATION";;
      --storage-class)                          setOptionVal "$1" "$2" "CLI_DEFAULT_STORAGE_CLASS";;
      --storage-class-mappings)                 setOptionVal "$1" "$2" "CLI_STORAGE_CLASS_MAPPINGS";;
      --tls-ciphers)                            setOptionVal "$1" "$2" "CLI_TLS_CIPHERS";;
      --tls-min-version)                        setOptionVal "$1" "$2" "CLI_TLS_MIN_VERSION";;
      --persistence-threshold)                  setOptionVal "$1" "$2" "CLI_PERSISTENCE_THREHOLD";;

      -P|--password )           # Silent install, can not use setOptionVal as eval can not handle special character like:$"',etc
        case "$2" in
          -*) write_log "fatal" "-P|--password parameter requires a value. ";;
          * ) if [ -z "$2" ];then write_log "fatal" "-P|--password parameter requires a value. "; elif [ $(validatePwd "$2"; echo $?) -ne 0 ]; then write_log "fatal" "Password does not meet policy requirement."; fi; SUPER_USERPWD=$2; ;;
        esac ;;
      --db-password )
        case "$2" in
          -*) write_log "fatal" "--db-password parameter requires a value. ";;
          * ) if [ -z "$2" ];then write_log "fatal" "--db-password parameter requires a value. ";  fi; SUITEDB_PASSWORD=$2; ;;
        esac ;;

      --set-fqdn-in-ingress )                   export CLI_SET_FQDN_IN_INGRESS="true"; step=1;;
      --apphub-cluster-admin )                  export CLI_SET_APPHUB_CLUSTER_ADMIN="true"; step=1;;
      --kubelet-protect-kernel-defaults )       export CLI_KUBELET_PROTECT_KERNEL_DEFAULTS="true"; step=1;;
      --skip-warning )                          export CLI_SKIP_PRECHECK_WARNING="true"; step=1;; # P1
      -R|--reconfig )                           export SILENT_RECONFIG="true"; SILENT_LIFECYCLE="reconfig"; step=1;;
      -U|--update )                             export SILENT_UPDATE="true"; SILENT_LIFECYCLE="update"; step=1;;
      --noinfra )                               export CLI_NOINFRA="true"; step=1;; # setup CDF phase1.2
      -h|--help )                               export CLI_PRINT_HELP="true"; step=1;; # P1
      *)  write_log "error" "Invalid parameter: $1";
          usage ;;
    esac

    if [[ $step -eq 2 ]];then
        if [[ ! -f "$PREVIOUS_INSTALL_CONFIG" ]];then
            checkParm "$1" "$2"
        fi
        saveParams "$1" "$2"
    else
        saveParams "$1"
    fi
    if ! shift $step;then
        # prevent the parameter at the end from not pass a value, for example: ./install [...options] --cat
        fatalOnInvalidParm "$1"
    fi
done

if [[ "$CLI_PRINT_HELP" == "true" ]];then
    usage
    exit 0
fi

for command_var in TAR MV RM CP;do
    command="$(echo $command_var|tr '[:upper:]' '[:lower:]')"
    command_val=""
    if [[ -x "/usr/bin/$command" ]];then
        command_val="/usr/bin/$command"
    elif [[ -x "/bin/$command" ]];then
        command_val="/bin/$command"
    fi
    if [[ -z "$command_val" ]];then
        find_cmd="$(which $command 2>/dev/null|xargs -n1|grep '^/')"
        if [[ -n "$find_cmd" ]] && [[ -x "$find_cmd" ]];then
            command_val="$find_cmd"
        fi
    fi
    if [[ -z "$command_val" ]];then
        if [ -z "$NODE_TYPE" -o "$NODE_TYPE" == "first" ] && [[ "$CLI_SKIP_PRECHECK_WARNING" != "true" ]];then
            echo -e "! Warning: The '$command' command is not in the /bin or /usr/bin directory, the script will use the '$command' variable in the current user's system environment."
            read -p "Are you sure to continue(Y/N)?" confirm
            if [ "$confirm" != 'y' -a "$confirm" != 'Y' ]; then
                exit 1
            fi
        fi
        command_val="$command"
    fi

    eval "${command_var}=\"${command_val}\""
    export $command_var
done

initTmpFolderAndLogfile

if [ -s ${CURRENTDIR}/cdf/properties/images/images.properties ]; then
    source ${CURRENTDIR}/cdf/properties/images/images.properties
    source ${CURRENTDIR}/cdf/properties/images/charts.properties
elif [ -s ${CURRENTDIR}/properties/images/images.properties ]; then
    source ${CURRENTDIR}/properties/images/images.properties
    source ${CURRENTDIR}/properties/images/charts.properties
else
    write_log "fatal" "File images.properties is not found or it's empty. $MF_SUPPORT_MSG"
fi

if [ "$INSTALLED_TYPE" = "CLASSIC" ];then
    if [ -s ${CURRENTDIR}/k8s/properties/images/k8s_images.properties ]; then
        source ${CURRENTDIR}/k8s/properties/images/k8s_images.properties
    elif [ -s ${CURRENTDIR}/properties/images/k8s_images.properties ]; then
        source ${CURRENTDIR}/properties/images/k8s_images.properties
    else
        write_log "fatal" "File k8s_images.properties is not found or it's empty. $MF_SUPPORT_MSG"
    fi
    if [ -s ${CURRENTDIR}/k8s/properties/images/k8s_charts.properties ]; then
        source ${CURRENTDIR}/k8s/properties/images/k8s_charts.properties
    elif [ -s ${CURRENTDIR}/properties/images/k8s_charts.properties ]; then
        source ${CURRENTDIR}/properties/images/k8s_charts.properties
    else
        write_log "fatal" "File k8s_charts.properties is not found or it's empty. $MF_SUPPORT_MSG"
    fi
fi

###########
# BYOK
###########
if [ "$INSTALLED_TYPE" = "BYOK" ];then
    prechecksForBYOK
    sourceCdfProfile
    if [[ -n "$SILENT_LIFECYCLE" ]];then
        # update
        operationsEntry
        exit 0
    fi

    # install
    # clean for previous install
    export STEPS_FILE="$CDF_INSTALL_RUNTIME_HOME/.cdfInstallCompletedSteps_$(cat ${CURRENTDIR}/version.txt).tmp"
    # CDF_ADMIN_TASKS assign in init_BYOK(), so do not use CDF_ADMIN_TASKS
    cdf_admin_task="${CLI_CDF_ADMIN_TASKS:-"ns,pv,cr,pc"}"
    NS_ADMIN=
    if [[ "$cdf_admin_task" =~ (^|,)ns(,|$) ]];then
        NS_ADMIN=false
        if [ "$(exec_cmd "kubectl get namespace ${CDF_NAMESPACE} 2>/dev/null"; echo $?)" -ne 0 ]; then
            exec_cmd "$RM -f $PREVIOUS_INSTALL_CONFIG"
            exec_cmd "$RM -f $STEPS_FILE"
        fi
    else
        NS_ADMIN=true
    fi
    checkInstallCompleted
    if [[ -n "$JUST_FOR_CDF_SILENT_RERUN" ]]; then
        switchLogPath
    fi
    [[ ! -f "$STEPS_FILE" ]] && checkOpenssl
    [[ ! -f "$STEPS_FILE" ]] && checkUserHomeExist
    init_BYOK
    [[ ! -f "$STEPS_FILE" ]] && [[ "$NS_ADMIN" == "true" ]] && checkNsResources
    [[ ! -f "$STEPS_FILE" ]] && checkAppHubHelmValues
    [[ ! -f "$STEPS_FILE" ]] && checkConfigJsonSchema
    [[ ! -f "$STEPS_FILE" ]] && checkAllCaNumber
    [[ ! -f "$STEPS_FILE" ]] && checkCdfAdminPv

    if [[ "$CAPS_SUITE_DEPLOYMENT_MANAGEMENT" == "true" ]];then
        checkDBConflicts
    fi
    createSuperUser
    getPvcAccessModes
    getVolumeSizes
    getSuiteName
    setenv
    # start create "$STEPS_FILE"
    createContinueConfig
    copyFile2DestForBYOK
    getClusterName

    sourceCdfProfile
    createNamespace
    checkStorageSecret
    configureRBAC
    createRegistrypullSecret
    createCdfPkiSecret

    configNfsProvisioner
    checkDeployerNFSForBYOK
    preCheckSilentConfigForBYOK
    testIdmDbConnection
    if [[ "$CAPS_SUITE_DEPLOYMENT_MANAGEMENT" == "true" ]];then
        checkCdfapiserverDbParameter
        testCdfapiserverDbConnection
    fi

    if [[ "$NS_ADMIN" == "true" ]];then
        # suite
        if [[ -z "$SILENT_CONFIG_FILE" ]] || [[ -n "$METADATA" ]]; then
            createNsForDeployment
            pathNamespaceForNsAdmin
        fi
    fi

    createFeatureGatesConfigMap
    deployMiniCdf
    checkComponentPodsStatus

    if [[ "$CAPS_SUITE_DEPLOYMENT_MANAGEMENT" == "true" ]];then
        waitCdfApiServerReady
        uploadMetadata
    fi

    enableK8sBackup

    finalize
    write_log "info" "Successfully completed configuring the $PRODUCT_SHORT_NAME on this server!"

    if [ -z "$SILENT_CONFIG_FILE" ];then
        write_log "info" "1) MAKE SURE the port 3000/tcp on ${EXTERNAL_ACCESS_HOST}
                                is accessible out of cluster.
                             2) Please enter the URL https://${EXTERNAL_ACCESS_HOST}:3000
                                in your browser and log on to the installation portal with the created
                                administrator credentials (login name: admin) to complete the installation.
                             3) If you can't access the URL mentioned above.
                                You may need to: for example, patch load balancer or firewall rules.
                                Please contact your cloud provider administrator for help."
    fi

    installCdfAlias
    exec_cmd "chmod 600 $LOG_FILE"
    write_log "cata" "installation completed"
    cdfAliasWarining
    showCdfEnvTips

    ####START_SILENT_INSTALL#####
    if [ -n "$SILENT_CONFIG_FILE" ]; then
        if [[ "$CAPS_SUITE_DEPLOYMENT_MANAGEMENT" == "true" ]];then
            createDeployment
        fi
        if [ -n "$DEPLOYMENT_NAME" ];then
            deployment_name="-d $DEPLOYMENT_NAME"
        fi
        if [ -n "$SUPER_USERPWD" ]; then silent_pwd="-p '$(echo "$SUPER_USERPWD"|sed -e "s/'/'\\\\''/g")'"; fi
        if [ -n "$SILENT_TIMEOUT_MINUTES" ]; then silent_timeout_opt="-t $SILENT_TIMEOUT_MINUTES"; fi
        if [ -n "$METADATA" ]; then silent_metadata_opt="-m $METADATA"; fi
        eval "${CDF_HOME}/tools/silent-install/silent_main.sh -c '$SILENT_CONFIG_FILE' -L 'install' -u 'admin' $silent_pwd -e '$SILENT_END_STATE' $silent_timeout_opt $deployment_name -T '$INSTALLED_TYPE' $silent_metadata_opt --external-rep 2>>$LOG_FILE"
        if [ $? -ne 0 ]; then
             write_log "fatal" "Silent installation failed. Refer to $CDF_HOME/log/silent-install/silent-install.${LOG_FILE_TIMESTAMP}.log file for detail information."
        fi
    fi
    #############################
    exit 0
fi

###########
# CLASSIC
###########
# check infra ready for update/reconfig
checkInfraReady
if [ -z "$SILENT_LIFECYCLE" ]; then
    checkInstallCompleted
    if [[ -n "$JUST_FOR_CDF_SILENT_RERUN" ]]; then
        switchLogPath
    fi
    write_log "cata" "* initializing"
    init
    checkAll

    write_log "info" "Start to install the $PRODUCT_SHORT_NAME on this server"
    getPvcAccessModes
    getVolumeSizes
    getSuiteName
    setenv
    configFirewallSettings
    if [[ "$NODE_TYPE" == "first" ]];then
        # start create "$STEPS_FILE"
        createContinueConfig
    fi
    copyFile2Dest
    getClusterName
    installInfra
    if [[ "$NODE_TYPE" == "first" ]] || [[ "$NODE_TYPE" == "master" ]];then
        # TODO:
        configureKeepAlivedCm
        configureKeepAlived
    fi

    if [[ "$NODE_TYPE" == "first" ]];then
        sourceCdfProfile
        createNamespace
        configureRBAC
        configureNodeManagerRBAC
        # TODO:
        createCdfClusterHostConfigMap
        createRegistryCasConfigMap
        createRegistrypullSecret
        createEtcdClientCertSecret
        createCdfPkiSecret

        configureDNSExternalName
        configNfsProvisioner
        configureCdfVolume
        testIdmDbConnection
        if [[ "$CAPS_SUITE_DEPLOYMENT_MANAGEMENT" == "true" ]];then
            testCdfapiserverDbConnection
        fi

        createFeatureGatesConfigMap
        deployMiniCdf
        startLogrotate
        startKubeRgistry
    fi

    if [[ "$NODE_TYPE" == "first" ]];then
        packInstallerZip
        movePackageToVolume
        if [ "$DOCKER_REPOSITORY" = "localhost:5000" ]; then
            pushImages2LocalRegistry
        fi

        checkComponentPodsStatus

        if [[ "$CAPS_SUITE_DEPLOYMENT_MANAGEMENT" == "true" ]];then
            waitCdfApiServerReady
            uploadMetadata
        fi

        enableK8sBackup
    fi

    scaleKubeRegistry

    finalize
    write_log "info" "Successfully completed configuring the $PRODUCT_SHORT_NAME on this server!"
    if [ "$NODE_TYPE" = "first" -a -z "$SILENT_CONFIG_FILE" ]; then
        FIRST_NODE_FQDN=$(hostname -f | tr '[:upper:]' '[:lower:]')
        write_log "info" "1) Please enter the URL https://${FIRST_NODE_FQDN}:3000
                                in your browser and log on to the installation portal with the created
                                administrator credentials (login name: admin) to complete the installation.
                             2) When extending nodes, please make sure the provided user has permission
                                to execute scripts under temporary directory '$TMP_FOLDER' on the nodes."
    fi
    installCdfAlias
    write_log "cata" "installation completed"
    cdfAliasWarining
    showCdfEnvTips

    ####START_SILENT_INSTALL#####
    if [ -n "$SILENT_CONFIG_FILE" ]; then
        if [[ "$CAPS_SUITE_DEPLOYMENT_MANAGEMENT" == "true" ]];then
            createDeployment
        fi
        if [ -n "$DEPLOYMENT_NAME" ];then
            deployment_name="-d $DEPLOYMENT_NAME"
        fi
        if [ -n "$SUPER_USERPWD" ]; then silent_pwd="-p '$(echo "$SUPER_USERPWD"|sed -e "s/'/'\\\\''/g")'"; fi
        if [ -n "$INTERNAL_KUBE_REGISTRY_USERNAME" ]; then silent_registry_user_opt="-U $INTERNAL_KUBE_REGISTRY_USERNAME"; fi
        if [ -n "$SUPER_USERPWD" ]; then silent_registry_pwd_opt="-P '$(echo "$SUPER_USERPWD"|sed -e "s/'/'\\\\''/g")'"; fi
        eval "${CURRENTDIR}/cdf/tools/silent-install/silent_main.sh -c '$SILENT_CONFIG_FILE' -L 'install' -u 'admin' $silent_pwd -e '$SILENT_END_STATE' $silent_imgfolder_opt $silent_timeout_opt $silent_ext_rep $deployment_name -T '$INSTALLED_TYPE' $silent_registry_pwd_opt $silent_registry_user_opt 2>>$LOG_FILE"
        if [ $? -ne 0 ]; then
             write_log "fatal" "Silent installation failed. Refer to $CDF_HOME/log/silent-install/silent-install.${LOG_FILE_TIMESTAMP}.log file for detail information."
        fi
    fi
    #############################
else
    operationsEntry
fi
